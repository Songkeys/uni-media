(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a4, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a4, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a4, prop, b3[prop]);
      }
    return a4;
  };
  var __spreadProps = (a4, b3) => __defProps(a4, __getOwnPropDescs(b3));
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
      if (decorator = decorators[i6])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_shim();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i6 = 0, len = code.length; i6 < len; ++i6) {
        lookup[i6] = code[i6];
        revLookup[code.charCodeAt(i6)] = i6;
      }
      var i6;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i7;
        for (i7 = 0; i7 < len2; i7 += 4) {
          tmp = revLookup[b64.charCodeAt(i7)] << 18 | revLookup[b64.charCodeAt(i7 + 1)] << 12 | revLookup[b64.charCodeAt(i7 + 2)] << 6 | revLookup[b64.charCodeAt(i7 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i7)] << 2 | revLookup[b64.charCodeAt(i7 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i7)] << 10 | revLookup[b64.charCodeAt(i7 + 1)] << 4 | revLookup[b64.charCodeAt(i7 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i7 = start; i7 < end; i7 += 3) {
          tmp = (uint8[i7] << 16 & 16711680) + (uint8[i7 + 1] << 8 & 65280) + (uint8[i7 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i7 = 0, len22 = len2 - extraBytes; i7 < len22; i7 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i7, i7 + maxChunkLength > len22 ? len22 : i7 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      init_shim();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e8, m3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i6 = isLE ? nBytes - 1 : 0;
        var d3 = isLE ? -1 : 1;
        var s6 = buffer[offset + i6];
        i6 += d3;
        e8 = s6 & (1 << -nBits) - 1;
        s6 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e8 = e8 * 256 + buffer[offset + i6], i6 += d3, nBits -= 8) {
        }
        m3 = e8 & (1 << -nBits) - 1;
        e8 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i6], i6 += d3, nBits -= 8) {
        }
        if (e8 === 0) {
          e8 = 1 - eBias;
        } else if (e8 === eMax) {
          return m3 ? NaN : (s6 ? -1 : 1) * Infinity;
        } else {
          m3 = m3 + Math.pow(2, mLen);
          e8 = e8 - eBias;
        }
        return (s6 ? -1 : 1) * m3 * Math.pow(2, e8 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e8, m3, c3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i6 = isLE ? 0 : nBytes - 1;
        var d3 = isLE ? 1 : -1;
        var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m3 = isNaN(value) ? 1 : 0;
          e8 = eMax;
        } else {
          e8 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c3 = Math.pow(2, -e8)) < 1) {
            e8--;
            c3 *= 2;
          }
          if (e8 + eBias >= 1) {
            value += rt2 / c3;
          } else {
            value += rt2 * Math.pow(2, 1 - eBias);
          }
          if (value * c3 >= 2) {
            e8++;
            c3 /= 2;
          }
          if (e8 + eBias >= eMax) {
            m3 = 0;
            e8 = eMax;
          } else if (e8 + eBias >= 1) {
            m3 = (value * c3 - 1) * Math.pow(2, mLen);
            e8 = e8 + eBias;
          } else {
            m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e8 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i6] = m3 & 255, i6 += d3, m3 /= 256, mLen -= 8) {
        }
        e8 = e8 << mLen | m3;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i6] = e8 & 255, i6 += d3, e8 /= 256, eLen -= 8) {
        }
        buffer[offset + i6 - d3] |= s6 * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      init_shim();
      var base64 = require_base64_js();
      var ieee7542 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer7;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer7.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer7.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e8) {
          return false;
        }
      }
      Object.defineProperty(Buffer7.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer7.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer7.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer7.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer7.prototype);
        return buf;
      }
      function Buffer7(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer7.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer7.from(valueOf, encodingOrOffset, length);
        }
        var b3 = fromObject(value);
        if (b3)
          return b3;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer7.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      Buffer7.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer7.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer7, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer7.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer7.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer7.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer7.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength(string, encoding) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i6 = 0; i6 < length; i6 += 1) {
          buf[i6] = array[i6] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer7.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer7.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer7.alloc(+length);
      }
      Buffer7.isBuffer = function isBuffer(b3) {
        return b3 != null && b3._isBuffer === true && b3 !== Buffer7.prototype;
      };
      Buffer7.compare = function compare(a4, b3) {
        if (isInstance(a4, Uint8Array))
          a4 = Buffer7.from(a4, a4.offset, a4.byteLength);
        if (isInstance(b3, Uint8Array))
          b3 = Buffer7.from(b3, b3.offset, b3.byteLength);
        if (!Buffer7.isBuffer(a4) || !Buffer7.isBuffer(b3)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a4 === b3)
          return 0;
        var x3 = a4.length;
        var y3 = b3.length;
        for (var i6 = 0, len = Math.min(x3, y3); i6 < len; ++i6) {
          if (a4[i6] !== b3[i6]) {
            x3 = a4[i6];
            y3 = b3[i6];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      Buffer7.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer7.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer7.alloc(0);
        }
        var i6;
        if (length === void 0) {
          length = 0;
          for (i6 = 0; i6 < list.length; ++i6) {
            length += list[i6].length;
          }
        }
        var buffer = Buffer7.allocUnsafe(length);
        var pos = 0;
        for (i6 = 0; i6 < list.length; ++i6) {
          var buf = list[i6];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer7.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer7.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer7.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer7.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer7.prototype._isBuffer = true;
      function swap(b3, n8, m3) {
        var i6 = b3[n8];
        b3[n8] = b3[m3];
        b3[m3] = i6;
      }
      Buffer7.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i6 = 0; i6 < len; i6 += 2) {
          swap(this, i6, i6 + 1);
        }
        return this;
      };
      Buffer7.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i6 = 0; i6 < len; i6 += 4) {
          swap(this, i6, i6 + 3);
          swap(this, i6 + 1, i6 + 2);
        }
        return this;
      };
      Buffer7.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i6 = 0; i6 < len; i6 += 8) {
          swap(this, i6, i6 + 7);
          swap(this, i6 + 1, i6 + 6);
          swap(this, i6 + 2, i6 + 5);
          swap(this, i6 + 3, i6 + 4);
        }
        return this;
      };
      Buffer7.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer7.prototype.toLocaleString = Buffer7.prototype.toString;
      Buffer7.prototype.equals = function equals(b3) {
        if (!Buffer7.isBuffer(b3))
          throw new TypeError("Argument must be a Buffer");
        if (this === b3)
          return true;
        return Buffer7.compare(this, b3) === 0;
      };
      Buffer7.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer7.prototype[customInspectSymbol] = Buffer7.prototype.inspect;
      }
      Buffer7.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer7.from(target, target.offset, target.byteLength);
        }
        if (!Buffer7.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x3 = thisEnd - thisStart;
        var y3 = end - start;
        var len = Math.min(x3, y3);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i6 = 0; i6 < len; ++i6) {
          if (thisCopy[i6] !== targetCopy[i6]) {
            x3 = thisCopy[i6];
            y3 = targetCopy[i6];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer7.from(val, encoding);
        }
        if (Buffer7.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i7) {
          if (indexSize === 1) {
            return buf[i7];
          } else {
            return buf.readUInt16BE(i7 * indexSize);
          }
        }
        var i6;
        if (dir) {
          var foundIndex = -1;
          for (i6 = byteOffset; i6 < arrLength; i6++) {
            if (read2(arr, i6) === read2(val, foundIndex === -1 ? 0 : i6 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i6;
              if (i6 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i6 -= i6 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i6 = byteOffset; i6 >= 0; i6--) {
            var found = true;
            for (var j2 = 0; j2 < valLength; j2++) {
              if (read2(arr, i6 + j2) !== read2(val, j2)) {
                found = false;
                break;
              }
            }
            if (found)
              return i6;
          }
        }
        return -1;
      }
      Buffer7.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer7.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer7.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i6 = 0; i6 < length; ++i6) {
          var parsed = parseInt(string.substr(i6 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i6;
          buf[offset + i6] = parsed;
        }
        return i6;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer7.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer7.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i6 = start;
        while (i6 < end) {
          var firstByte = buf[i6];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i6 + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i6 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i6 + 1];
                thirdByte = buf[i6 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i6 + 1];
                thirdByte = buf[i6 + 2];
                fourthByte = buf[i6 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i6 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i6 = 0;
        while (i6 < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i6, i6 += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i6 = start; i6 < end; ++i6) {
          ret += String.fromCharCode(buf[i6] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i6 = start; i6 < end; ++i6) {
          ret += String.fromCharCode(buf[i6]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i6 = start; i6 < end; ++i6) {
          out += hexSliceLookupTable[buf[i6]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i6 = 0; i6 < bytes.length - 1; i6 += 2) {
          res += String.fromCharCode(bytes[i6] + bytes[i6 + 1] * 256);
        }
        return res;
      }
      Buffer7.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer7.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer7.prototype.readUintLE = Buffer7.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i6 = 0;
        while (++i6 < byteLength2 && (mul *= 256)) {
          val += this[offset + i6] * mul;
        }
        return val;
      };
      Buffer7.prototype.readUintBE = Buffer7.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer7.prototype.readUint8 = Buffer7.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer7.prototype.readUint16LE = Buffer7.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer7.prototype.readUint16BE = Buffer7.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer7.prototype.readUint32LE = Buffer7.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer7.prototype.readUint32BE = Buffer7.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer7.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i6 = 0;
        while (++i6 < byteLength2 && (mul *= 256)) {
          val += this[offset + i6] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer7.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i6 = byteLength2;
        var mul = 1;
        var val = this[offset + --i6];
        while (i6 > 0 && (mul *= 256)) {
          val += this[offset + --i6] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer7.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer7.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer7.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer7.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer7.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer7.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee7542.read(this, offset, true, 23, 4);
      };
      Buffer7.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee7542.read(this, offset, false, 23, 4);
      };
      Buffer7.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee7542.read(this, offset, true, 52, 8);
      };
      Buffer7.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee7542.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer7.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer7.prototype.writeUintLE = Buffer7.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i6 = 0;
        this[offset] = value & 255;
        while (++i6 < byteLength2 && (mul *= 256)) {
          this[offset + i6] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer7.prototype.writeUintBE = Buffer7.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i6 = byteLength2 - 1;
        var mul = 1;
        this[offset + i6] = value & 255;
        while (--i6 >= 0 && (mul *= 256)) {
          this[offset + i6] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer7.prototype.writeUint8 = Buffer7.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer7.prototype.writeUint16LE = Buffer7.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer7.prototype.writeUint16BE = Buffer7.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer7.prototype.writeUint32LE = Buffer7.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer7.prototype.writeUint32BE = Buffer7.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer7.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i6 = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i6 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i6 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i6] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer7.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i6 = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i6] = value & 255;
        while (--i6 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i6 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i6] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer7.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer7.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer7.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer7.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer7.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee7542.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer7.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer7.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee7542.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer7.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer7.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer7.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer7.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer7.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer7.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i6;
        if (typeof val === "number") {
          for (i6 = start; i6 < end; ++i6) {
            this[i6] = val;
          }
        } else {
          var bytes = Buffer7.isBuffer(val) ? val : Buffer7.from(val, encoding);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i6 = 0; i6 < end - start; ++i6) {
            this[i6 + start] = bytes[i6 % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i6 = 0; i6 < length; ++i6) {
          codePoint = string.charCodeAt(i6);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i6 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i6 = 0; i6 < str.length; ++i6) {
          byteArray.push(str.charCodeAt(i6) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c3, hi2, lo2;
        var byteArray = [];
        for (var i6 = 0; i6 < str.length; ++i6) {
          if ((units -= 2) < 0)
            break;
          c3 = str.charCodeAt(i6);
          hi2 = c3 >> 8;
          lo2 = c3 % 256;
          byteArray.push(lo2);
          byteArray.push(hi2);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i6 = 0; i6 < length; ++i6) {
          if (i6 + offset >= dst.length || i6 >= src.length)
            break;
          dst[i6 + offset] = src[i6];
        }
        return i6;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i6 = 0; i6 < 16; ++i6) {
          var i16 = i6 * 16;
          for (var j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i6] + alphabet[j2];
          }
        }
        return table;
      }();
    }
  });

  // node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/process/browser.js"(exports, module) {
      init_shim();
      var process2 = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e8) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e8) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e8) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e9) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e8) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e9) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i6 = 1; i6 < arguments.length; i6++) {
            args[i6 - 1] = arguments[i6];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop() {
      }
      process2.on = noop;
      process2.addListener = noop;
      process2.once = noop;
      process2.off = noop;
      process2.removeListener = noop;
      process2.removeAllListeners = noop;
      process2.emit = noop;
      process2.prependListener = noop;
      process2.prependOnceListener = noop;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/node-stdlib-browser/helpers/esbuild/shim.js
  var import_buffer, import_process, _globalThis;
  var init_shim = __esm({
    "node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
      import_buffer = __toESM(require_buffer());
      import_process = __toESM(require_browser());
      _globalThis = function(Object2) {
        function get() {
          var _global3 = this || self;
          delete Object2.prototype.__magic__;
          return _global3;
        }
        if (typeof globalThis === "object") {
          return globalThis;
        }
        if (this) {
          return get();
        } else {
          Object2.defineProperty(Object2.prototype, "__magic__", {
            configurable: true,
            get
          });
          var _global2 = __magic__;
          return _global2;
        }
      }(Object);
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      init_shim();
      var R2 = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R2 && typeof R2.ownKeys === "function") {
        ReflectOwnKeys = R2.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n8) {
        if (typeof n8 !== "number" || n8 < 0 || NumberIsNaN(n8)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n8 + ".");
        }
        this._maxListeners = n8;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i6 = 1; i6 < arguments.length; i6++)
          args.push(arguments[i6]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er2;
          if (args.length > 0)
            er2 = args[0];
          if (er2 instanceof Error) {
            throw er2;
          }
          var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
          err.context = er2;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i6 = 0; i6 < len; ++i6)
            ReflectApply(listeners[i6], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m3;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m3 = _getMaxListeners(target);
          if (m3 > 0 && existing.length > m3 && !existing.warned) {
            existing.warned = true;
            var w3 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w3.name = "MaxListenersExceededWarning";
            w3.emitter = target;
            w3.type = type;
            w3.count = existing.length;
            ProcessEmitWarning(w3);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i6, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i6 = list.length - 1; i6 >= 0; i6--) {
            if (list[i6] === listener || list[i6].listener === listener) {
              originalListener = list[i6].listener;
              position = i6;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i6;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i6 = 0; i6 < keys.length; ++i6) {
            key = keys[i6];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i6 = listeners.length - 1; i6 >= 0; i6--) {
            this.removeListener(type, listeners[i6]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n8) {
        var copy = new Array(n8);
        for (var i6 = 0; i6 < n8; ++i6)
          copy[i6] = arr[i6];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i6 = 0; i6 < ret.length; ++i6) {
          ret[i6] = arr[i6].listener || arr[i6];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      init_shim();
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      init_shim();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i6 = 0; i6 < boundLength; i6++) {
          boundArgs.push("$" + i6);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      init_shim();
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e8) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e8) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x3) {
        return x3.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn2 = doEval2("%AsyncGeneratorFunction%");
          if (fn2) {
            value = fn2.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/g, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i6 = 1, isOwn = true; i6 < parts.length; i6 += 1) {
          var part = parts[i6];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i6 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e8) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      init_shim();
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      init_shim();
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e8) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn2) {
        if (typeof fn2 !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn2))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn2);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn2) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      init_shim();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_3) {
          if (_3 !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e8) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e8) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
      module.exports = reflectApply ? function isCallable(value) {
        if (value === documentDotAll) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (typeof value === "function" && !value.prototype) {
          return true;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e8) {
          if (e8 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value);
      } : function isCallable(value) {
        if (value === documentDotAll) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (typeof value === "function" && !value.prototype) {
          return true;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        return strClass === fnClass || strClass === genClass;
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports, module) {
      "use strict";
      init_shim();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i6 = 0, len = array.length; i6 < len; i6++) {
          if (hasOwnProperty.call(array, i6)) {
            if (receiver == null) {
              iterator(array[i6], i6, array);
            } else {
              iterator.call(receiver, array[i6], i6, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i6 = 0, len = string.length; i6 < len; i6++) {
          if (receiver == null) {
            iterator(string.charAt(i6), i6, string);
          } else {
            iterator.call(receiver, string.charAt(i6), i6, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k3 in object) {
          if (hasOwnProperty.call(object, k3)) {
            if (receiver == null) {
              iterator(object[k3], k3, object);
            } else {
              iterator.call(receiver, object[k3], k3, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      init_shim();
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g3 = typeof globalThis === "undefined" ? window : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i6 = 0; i6 < possibleNames.length; i6++) {
          if (typeof g3[possibleNames[i6]] === "function") {
            out[out.length] = possibleNames[i6];
          }
        }
        return out;
      };
    }
  });

  // node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
  var require_getOwnPropertyDescriptor = __commonJS({
    "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e8) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g3 = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i6 = 0; i6 < array.length; i6 += 1) {
          if (array[i6] === value) {
            return i6;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g3[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e8) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g3 = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g3[typedArray] === "function") {
            var arr = new g3[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e8) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      init_shim();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f3) {
        return f3.call.bind(f3);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e8) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      init_shim();
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      init_shim();
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      init_shim();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i6 = 0; i6 < keys.length; i6++) {
          descriptors[keys[i6]] = Object.getOwnPropertyDescriptor(obj, keys[i6]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f3) {
        if (!isString(f3)) {
          var objects = [];
          for (var i6 = 0; i6 < arguments.length; i6++) {
            objects.push(inspect(arguments[i6]));
          }
          return objects.join(" ");
        }
        var i6 = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f3).replace(formatRegExp, function(x4) {
          if (x4 === "%%")
            return "%";
          if (i6 >= len)
            return x4;
          switch (x4) {
            case "%s":
              return String(args[i6++]);
            case "%d":
              return Number(args[i6++]);
            case "%j":
              try {
                return JSON.stringify(args[i6++]);
              } catch (_3) {
                return "[Circular]";
              }
            default:
              return x4;
          }
        });
        for (var x3 = args[i6]; i6 < len; x3 = args[++i6]) {
          if (isNull(x3) || !isObject(x3)) {
            str += " " + x3;
          } else {
            str += " " + inspect(x3);
          }
        }
        return str;
      };
      exports.deprecate = function(fn2, msg) {
        if (typeof import_process.default !== "undefined" && import_process.default.noDeprecation === true) {
          return fn2;
        }
        if (typeof import_process.default === "undefined") {
          return function() {
            return exports.deprecate(fn2, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (import_process.default.throwDeprecation) {
              throw new Error(msg);
            } else if (import_process.default.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn2.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (import_process.default.env.NODE_DEBUG) {
        debugEnv = import_process.default.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = import_process.default.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n8 = value.name ? ": " + value.name : "";
          base = " [Function" + n8 + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i6 = 0, l6 = value.length; i6 < l6; ++i6) {
          if (hasOwnProperty(value, String(i6))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i6), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar2) {
        return Array.isArray(ar2);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re2) {
        return isObject(re2) && objectToString(re2) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d3) {
        return isObject(d3) && objectToString(d3) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e8) {
        return isObject(e8) && (objectToString(e8) === "[object Error]" || e8 instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o7) {
        return Object.prototype.toString.call(o7);
      }
      function pad(n8) {
        return n8 < 10 ? "0" + n8.toString(10) : n8.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d3 = new Date();
        var time = [
          pad(d3.getHours()),
          pad(d3.getMinutes()),
          pad(d3.getSeconds())
        ].join(":");
        return [d3.getDate(), months[d3.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i6 = keys.length;
        while (i6--) {
          origin[keys[i6]] = add[keys[i6]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn2 = original[kCustomPromisifiedSymbol];
          if (typeof fn2 !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn2;
        }
        function fn2() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i6 = 0; i6 < arguments.length; i6++) {
            args.push(arguments[i6]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(fn2, getOwnPropertyDescriptors(original));
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i6 = 0; i6 < arguments.length; i6++) {
            args.push(arguments[i6]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(function(ret) {
            import_process.default.nextTick(cb.bind(null, null, ret));
          }, function(rej) {
            import_process.default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          });
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i6 = 1; i6 < arguments.length; i6++) {
          var source = arguments[i6] != null ? arguments[i6] : {};
          if (i6 % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i6 = 0; i6 < props.length; i6++) {
          var descriptor = props[i6];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer7 = _require.Buffer;
      var _require2 = require_util();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer7.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v3) {
            var entry = {
              data: v3,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v3) {
            var entry = {
              data: v3,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s6) {
            if (this.length === 0)
              return "";
            var p3 = this.head;
            var ret = "" + p3.data;
            while (p3 = p3.next) {
              ret += s6 + p3.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n8) {
            if (this.length === 0)
              return Buffer7.alloc(0);
            var ret = Buffer7.allocUnsafe(n8 >>> 0);
            var p3 = this.head;
            var i6 = 0;
            while (p3) {
              copyBuffer(p3.data, ret, i6);
              i6 += p3.data.length;
              p3 = p3.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n8, hasStrings) {
            var ret;
            if (n8 < this.head.data.length) {
              ret = this.head.data.slice(0, n8);
              this.head.data = this.head.data.slice(n8);
            } else if (n8 === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n8) {
            var p3 = this.head;
            var c3 = 1;
            var ret = p3.data;
            n8 -= ret.length;
            while (p3 = p3.next) {
              var str = p3.data;
              var nb2 = n8 > str.length ? str.length : n8;
              if (nb2 === str.length)
                ret += str;
              else
                ret += str.slice(0, n8);
              n8 -= nb2;
              if (n8 === 0) {
                if (nb2 === str.length) {
                  ++c3;
                  if (p3.next)
                    this.head = p3.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p3;
                  p3.data = str.slice(nb2);
                }
                break;
              }
              ++c3;
            }
            this.length -= c3;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n8) {
            var ret = Buffer7.allocUnsafe(n8);
            var p3 = this.head;
            var c3 = 1;
            p3.data.copy(ret);
            n8 -= p3.data.length;
            while (p3 = p3.next) {
              var buf = p3.data;
              var nb2 = n8 > buf.length ? buf.length : n8;
              buf.copy(ret, ret.length - n8, 0, nb2);
              n8 -= nb2;
              if (n8 === 0) {
                if (nb2 === buf.length) {
                  ++c3;
                  if (p3.next)
                    this.head = p3.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p3;
                  p3.data = buf.slice(nb2);
                }
                break;
              }
              ++c3;
            }
            this.length -= c3;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_3, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i6) {
            return String(i6);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser2 = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      init_shim();
      module.exports = deprecate;
      function deprecate(fn2, msg) {
        if (config("noDeprecation")) {
          return fn2;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn2.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!window.localStorage)
            return false;
        } catch (_3) {
          return false;
        }
        var val = window.localStorage[name];
        if (val == null)
          return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser();
      var Buffer7 = require_buffer().Buffer;
      var OurUint8Array = window.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer7.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer7.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er2) {
          onwrite(stream, er2);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_3) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er2 = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er2);
        import_process.default.nextTick(cb, er2);
      }
      function validChunk(stream, state, chunk, cb) {
        var er2;
        if (chunk === null) {
          er2 = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er2) {
          errorOrDestroy(stream, er2);
          import_process.default.nextTick(cb, er2);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer7.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer7.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er2, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er2);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er2);
        } else {
          cb(er2);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er2);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er2) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er2)
          onwriteError(stream, state, sync, er2, cb);
        else {
          var finished = needFinish(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l6 = state.bufferedRequestCount;
          var buffer = new Array(l6);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable = require_stream_readable();
      var Writable = require_stream_writable();
      require_inherits_browser()(Duplex, Readable);
      {
        keys = objectKeys(Writable.prototype);
        for (v3 = 0; v3 < keys.length; v3++) {
          method = keys[v3];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v3;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      init_shim();
      var buffer = require_buffer();
      var Buffer7 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer7.from && Buffer7.alloc && Buffer7.allocUnsafe && Buffer7.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer7(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer7.prototype);
      copyProps(Buffer7, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer7(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer7(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer7(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_shim();
      var Buffer7 = require_safe_buffer().Buffer;
      var isEncoding = Buffer7.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer7.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb2;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb2 = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb2 = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb2 = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer7.allocUnsafe(nb2);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r5;
        var i6;
        if (this.lastNeed) {
          r5 = this.fillLast(buf);
          if (r5 === void 0)
            return "";
          i6 = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i6 = 0;
        }
        if (i6 < buf.length)
          return r5 ? r5 + this.text(buf, i6) : this.text(buf, i6);
        return r5 || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i6) {
        var j2 = buf.length - 1;
        if (j2 < i6)
          return 0;
        var nb2 = utf8CheckByte(buf[j2]);
        if (nb2 >= 0) {
          if (nb2 > 0)
            self2.lastNeed = nb2 - 1;
          return nb2;
        }
        if (--j2 < i6 || nb2 === -2)
          return 0;
        nb2 = utf8CheckByte(buf[j2]);
        if (nb2 >= 0) {
          if (nb2 > 0)
            self2.lastNeed = nb2 - 2;
          return nb2;
        }
        if (--j2 < i6 || nb2 === -2)
          return 0;
        nb2 = utf8CheckByte(buf[j2]);
        if (nb2 >= 0) {
          if (nb2 > 0) {
            if (nb2 === 2)
              nb2 = 0;
            else
              self2.lastNeed = nb2 - 3;
          }
          return nb2;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p3) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p3 = this.lastTotal - this.lastNeed;
        var r5 = utf8CheckExtraBytes(this, buf, p3);
        if (r5 !== void 0)
          return r5;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p3, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p3, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i6) {
        var total = utf8CheckIncomplete(this, buf, i6);
        if (!this.lastNeed)
          return buf.toString("utf8", i6);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i6, end);
      }
      function utf8End(buf) {
        var r5 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r5 + "\uFFFD";
        return r5;
      }
      function utf16Text(buf, i6) {
        if ((buf.length - i6) % 2 === 0) {
          var r5 = buf.toString("utf16le", i6);
          if (r5) {
            var c3 = r5.charCodeAt(r5.length - 1);
            if (c3 >= 55296 && c3 <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r5.slice(0, -1);
            }
          }
          return r5;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i6, buf.length - 1);
      }
      function utf16End(buf) {
        var r5 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r5 + this.lastChar.toString("utf16le", 0, end);
        }
        return r5;
      }
      function base64Text(buf, i6) {
        var n8 = (buf.length - i6) % 3;
        if (n8 === 0)
          return buf.toString("base64", i6);
        this.lastNeed = 3 - n8;
        this.lastTotal = 3;
        if (n8 === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i6, buf.length - n8);
      }
      function base64End(buf) {
        var r5 = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r5;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable;
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer7 = require_buffer().Buffer;
      var OurUint8Array = window.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer7.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer7.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn2) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn2);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn2);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn2);
        else
          emitter._events[event] = [fn2, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable))
          return new Readable(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer7.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er2;
          if (!skipChunkCheck)
            er2 = chunkInvalid(state, chunk);
          if (er2) {
            errorOrDestroy(stream, er2);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer7.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er2;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er2;
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p3 = this._readableState.buffer.head;
        var content = "";
        while (p3 !== null) {
          content += decoder.write(p3.data);
          p3 = p3.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n8) {
        if (n8 >= MAX_HWM) {
          n8 = MAX_HWM;
        } else {
          n8--;
          n8 |= n8 >>> 1;
          n8 |= n8 >>> 2;
          n8 |= n8 >>> 4;
          n8 |= n8 >>> 8;
          n8 |= n8 >>> 16;
          n8++;
        }
        return n8;
      }
      function howMuchToRead(n8, state) {
        if (n8 <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n8 !== n8) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n8 > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n8);
        if (n8 <= state.length)
          return n8;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n8) {
        debug("read", n8);
        n8 = parseInt(n8, 10);
        var state = this._readableState;
        var nOrig = n8;
        if (n8 !== 0)
          state.emittedReadable = false;
        if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n8 = howMuchToRead(n8, state);
        if (n8 === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n8 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n8 = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n8 > 0)
          ret = fromList(n8, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n8 = 0;
        } else {
          state.length -= n8;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n8 && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n8) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er2) {
          debug("onerror", er2);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er2);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i6 = 0; i6 < len; i6++) {
            dests[i6].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev2, fn2) {
        var res = Stream.prototype.on.call(this, ev2, fn2);
        var state = this._readableState;
        if (ev2 === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev2 === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev2, fn2) {
        var res = Stream.prototype.removeListener.call(this, ev2, fn2);
        if (ev2 === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.removeAllListeners = function(ev2) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev2 === "readable" || ev2 === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i6 in stream) {
          if (this[i6] === void 0 && typeof stream[i6] === "function") {
            this[i6] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i6);
          }
        }
        for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
          stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
        }
        this._read = function(n9) {
          debug("wrapped _read", n9);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable._fromList = fromList;
      Object.defineProperty(Readable.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n8, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n8 || n8 >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n8, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser();
          }
          return from(Readable, iterable, opts);
        };
      }
      function indexOf(xs2, x3) {
        for (var i6 = 0, l6 = xs2.length; i6 < l6; i6++) {
          if (xs2[i6] === x3)
            return i6;
        }
        return -1;
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er2, data) {
        var ts2 = this._transformState;
        ts2.transforming = false;
        var cb = ts2.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts2.writechunk = null;
        ts2.writecb = null;
        if (data != null)
          this.push(data);
        cb(er2);
        var rs2 = this._readableState;
        rs2.reading = false;
        if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
          this._read(rs2.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er2, data) {
            done(_this, er2, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts2 = this._transformState;
        ts2.writecb = cb;
        ts2.writechunk = chunk;
        ts2.writeencoding = encoding;
        if (!ts2.transforming) {
          var rs2 = this._readableState;
          if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
            this._read(rs2.highWaterMark);
        }
      };
      Transform.prototype._read = function(n8) {
        var ts2 = this._transformState;
        if (ts2.writechunk !== null && !ts2.transforming) {
          ts2.transforming = true;
          this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
        } else {
          ts2.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er2, data) {
        if (er2)
          return stream.emit("error", er2);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn2) {
        fn2();
      }
      function pipe(from, to2) {
        return from.pipe(to2);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i6) {
          var reading = i6 < streams.length - 1;
          var writing = i6 > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/readable-stream/readable-browser.js
  var require_readable_browser = __commonJS({
    "node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  });

  // node_modules/readable-web-to-node-stream/lib/index.js
  var require_lib = __commonJS({
    "node_modules/readable-web-to-node-stream/lib/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableWebToNodeStream = void 0;
      var readable_stream_1 = require_readable_browser();
      var ReadableWebToNodeStream2 = class extends readable_stream_1.Readable {
        constructor(stream) {
          super();
          this.bytesRead = 0;
          this.released = false;
          this.reader = stream.getReader();
        }
        async _read() {
          if (this.released) {
            this.push(null);
            return;
          }
          this.pendingRead = this.reader.read();
          const data = await this.pendingRead;
          delete this.pendingRead;
          if (data.done || this.released) {
            this.push(null);
          } else {
            this.bytesRead += data.value.length;
            this.push(data.value);
          }
        }
        async waitForReadToComplete() {
          if (this.pendingRead) {
            await this.pendingRead;
          }
        }
        async close() {
          await this.syncAndRelease();
        }
        async syncAndRelease() {
          this.released = true;
          await this.waitForReadToComplete();
          await this.reader.releaseLock();
        }
      };
      exports.ReadableWebToNodeStream = ReadableWebToNodeStream2;
    }
  });

  // node_modules/mime/Mime.js
  var require_Mime = __commonJS({
    "node_modules/mime/Mime.js"(exports, module) {
      "use strict";
      init_shim();
      function Mime() {
        this._types = /* @__PURE__ */ Object.create(null);
        this._extensions = /* @__PURE__ */ Object.create(null);
        for (let i6 = 0; i6 < arguments.length; i6++) {
          this.define(arguments[i6]);
        }
        this.define = this.define.bind(this);
        this.getType = this.getType.bind(this);
        this.getExtension = this.getExtension.bind(this);
      }
      Mime.prototype.define = function(typeMap, force) {
        for (let type in typeMap) {
          let extensions2 = typeMap[type].map(function(t5) {
            return t5.toLowerCase();
          });
          type = type.toLowerCase();
          for (let i6 = 0; i6 < extensions2.length; i6++) {
            const ext = extensions2[i6];
            if (ext[0] === "*") {
              continue;
            }
            if (!force && ext in this._types) {
              throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
            }
            this._types[ext] = type;
          }
          if (force || !this._extensions[type]) {
            const ext = extensions2[0];
            this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
          }
        }
      };
      Mime.prototype.getType = function(path) {
        path = String(path);
        let last = path.replace(/^.*[/\\]/, "").toLowerCase();
        let ext = last.replace(/^.*\./, "").toLowerCase();
        let hasPath = last.length < path.length;
        let hasDot = ext.length < last.length - 1;
        return (hasDot || !hasPath) && this._types[ext] || null;
      };
      Mime.prototype.getExtension = function(type) {
        type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
        return type && this._extensions[type.toLowerCase()] || null;
      };
      module.exports = Mime;
    }
  });

  // node_modules/mime/types/standard.js
  var require_standard = __commonJS({
    "node_modules/mime/types/standard.js"(exports, module) {
      init_shim();
      module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    }
  });

  // node_modules/mime/lite.js
  var require_lite = __commonJS({
    "node_modules/mime/lite.js"(exports, module) {
      "use strict";
      init_shim();
      var Mime = require_Mime();
      module.exports = new Mime(require_standard());
    }
  });

  // src/uni-media.ts
  init_shim();

  // node_modules/lit/index.js
  init_shim();

  // node_modules/@lit/reactive-element/reactive-element.js
  init_shim();

  // node_modules/@lit/reactive-element/css-tag.js
  init_shim();
  var t = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var e = Symbol();
  var n = /* @__PURE__ */ new Map();
  var s = class {
    constructor(t5, n8) {
      if (this._$cssResult$ = true, n8 !== e)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t5;
    }
    get styleSheet() {
      let e8 = n.get(this.cssText);
      return t && e8 === void 0 && (n.set(this.cssText, e8 = new CSSStyleSheet()), e8.replaceSync(this.cssText)), e8;
    }
    toString() {
      return this.cssText;
    }
  };
  var o = (t5) => new s(typeof t5 == "string" ? t5 : t5 + "", e);
  var i = (e8, n8) => {
    t ? e8.adoptedStyleSheets = n8.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet) : n8.forEach((t5) => {
      const n9 = document.createElement("style"), s6 = window.litNonce;
      s6 !== void 0 && n9.setAttribute("nonce", s6), n9.textContent = t5.cssText, e8.appendChild(n9);
    });
  };
  var S = t ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
    let e8 = "";
    for (const n8 of t6.cssRules)
      e8 += n8.cssText;
    return o(e8);
  })(t5) : t5;

  // node_modules/@lit/reactive-element/reactive-element.js
  var s2;
  var e2 = window.trustedTypes;
  var r2 = e2 ? e2.emptyScript : "";
  var h = window.reactiveElementPolyfillSupport;
  var o2 = { toAttribute(t5, i6) {
    switch (i6) {
      case Boolean:
        t5 = t5 ? r2 : null;
        break;
      case Object:
      case Array:
        t5 = t5 == null ? t5 : JSON.stringify(t5);
    }
    return t5;
  }, fromAttribute(t5, i6) {
    let s6 = t5;
    switch (i6) {
      case Boolean:
        s6 = t5 !== null;
        break;
      case Number:
        s6 = t5 === null ? null : Number(t5);
        break;
      case Object:
      case Array:
        try {
          s6 = JSON.parse(t5);
        } catch (t6) {
          s6 = null;
        }
    }
    return s6;
  } };
  var n2 = (t5, i6) => i6 !== t5 && (i6 == i6 || t5 == t5);
  var l = { attribute: true, type: String, converter: o2, reflect: false, hasChanged: n2 };
  var a = class extends HTMLElement {
    constructor() {
      super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
    }
    static addInitializer(t5) {
      var i6;
      (i6 = this.l) !== null && i6 !== void 0 || (this.l = []), this.l.push(t5);
    }
    static get observedAttributes() {
      this.finalize();
      const t5 = [];
      return this.elementProperties.forEach((i6, s6) => {
        const e8 = this._$Eh(s6, i6);
        e8 !== void 0 && (this._$Eu.set(e8, s6), t5.push(e8));
      }), t5;
    }
    static createProperty(t5, i6 = l) {
      if (i6.state && (i6.attribute = false), this.finalize(), this.elementProperties.set(t5, i6), !i6.noAccessor && !this.prototype.hasOwnProperty(t5)) {
        const s6 = typeof t5 == "symbol" ? Symbol() : "__" + t5, e8 = this.getPropertyDescriptor(t5, s6, i6);
        e8 !== void 0 && Object.defineProperty(this.prototype, t5, e8);
      }
    }
    static getPropertyDescriptor(t5, i6, s6) {
      return { get() {
        return this[i6];
      }, set(e8) {
        const r5 = this[t5];
        this[i6] = e8, this.requestUpdate(t5, r5, s6);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t5) {
      return this.elementProperties.get(t5) || l;
    }
    static finalize() {
      if (this.hasOwnProperty("finalized"))
        return false;
      this.finalized = true;
      const t5 = Object.getPrototypeOf(this);
      if (t5.finalize(), this.elementProperties = new Map(t5.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t6 = this.properties, i6 = [...Object.getOwnPropertyNames(t6), ...Object.getOwnPropertySymbols(t6)];
        for (const s6 of i6)
          this.createProperty(s6, t6[s6]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(i6) {
      const s6 = [];
      if (Array.isArray(i6)) {
        const e8 = new Set(i6.flat(1 / 0).reverse());
        for (const i7 of e8)
          s6.unshift(S(i7));
      } else
        i6 !== void 0 && s6.push(S(i6));
      return s6;
    }
    static _$Eh(t5, i6) {
      const s6 = i6.attribute;
      return s6 === false ? void 0 : typeof s6 == "string" ? s6 : typeof t5 == "string" ? t5.toLowerCase() : void 0;
    }
    o() {
      var t5;
      this._$Ep = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t5 = this.constructor.l) === null || t5 === void 0 || t5.forEach((t6) => t6(this));
    }
    addController(t5) {
      var i6, s6;
      ((i6 = this._$Eg) !== null && i6 !== void 0 ? i6 : this._$Eg = []).push(t5), this.renderRoot !== void 0 && this.isConnected && ((s6 = t5.hostConnected) === null || s6 === void 0 || s6.call(t5));
    }
    removeController(t5) {
      var i6;
      (i6 = this._$Eg) === null || i6 === void 0 || i6.splice(this._$Eg.indexOf(t5) >>> 0, 1);
    }
    _$Em() {
      this.constructor.elementProperties.forEach((t5, i6) => {
        this.hasOwnProperty(i6) && (this._$Et.set(i6, this[i6]), delete this[i6]);
      });
    }
    createRenderRoot() {
      var t5;
      const s6 = (t5 = this.shadowRoot) !== null && t5 !== void 0 ? t5 : this.attachShadow(this.constructor.shadowRootOptions);
      return i(s6, this.constructor.elementStyles), s6;
    }
    connectedCallback() {
      var t5;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
        var i6;
        return (i6 = t6.hostConnected) === null || i6 === void 0 ? void 0 : i6.call(t6);
      });
    }
    enableUpdating(t5) {
    }
    disconnectedCallback() {
      var t5;
      (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
        var i6;
        return (i6 = t6.hostDisconnected) === null || i6 === void 0 ? void 0 : i6.call(t6);
      });
    }
    attributeChangedCallback(t5, i6, s6) {
      this._$AK(t5, s6);
    }
    _$ES(t5, i6, s6 = l) {
      var e8, r5;
      const h4 = this.constructor._$Eh(t5, s6);
      if (h4 !== void 0 && s6.reflect === true) {
        const n8 = ((r5 = (e8 = s6.converter) === null || e8 === void 0 ? void 0 : e8.toAttribute) !== null && r5 !== void 0 ? r5 : o2.toAttribute)(i6, s6.type);
        this._$Ei = t5, n8 == null ? this.removeAttribute(h4) : this.setAttribute(h4, n8), this._$Ei = null;
      }
    }
    _$AK(t5, i6) {
      var s6, e8, r5;
      const h4 = this.constructor, n8 = h4._$Eu.get(t5);
      if (n8 !== void 0 && this._$Ei !== n8) {
        const t6 = h4.getPropertyOptions(n8), l6 = t6.converter, a4 = (r5 = (e8 = (s6 = l6) === null || s6 === void 0 ? void 0 : s6.fromAttribute) !== null && e8 !== void 0 ? e8 : typeof l6 == "function" ? l6 : null) !== null && r5 !== void 0 ? r5 : o2.fromAttribute;
        this._$Ei = n8, this[n8] = a4(i6, t6.type), this._$Ei = null;
      }
    }
    requestUpdate(t5, i6, s6) {
      let e8 = true;
      t5 !== void 0 && (((s6 = s6 || this.constructor.getPropertyOptions(t5)).hasChanged || n2)(this[t5], i6) ? (this._$AL.has(t5) || this._$AL.set(t5, i6), s6.reflect === true && this._$Ei !== t5 && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t5, s6))) : e8 = false), !this.isUpdatePending && e8 && (this._$Ep = this._$E_());
    }
    async _$E_() {
      this.isUpdatePending = true;
      try {
        await this._$Ep;
      } catch (t6) {
        Promise.reject(t6);
      }
      const t5 = this.scheduleUpdate();
      return t5 != null && await t5, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t5;
      if (!this.isUpdatePending)
        return;
      this.hasUpdated, this._$Et && (this._$Et.forEach((t6, i7) => this[i7] = t6), this._$Et = void 0);
      let i6 = false;
      const s6 = this._$AL;
      try {
        i6 = this.shouldUpdate(s6), i6 ? (this.willUpdate(s6), (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
          var i7;
          return (i7 = t6.hostUpdate) === null || i7 === void 0 ? void 0 : i7.call(t6);
        }), this.update(s6)) : this._$EU();
      } catch (t6) {
        throw i6 = false, this._$EU(), t6;
      }
      i6 && this._$AE(s6);
    }
    willUpdate(t5) {
    }
    _$AE(t5) {
      var i6;
      (i6 = this._$Eg) === null || i6 === void 0 || i6.forEach((t6) => {
        var i7;
        return (i7 = t6.hostUpdated) === null || i7 === void 0 ? void 0 : i7.call(t6);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
    }
    _$EU() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$Ep;
    }
    shouldUpdate(t5) {
      return true;
    }
    update(t5) {
      this._$EC !== void 0 && (this._$EC.forEach((t6, i6) => this._$ES(i6, this[i6], t6)), this._$EC = void 0), this._$EU();
    }
    updated(t5) {
    }
    firstUpdated(t5) {
    }
  };
  a.finalized = true, a.elementProperties = /* @__PURE__ */ new Map(), a.elementStyles = [], a.shadowRootOptions = { mode: "open" }, h == null || h({ ReactiveElement: a }), ((s2 = globalThis.reactiveElementVersions) !== null && s2 !== void 0 ? s2 : globalThis.reactiveElementVersions = []).push("1.3.2");

  // node_modules/lit-html/lit-html.js
  init_shim();
  var t2;
  var i2 = globalThis.trustedTypes;
  var s3 = i2 ? i2.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
  var e3 = `lit$${(Math.random() + "").slice(9)}$`;
  var o3 = "?" + e3;
  var n3 = `<${o3}>`;
  var l2 = document;
  var h2 = (t5 = "") => l2.createComment(t5);
  var r3 = (t5) => t5 === null || typeof t5 != "object" && typeof t5 != "function";
  var d = Array.isArray;
  var u = (t5) => {
    var i6;
    return d(t5) || typeof ((i6 = t5) === null || i6 === void 0 ? void 0 : i6[Symbol.iterator]) == "function";
  };
  var c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v = /-->/g;
  var a2 = />/g;
  var f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g;
  var _ = /'/g;
  var m = /"/g;
  var g = /^(?:script|style|textarea|title)$/i;
  var p = (t5) => (i6, ...s6) => ({ _$litType$: t5, strings: i6, values: s6 });
  var $ = p(1);
  var y = p(2);
  var b = Symbol.for("lit-noChange");
  var w = Symbol.for("lit-nothing");
  var T = /* @__PURE__ */ new WeakMap();
  var x = (t5, i6, s6) => {
    var e8, o7;
    const n8 = (e8 = s6 == null ? void 0 : s6.renderBefore) !== null && e8 !== void 0 ? e8 : i6;
    let l6 = n8._$litPart$;
    if (l6 === void 0) {
      const t6 = (o7 = s6 == null ? void 0 : s6.renderBefore) !== null && o7 !== void 0 ? o7 : null;
      n8._$litPart$ = l6 = new N(i6.insertBefore(h2(), t6), t6, void 0, s6 != null ? s6 : {});
    }
    return l6._$AI(t5), l6;
  };
  var A = l2.createTreeWalker(l2, 129, null, false);
  var C = (t5, i6) => {
    const o7 = t5.length - 1, l6 = [];
    let h4, r5 = i6 === 2 ? "<svg>" : "", d3 = c;
    for (let i7 = 0; i7 < o7; i7++) {
      const s6 = t5[i7];
      let o8, u4, p3 = -1, $3 = 0;
      for (; $3 < s6.length && (d3.lastIndex = $3, u4 = d3.exec(s6), u4 !== null); )
        $3 = d3.lastIndex, d3 === c ? u4[1] === "!--" ? d3 = v : u4[1] !== void 0 ? d3 = a2 : u4[2] !== void 0 ? (g.test(u4[2]) && (h4 = RegExp("</" + u4[2], "g")), d3 = f) : u4[3] !== void 0 && (d3 = f) : d3 === f ? u4[0] === ">" ? (d3 = h4 != null ? h4 : c, p3 = -1) : u4[1] === void 0 ? p3 = -2 : (p3 = d3.lastIndex - u4[2].length, o8 = u4[1], d3 = u4[3] === void 0 ? f : u4[3] === '"' ? m : _) : d3 === m || d3 === _ ? d3 = f : d3 === v || d3 === a2 ? d3 = c : (d3 = f, h4 = void 0);
      const y3 = d3 === f && t5[i7 + 1].startsWith("/>") ? " " : "";
      r5 += d3 === c ? s6 + n3 : p3 >= 0 ? (l6.push(o8), s6.slice(0, p3) + "$lit$" + s6.slice(p3) + e3 + y3) : s6 + e3 + (p3 === -2 ? (l6.push(void 0), i7) : y3);
    }
    const u3 = r5 + (t5[o7] || "<?>") + (i6 === 2 ? "</svg>" : "");
    if (!Array.isArray(t5) || !t5.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return [s3 !== void 0 ? s3.createHTML(u3) : u3, l6];
  };
  var E = class {
    constructor({ strings: t5, _$litType$: s6 }, n8) {
      let l6;
      this.parts = [];
      let r5 = 0, d3 = 0;
      const u3 = t5.length - 1, c3 = this.parts, [v3, a4] = C(t5, s6);
      if (this.el = E.createElement(v3, n8), A.currentNode = this.el.content, s6 === 2) {
        const t6 = this.el.content, i6 = t6.firstChild;
        i6.remove(), t6.append(...i6.childNodes);
      }
      for (; (l6 = A.nextNode()) !== null && c3.length < u3; ) {
        if (l6.nodeType === 1) {
          if (l6.hasAttributes()) {
            const t6 = [];
            for (const i6 of l6.getAttributeNames())
              if (i6.endsWith("$lit$") || i6.startsWith(e3)) {
                const s7 = a4[d3++];
                if (t6.push(i6), s7 !== void 0) {
                  const t7 = l6.getAttribute(s7.toLowerCase() + "$lit$").split(e3), i7 = /([.?@])?(.*)/.exec(s7);
                  c3.push({ type: 1, index: r5, name: i7[2], strings: t7, ctor: i7[1] === "." ? M : i7[1] === "?" ? H : i7[1] === "@" ? I : S2 });
                } else
                  c3.push({ type: 6, index: r5 });
              }
            for (const i6 of t6)
              l6.removeAttribute(i6);
          }
          if (g.test(l6.tagName)) {
            const t6 = l6.textContent.split(e3), s7 = t6.length - 1;
            if (s7 > 0) {
              l6.textContent = i2 ? i2.emptyScript : "";
              for (let i6 = 0; i6 < s7; i6++)
                l6.append(t6[i6], h2()), A.nextNode(), c3.push({ type: 2, index: ++r5 });
              l6.append(t6[s7], h2());
            }
          }
        } else if (l6.nodeType === 8)
          if (l6.data === o3)
            c3.push({ type: 2, index: r5 });
          else {
            let t6 = -1;
            for (; (t6 = l6.data.indexOf(e3, t6 + 1)) !== -1; )
              c3.push({ type: 7, index: r5 }), t6 += e3.length - 1;
          }
        r5++;
      }
    }
    static createElement(t5, i6) {
      const s6 = l2.createElement("template");
      return s6.innerHTML = t5, s6;
    }
  };
  function P(t5, i6, s6 = t5, e8) {
    var o7, n8, l6, h4;
    if (i6 === b)
      return i6;
    let d3 = e8 !== void 0 ? (o7 = s6._$Cl) === null || o7 === void 0 ? void 0 : o7[e8] : s6._$Cu;
    const u3 = r3(i6) ? void 0 : i6._$litDirective$;
    return (d3 == null ? void 0 : d3.constructor) !== u3 && ((n8 = d3 == null ? void 0 : d3._$AO) === null || n8 === void 0 || n8.call(d3, false), u3 === void 0 ? d3 = void 0 : (d3 = new u3(t5), d3._$AT(t5, s6, e8)), e8 !== void 0 ? ((l6 = (h4 = s6)._$Cl) !== null && l6 !== void 0 ? l6 : h4._$Cl = [])[e8] = d3 : s6._$Cu = d3), d3 !== void 0 && (i6 = P(t5, d3._$AS(t5, i6.values), d3, e8)), i6;
  }
  var V = class {
    constructor(t5, i6) {
      this.v = [], this._$AN = void 0, this._$AD = t5, this._$AM = i6;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    p(t5) {
      var i6;
      const { el: { content: s6 }, parts: e8 } = this._$AD, o7 = ((i6 = t5 == null ? void 0 : t5.creationScope) !== null && i6 !== void 0 ? i6 : l2).importNode(s6, true);
      A.currentNode = o7;
      let n8 = A.nextNode(), h4 = 0, r5 = 0, d3 = e8[0];
      for (; d3 !== void 0; ) {
        if (h4 === d3.index) {
          let i7;
          d3.type === 2 ? i7 = new N(n8, n8.nextSibling, this, t5) : d3.type === 1 ? i7 = new d3.ctor(n8, d3.name, d3.strings, this, t5) : d3.type === 6 && (i7 = new L(n8, this, t5)), this.v.push(i7), d3 = e8[++r5];
        }
        h4 !== (d3 == null ? void 0 : d3.index) && (n8 = A.nextNode(), h4++);
      }
      return o7;
    }
    m(t5) {
      let i6 = 0;
      for (const s6 of this.v)
        s6 !== void 0 && (s6.strings !== void 0 ? (s6._$AI(t5, s6, i6), i6 += s6.strings.length - 2) : s6._$AI(t5[i6])), i6++;
    }
  };
  var N = class {
    constructor(t5, i6, s6, e8) {
      var o7;
      this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t5, this._$AB = i6, this._$AM = s6, this.options = e8, this._$Cg = (o7 = e8 == null ? void 0 : e8.isConnected) === null || o7 === void 0 || o7;
    }
    get _$AU() {
      var t5, i6;
      return (i6 = (t5 = this._$AM) === null || t5 === void 0 ? void 0 : t5._$AU) !== null && i6 !== void 0 ? i6 : this._$Cg;
    }
    get parentNode() {
      let t5 = this._$AA.parentNode;
      const i6 = this._$AM;
      return i6 !== void 0 && t5.nodeType === 11 && (t5 = i6.parentNode), t5;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t5, i6 = this) {
      t5 = P(this, t5, i6), r3(t5) ? t5 === w || t5 == null || t5 === "" ? (this._$AH !== w && this._$AR(), this._$AH = w) : t5 !== this._$AH && t5 !== b && this.$(t5) : t5._$litType$ !== void 0 ? this.T(t5) : t5.nodeType !== void 0 ? this.k(t5) : u(t5) ? this.S(t5) : this.$(t5);
    }
    M(t5, i6 = this._$AB) {
      return this._$AA.parentNode.insertBefore(t5, i6);
    }
    k(t5) {
      this._$AH !== t5 && (this._$AR(), this._$AH = this.M(t5));
    }
    $(t5) {
      this._$AH !== w && r3(this._$AH) ? this._$AA.nextSibling.data = t5 : this.k(l2.createTextNode(t5)), this._$AH = t5;
    }
    T(t5) {
      var i6;
      const { values: s6, _$litType$: e8 } = t5, o7 = typeof e8 == "number" ? this._$AC(t5) : (e8.el === void 0 && (e8.el = E.createElement(e8.h, this.options)), e8);
      if (((i6 = this._$AH) === null || i6 === void 0 ? void 0 : i6._$AD) === o7)
        this._$AH.m(s6);
      else {
        const t6 = new V(o7, this), i7 = t6.p(this.options);
        t6.m(s6), this.k(i7), this._$AH = t6;
      }
    }
    _$AC(t5) {
      let i6 = T.get(t5.strings);
      return i6 === void 0 && T.set(t5.strings, i6 = new E(t5)), i6;
    }
    S(t5) {
      d(this._$AH) || (this._$AH = [], this._$AR());
      const i6 = this._$AH;
      let s6, e8 = 0;
      for (const o7 of t5)
        e8 === i6.length ? i6.push(s6 = new N(this.M(h2()), this.M(h2()), this, this.options)) : s6 = i6[e8], s6._$AI(o7), e8++;
      e8 < i6.length && (this._$AR(s6 && s6._$AB.nextSibling, e8), i6.length = e8);
    }
    _$AR(t5 = this._$AA.nextSibling, i6) {
      var s6;
      for ((s6 = this._$AP) === null || s6 === void 0 || s6.call(this, false, true, i6); t5 && t5 !== this._$AB; ) {
        const i7 = t5.nextSibling;
        t5.remove(), t5 = i7;
      }
    }
    setConnected(t5) {
      var i6;
      this._$AM === void 0 && (this._$Cg = t5, (i6 = this._$AP) === null || i6 === void 0 || i6.call(this, t5));
    }
  };
  var S2 = class {
    constructor(t5, i6, s6, e8, o7) {
      this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t5, this.name = i6, this._$AM = e8, this.options = o7, s6.length > 2 || s6[0] !== "" || s6[1] !== "" ? (this._$AH = Array(s6.length - 1).fill(new String()), this.strings = s6) : this._$AH = w;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5, i6 = this, s6, e8) {
      const o7 = this.strings;
      let n8 = false;
      if (o7 === void 0)
        t5 = P(this, t5, i6, 0), n8 = !r3(t5) || t5 !== this._$AH && t5 !== b, n8 && (this._$AH = t5);
      else {
        const e9 = t5;
        let l6, h4;
        for (t5 = o7[0], l6 = 0; l6 < o7.length - 1; l6++)
          h4 = P(this, e9[s6 + l6], i6, l6), h4 === b && (h4 = this._$AH[l6]), n8 || (n8 = !r3(h4) || h4 !== this._$AH[l6]), h4 === w ? t5 = w : t5 !== w && (t5 += (h4 != null ? h4 : "") + o7[l6 + 1]), this._$AH[l6] = h4;
      }
      n8 && !e8 && this.C(t5);
    }
    C(t5) {
      t5 === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 != null ? t5 : "");
    }
  };
  var M = class extends S2 {
    constructor() {
      super(...arguments), this.type = 3;
    }
    C(t5) {
      this.element[this.name] = t5 === w ? void 0 : t5;
    }
  };
  var k = i2 ? i2.emptyScript : "";
  var H = class extends S2 {
    constructor() {
      super(...arguments), this.type = 4;
    }
    C(t5) {
      t5 && t5 !== w ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);
    }
  };
  var I = class extends S2 {
    constructor(t5, i6, s6, e8, o7) {
      super(t5, i6, s6, e8, o7), this.type = 5;
    }
    _$AI(t5, i6 = this) {
      var s6;
      if ((t5 = (s6 = P(this, t5, i6, 0)) !== null && s6 !== void 0 ? s6 : w) === b)
        return;
      const e8 = this._$AH, o7 = t5 === w && e8 !== w || t5.capture !== e8.capture || t5.once !== e8.once || t5.passive !== e8.passive, n8 = t5 !== w && (e8 === w || o7);
      o7 && this.element.removeEventListener(this.name, this, e8), n8 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
    }
    handleEvent(t5) {
      var i6, s6;
      typeof this._$AH == "function" ? this._$AH.call((s6 = (i6 = this.options) === null || i6 === void 0 ? void 0 : i6.host) !== null && s6 !== void 0 ? s6 : this.element, t5) : this._$AH.handleEvent(t5);
    }
  };
  var L = class {
    constructor(t5, i6, s6) {
      this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s6;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5) {
      P(this, t5);
    }
  };
  var z = window.litHtmlPolyfillSupport;
  z == null || z(E, N), ((t2 = globalThis.litHtmlVersions) !== null && t2 !== void 0 ? t2 : globalThis.litHtmlVersions = []).push("2.2.6");

  // node_modules/lit-element/lit-element.js
  init_shim();
  var l3;
  var o4;
  var s4 = class extends a {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
    }
    createRenderRoot() {
      var t5, e8;
      const i6 = super.createRenderRoot();
      return (t5 = (e8 = this.renderOptions).renderBefore) !== null && t5 !== void 0 || (e8.renderBefore = i6.firstChild), i6;
    }
    update(t5) {
      const i6 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Dt = x(i6, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t5;
      super.connectedCallback(), (t5 = this._$Dt) === null || t5 === void 0 || t5.setConnected(true);
    }
    disconnectedCallback() {
      var t5;
      super.disconnectedCallback(), (t5 = this._$Dt) === null || t5 === void 0 || t5.setConnected(false);
    }
    render() {
      return b;
    }
  };
  s4.finalized = true, s4._$litElement$ = true, (l3 = globalThis.litElementHydrateSupport) === null || l3 === void 0 || l3.call(globalThis, { LitElement: s4 });
  var n4 = globalThis.litElementPolyfillSupport;
  n4 == null || n4({ LitElement: s4 });
  ((o4 = globalThis.litElementVersions) !== null && o4 !== void 0 ? o4 : globalThis.litElementVersions = []).push("3.2.0");

  // node_modules/lit/decorators.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/custom-element.js
  init_shim();
  var n5 = (n8) => (e8) => typeof e8 == "function" ? ((n9, e9) => (window.customElements.define(n9, e9), e9))(n8, e8) : ((n9, e9) => {
    const { kind: t5, elements: i6 } = e9;
    return { kind: t5, elements: i6, finisher(e10) {
      window.customElements.define(n9, e10);
    } };
  })(n8, e8);

  // node_modules/@lit/reactive-element/decorators/property.js
  init_shim();
  var i3 = (i6, e8) => e8.kind === "method" && e8.descriptor && !("value" in e8.descriptor) ? __spreadProps(__spreadValues({}, e8), { finisher(n8) {
    n8.createProperty(e8.key, i6);
  } }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e8.key, initializer() {
    typeof e8.initializer == "function" && (this[e8.key] = e8.initializer.call(this));
  }, finisher(n8) {
    n8.createProperty(e8.key, i6);
  } };
  function e4(e8) {
    return (n8, t5) => t5 !== void 0 ? ((i6, e9, n9) => {
      e9.constructor.createProperty(n9, i6);
    })(e8, n8, t5) : i3(e8, n8);
  }

  // node_modules/@lit/reactive-element/decorators/state.js
  init_shim();
  function t3(t5) {
    return e4(__spreadProps(__spreadValues({}, t5), { state: true }));
  }

  // node_modules/@lit/reactive-element/decorators/event-options.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/base.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/query.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/query-all.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/query-async.js
  init_shim();

  // node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
  init_shim();
  var n6;
  var e5 = ((n6 = window.HTMLSlotElement) === null || n6 === void 0 ? void 0 : n6.prototype.assignedElements) != null ? (o7, n8) => o7.assignedElements(n8) : (o7, n8) => o7.assignedNodes(n8).filter((o8) => o8.nodeType === Node.ELEMENT_NODE);

  // node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js
  init_shim();

  // src/utils/index.ts
  init_shim();

  // node_modules/file-type/browser.js
  init_shim();
  var import_node_buffer4 = __toESM(require_buffer(), 1);
  var import_readable_web_to_node_stream = __toESM(require_lib(), 1);

  // node_modules/file-type/core.js
  init_shim();
  var import_node_buffer3 = __toESM(require_buffer(), 1);

  // node_modules/token-types/lib/index.js
  init_shim();
  var ieee754 = __toESM(require_ieee754(), 1);
  var import_node_buffer = __toESM(require_buffer(), 1);
  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  var UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  var UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  var UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  var UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  var UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  var INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  var UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  var StringType = class {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return import_node_buffer.Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  };
  var AnsiStringType = class {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = "";
      for (let i6 = offset; i6 < until; ++i6) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i6]));
      }
      return str;
    }
    static inRange(a4, min, max) {
      return min <= a4 && a4 <= max;
    }
    static codePointToString(cp2) {
      if (cp2 <= 65535) {
        return String.fromCharCode(cp2);
      } else {
        cp2 -= 65536;
        return String.fromCharCode((cp2 >> 10) + 55296, (cp2 & 1023) + 56320);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0, 127)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 128];
      if (codePoint === null) {
        throw Error("invaliding encoding");
      }
      return codePoint;
    }
    get(buffer, offset = 0) {
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  };
  AnsiStringType.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];

  // node_modules/strtok3/lib/core.js
  init_shim();

  // node_modules/strtok3/lib/ReadStreamTokenizer.js
  init_shim();

  // node_modules/strtok3/lib/AbstractTokenizer.js
  init_shim();

  // node_modules/peek-readable/lib/index.js
  init_shim();

  // node_modules/peek-readable/lib/EndOfFileStream.js
  init_shim();
  var defaultMessages = "End-Of-Stream";
  var EndOfStreamError = class extends Error {
    constructor() {
      super(defaultMessages);
    }
  };

  // node_modules/peek-readable/lib/StreamReader.js
  init_shim();

  // node_modules/peek-readable/lib/Deferred.js
  init_shim();
  var Deferred = class {
    constructor() {
      this.resolve = () => null;
      this.reject = () => null;
      this.promise = new Promise((resolve, reject) => {
        this.reject = reject;
        this.resolve = resolve;
      });
    }
  };

  // node_modules/peek-readable/lib/StreamReader.js
  var maxStreamReadSize = 1 * 1024 * 1024;
  var StreamReader = class {
    constructor(s6) {
      this.s = s6;
      this.deferred = null;
      this.endOfStream = false;
      this.peekQueue = [];
      if (!s6.read || !s6.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => this.reject(new EndOfStreamError()));
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
      return bytesRead;
    }
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfStreamError();
      }
      let remaining = length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen)
          break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    async _read(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred()
        };
        this.deferred = request.deferred;
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  };

  // node_modules/strtok3/lib/AbstractTokenizer.js
  var import_node_buffer2 = __toESM(require_buffer(), 1);
  var AbstractTokenizer = class {
    constructor(fileInfo) {
      this.position = 0;
      this.numBuffer = new Uint8Array(8);
      this.fileInfo = fileInfo ? fileInfo : {};
    }
    async readToken(token, position = this.position) {
      const uint8Array = import_node_buffer2.Buffer.alloc(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    async peekToken(token, position = this.position) {
      const uint8Array = import_node_buffer2.Buffer.alloc(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    async ignore(length) {
      if (this.fileInfo.size !== void 0) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length;
      return length;
    }
    async close() {
    }
    normalizeOptions(uint8Array, options) {
      if (options && options.position !== void 0 && options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }
      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  };

  // node_modules/strtok3/lib/ReadStreamTokenizer.js
  var maxBufferSize = 256e3;
  var ReadStreamTokenizer = class extends AbstractTokenizer {
    constructor(stream, fileInfo) {
      super(fileInfo);
      this.streamReader = new StreamReader(stream);
    }
    async getFileInfo() {
      return this.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      } else if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
          return bytesRead - skipBytes;
        } else if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
        } catch (err) {
          if (options && options.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
  };

  // node_modules/strtok3/lib/BufferTokenizer.js
  init_shim();

  // node_modules/strtok3/lib/core.js
  function fromStream(stream, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer(stream, fileInfo);
  }

  // node_modules/file-type/util.js
  init_shim();
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function tarHeaderChecksumMatches(buffer, offset = 0) {
    const readSum = Number.parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
    if (Number.isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let i6 = offset; i6 < offset + 148; i6++) {
      sum += buffer[i6];
    }
    for (let i6 = offset + 156; i6 < offset + 512; i6++) {
      sum += buffer[i6];
    }
    return readSum === sum;
  }
  var uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };

  // node_modules/file-type/supported.js
  init_shim();
  var extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "ai",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf"
  ];
  var mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/x-apache-arrow",
    "video/mp4",
    "audio/midi",
    "video/x-matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/vnd.wave",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "audio/opus",
    "video/ogg",
    "audio/ogg",
    "application/ogg",
    "audio/x-flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd"
  ];

  // node_modules/file-type/core.js
  var minimumBytes = 4100;
  async function fileTypeFromStream(stream) {
    const tokenizer = await fromStream(stream);
    try {
      return await fileTypeFromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  function _check(buffer, headers, options) {
    options = __spreadValues({
      offset: 0
    }, options);
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  }
  async function fileTypeFromTokenizer(tokenizer) {
    try {
      return new FileTypeParser().parse(tokenizer);
    } catch (error) {
      if (!(error instanceof EndOfStreamError)) {
        throw error;
      }
    }
  }
  var FileTypeParser = class {
    check(header, options) {
      return _check(this.buffer, header, options);
    }
    checkString(header, options) {
      return this.check(stringToBytes(header), options);
    }
    async parse(tokenizer) {
      this.buffer = import_node_buffer3.Buffer.alloc(minimumBytes);
      if (tokenizer.fileInfo.size === void 0) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      this.tokenizer = tokenizer;
      await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
      if (this.check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (this.check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (this.check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (this.check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (this.check([37, 33])) {
        await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
        if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (this.check([31, 160]) || this.check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (this.check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (this.check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (this.check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (this.check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (this.check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (this.checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLength);
        return fileTypeFromTokenizer(tokenizer);
      }
      if (this.checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (this.checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (this.checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (this.checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (this.checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (this.check([80, 75, 3, 4])) {
        try {
          while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
            await tokenizer.readBuffer(this.buffer, { length: 30 });
            const zipHeader = {
              compressedSize: this.buffer.readUInt32LE(18),
              uncompressedSize: this.buffer.readUInt32LE(22),
              filenameLength: this.buffer.readUInt16LE(26),
              extraFieldLength: this.buffer.readUInt16LE(28)
            };
            zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, "utf-8"));
            await tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.filename === "META-INF/mozilla.rsa") {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
              const type = zipHeader.filename.split("/")[0];
              switch (type) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            }
            if (zipHeader.filename.startsWith("xl/")) {
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            }
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
              const mimeType = (await tokenizer.readToken(new StringType(zipHeader.compressedSize, "utf-8"))).trim();
              switch (mimeType) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                await tokenizer.peekBuffer(this.buffer, { mayBeLess: true });
                nextHeaderIndex = this.buffer.indexOf("504B0304", 0, "hex");
                await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
              }
            } else {
              await tokenizer.ignore(zipHeader.compressedSize);
            }
          }
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = import_node_buffer3.Buffer.alloc(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
        const brandMajor = this.buffer.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
          case "avis":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (this.checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (this.checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
        };
      }
      if (this.checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (this.checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (this.check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (this.checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (this.checkString("%PDF")) {
        await tokenizer.ignore(1350);
        const maxBufferSize2 = 10 * 1024 * 1024;
        const buffer = import_node_buffer3.Buffer.alloc(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer, { mayBeLess: true });
        if (buffer.includes(import_node_buffer3.Buffer.from("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (this.check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (this.check([73, 73])) {
        const fileType = await this.readTiffHeader(false);
        if (fileType) {
          return fileType;
        }
      }
      if (this.check([77, 77])) {
        const fileType = await this.readTiffHeader(true);
        if (fileType) {
          return fileType;
        }
      }
      if (this.checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (this.check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(UINT8);
          let mask = 128;
          let ic2 = 0;
          while ((msb & mask) === 0) {
            ++ic2;
            mask >>= 1;
          }
          const id2 = import_node_buffer3.Buffer.alloc(ic2 + 1);
          await tokenizer.readBuffer(id2);
          return id2;
        }
        async function readElement() {
          const id2 = await readField();
          const lengthField = await readField();
          lengthField[0] ^= 128 >> lengthField.length - 1;
          const nrLength = Math.min(6, lengthField.length);
          return {
            id: id2.readUIntBE(0, id2.length),
            len: lengthField.readUIntBE(lengthField.length - nrLength, nrLength)
          };
        }
        async function readChildren(level, children) {
          while (children > 0) {
            const element = await readElement();
            if (element.id === 17026) {
              const rawValue = await tokenizer.readToken(new StringType(element.len, "utf-8"));
              return rawValue.replace(/\00.*$/g, "");
            }
            await tokenizer.ignore(element.len);
            --children;
          }
        }
        const re2 = await readElement();
        const docType = await readChildren(1, re2.len);
        switch (docType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (this.check([82, 73, 70, 70])) {
        if (this.check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (this.check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (this.check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (this.checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (this.check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (this.checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (this.checkString("MSCF") || this.checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (this.check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (this.check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (this.check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (this.check([127, 69, 76, 70])) {
        return {
          ext: "elf",
          mime: "application/x-elf"
        };
      }
      if (this.check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (this.checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (this.checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (this.check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (this.checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (this.check([0, 0, 1, 186])) {
        if (this.check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            mime: "video/MP1S"
          };
        }
        if (this.check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            mime: "video/MP2P"
          };
        }
      }
      if (this.checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (this.check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (this.checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (this.checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (this.checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (this.checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const string = await tokenizer.readToken(new StringType(13, "ascii"));
        if (string === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(INT32_BE),
            type: await tokenizer.readToken(new StringType(4, "binary"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      }
      if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (this.check([239, 187, 191]) && this.checkString("<?xml", { offset: 3 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (this.checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = import_node_buffer3.Buffer.alloc(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = import_node_buffer3.Buffer.alloc(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (this.check([254, 255, 0, 60, 0, 63, 0, 120, 0, 109, 0, 108]) || this.check([255, 254, 60, 0, 63, 0, 120, 0, 109, 0, 108, 0])) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (this.check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (this.check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (this.check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.checkString("BEGIN:")) {
        if (this.checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (this.checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (this.checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (this.checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (this.checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
        const jsonSize = this.buffer.readUInt32LE(12);
        if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
          try {
            const header = this.buffer.slice(16, jsonSize + 16).toString();
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch {
          }
        }
      }
      if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (this.checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (this.check([71]) && this.check([71], { offset: 188 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (this.check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
        };
      }
      if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
        };
      }
      if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (tarHeaderChecksumMatches(this.buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (this.check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
      if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (this.check([16], { offset: 1, mask: [22] })) {
          if (this.check([8], { offset: 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (this.check([2], { offset: 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (this.check([4], { offset: 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (this.check([6], { offset: 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
    async readTiffTag(bigEndian) {
      const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      this.tokenizer.ignore(10);
      switch (tagId) {
        case 50341:
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        case 50706:
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        default:
      }
    }
    async readTiffIFD(bigEndian) {
      const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      for (let n8 = 0; n8 < numberOfTags; ++n8) {
        const fileType = await this.readTiffTag(bigEndian);
        if (fileType) {
          return fileType;
        }
      }
    }
    async readTiffHeader(bigEndian) {
      const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
      const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
      if (version === 42) {
        if (ifdOffset >= 6) {
          if (this.checkString("CR", { offset: 8 })) {
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          }
          if (ifdOffset >= 8 && (this.check([28, 0, 254, 0], { offset: 8 }) || this.check([31, 0, 11, 0], { offset: 8 }))) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
        await this.tokenizer.ignore(ifdOffset);
        const fileType = await this.readTiffIFD(false);
        return fileType ? fileType : {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (version === 43) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
    }
  };
  var supportedExtensions = new Set(extensions);
  var supportedMimeTypes = new Set(mimeTypes);

  // node_modules/file-type/browser.js
  async function fileTypeFromStream2(stream) {
    const readableWebToNodeStream = new import_readable_web_to_node_stream.ReadableWebToNodeStream(stream);
    const fileType = await fileTypeFromStream(readableWebToNodeStream);
    await readableWebToNodeStream.close();
    return fileType;
  }

  // src/utils/index.ts
  var import_lite = __toESM(require_lite());

  // src/utils/types.ts
  init_shim();

  // src/utils/directives.ts
  init_shim();

  // node_modules/lit/directive.js
  init_shim();

  // node_modules/lit-html/directive.js
  init_shim();
  var e6 = (t5) => (...e8) => ({ _$litDirective$: t5, values: e8 });
  var i4 = class {
    constructor(t5) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t5, e8, i6) {
      this._$Ct = t5, this._$AM = e8, this._$Ci = i6;
    }
    _$AS(t5, e8) {
      return this.update(t5, e8);
    }
    update(t5, e8) {
      return this.render(...e8);
    }
  };

  // src/utils/directives.ts
  var spreadProps = e6(class MyDirective extends i4 {
    constructor(partInfo) {
      super(partInfo);
      this.partInfo = partInfo;
    }
    render() {
      const host = this.partInfo.options.host;
      Object.values(host.attributes).forEach((attr) => {
        if (attr.name !== "src") {
          this.partInfo.element.setAttribute(attr.name, attr.value);
        }
      });
      return w;
    }
  });

  // src/utils/index.ts
  async function getMediaType(src, {
    ipfsGateway
  } = {}) {
    src = processSrc(src, ipfsGateway);
    const mimeType = import_lite.default.getType(src);
    if (mimeType) {
      const mediaType = mimeTypeToMediaType(mimeType);
      return { mediaType, mimeType, src };
    }
    try {
      const contentType = await fetch(src, { method: "HEAD" }).then((res) => res.headers.get("content-type"));
      if (contentType) {
        const mediaType = mimeTypeToMediaType(contentType);
        return { mediaType, mimeType, src };
      }
    } catch (e8) {
    }
    try {
      const controller = new AbortController();
      const signal = controller.signal;
      const stream = await fetch(src, { signal }).then((response) => response.body);
      if (stream) {
        const fileType = await fileTypeFromStream2(stream);
        controller.abort();
        if (fileType) {
          const mediaType = mimeTypeToMediaType(fileType.mime);
          return { mediaType, mimeType, src };
        }
      }
    } catch (e8) {
    }
    throw new Error("Unable to get media type of " + src);
  }
  function mimeTypeToMediaType(mimeType) {
    if (mimeType.startsWith("image")) {
      return "image";
    }
    if (mimeType.startsWith("video")) {
      return "video";
    }
    if (mimeType.startsWith("audio") || mimeType.endsWith("ogg")) {
      return "audio";
    }
    if (mimeType.startsWith("model")) {
      return "model";
    }
    if (mimeType.startsWith("application/pdf")) {
      return "pdf";
    }
    if (mimeType.startsWith("text/html")) {
      return "html";
    }
    return null;
  }
  function processSrc(src, ipfsGateway = getDefaultIpfsGateway()) {
    if (src.startsWith("ipfs://")) {
      return src.replace("ipfs://", ipfsGateway);
    }
    return src;
  }
  function getDefaultIpfsGateway() {
    return "https://ipfs.io/ipfs/";
  }

  // node_modules/@google/model-viewer/dist/model-viewer.min.js
  init_shim();
  var t4 = (t5, e8) => e8.kind === "method" && e8.descriptor && !("value" in e8.descriptor) ? __spreadProps(__spreadValues({}, e8), { finisher(n8) {
    n8.createProperty(e8.key, t5);
  } }) : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e8.key, initializer() {
    typeof e8.initializer == "function" && (this[e8.key] = e8.initializer.call(this));
  }, finisher(n8) {
    n8.createProperty(e8.key, t5);
  } };
  function e7(e8) {
    return (n8, i6) => i6 !== void 0 ? ((t5, e9, n9) => {
      e9.constructor.createProperty(n9, t5);
    })(e8, n8, i6) : t4(e8, n8);
  }
  var n7;
  (n7 = window.HTMLSlotElement) === null || n7 === void 0 || n7.prototype.assignedElements;
  var i5 = class {
    addEventListener(t5, e8) {
      this._listeners === void 0 && (this._listeners = {});
      const n8 = this._listeners;
      n8[t5] === void 0 && (n8[t5] = []), n8[t5].indexOf(e8) === -1 && n8[t5].push(e8);
    }
    hasEventListener(t5, e8) {
      if (this._listeners === void 0)
        return false;
      const n8 = this._listeners;
      return n8[t5] !== void 0 && n8[t5].indexOf(e8) !== -1;
    }
    removeEventListener(t5, e8) {
      if (this._listeners === void 0)
        return;
      const n8 = this._listeners[t5];
      if (n8 !== void 0) {
        const t6 = n8.indexOf(e8);
        t6 !== -1 && n8.splice(t6, 1);
      }
    }
    dispatchEvent(t5) {
      if (this._listeners === void 0)
        return;
      const e8 = this._listeners[t5.type];
      if (e8 !== void 0) {
        t5.target = this;
        const n8 = e8.slice(0);
        for (let e9 = 0, i6 = n8.length; e9 < i6; e9++)
          n8[e9].call(this, t5);
        t5.target = null;
      }
    }
  };
  var r4 = [];
  for (let t5 = 0; t5 < 256; t5++)
    r4[t5] = (t5 < 16 ? "0" : "") + t5.toString(16);
  var s5 = 1234567;
  var a3 = Math.PI / 180;
  var o6 = 180 / Math.PI;
  function l5() {
    const t5 = 4294967295 * Math.random() | 0, e8 = 4294967295 * Math.random() | 0, n8 = 4294967295 * Math.random() | 0, i6 = 4294967295 * Math.random() | 0;
    return (r4[255 & t5] + r4[t5 >> 8 & 255] + r4[t5 >> 16 & 255] + r4[t5 >> 24 & 255] + "-" + r4[255 & e8] + r4[e8 >> 8 & 255] + "-" + r4[e8 >> 16 & 15 | 64] + r4[e8 >> 24 & 255] + "-" + r4[63 & n8 | 128] + r4[n8 >> 8 & 255] + "-" + r4[n8 >> 16 & 255] + r4[n8 >> 24 & 255] + r4[255 & i6] + r4[i6 >> 8 & 255] + r4[i6 >> 16 & 255] + r4[i6 >> 24 & 255]).toLowerCase();
  }
  function h3(t5, e8, n8) {
    return Math.max(e8, Math.min(n8, t5));
  }
  function c2(t5, e8) {
    return (t5 % e8 + e8) % e8;
  }
  function u2(t5, e8, n8) {
    return (1 - n8) * t5 + n8 * e8;
  }
  function d2(t5) {
    return (t5 & t5 - 1) == 0 && t5 !== 0;
  }
  function p2(t5) {
    return Math.pow(2, Math.ceil(Math.log(t5) / Math.LN2));
  }
  function m2(t5) {
    return Math.pow(2, Math.floor(Math.log(t5) / Math.LN2));
  }
  var f2 = Object.freeze({ __proto__: null, DEG2RAD: a3, RAD2DEG: o6, generateUUID: l5, clamp: h3, euclideanModulo: c2, mapLinear: function(t5, e8, n8, i6, r5) {
    return i6 + (t5 - e8) * (r5 - i6) / (n8 - e8);
  }, inverseLerp: function(t5, e8, n8) {
    return t5 !== e8 ? (n8 - t5) / (e8 - t5) : 0;
  }, lerp: u2, damp: function(t5, e8, n8, i6) {
    return u2(t5, e8, 1 - Math.exp(-n8 * i6));
  }, pingpong: function(t5, e8 = 1) {
    return e8 - Math.abs(c2(t5, 2 * e8) - e8);
  }, smoothstep: function(t5, e8, n8) {
    return t5 <= e8 ? 0 : t5 >= n8 ? 1 : (t5 = (t5 - e8) / (n8 - e8)) * t5 * (3 - 2 * t5);
  }, smootherstep: function(t5, e8, n8) {
    return t5 <= e8 ? 0 : t5 >= n8 ? 1 : (t5 = (t5 - e8) / (n8 - e8)) * t5 * t5 * (t5 * (6 * t5 - 15) + 10);
  }, randInt: function(t5, e8) {
    return t5 + Math.floor(Math.random() * (e8 - t5 + 1));
  }, randFloat: function(t5, e8) {
    return t5 + Math.random() * (e8 - t5);
  }, randFloatSpread: function(t5) {
    return t5 * (0.5 - Math.random());
  }, seededRandom: function(t5) {
    t5 !== void 0 && (s5 = t5);
    let e8 = s5 += 1831565813;
    return e8 = Math.imul(e8 ^ e8 >>> 15, 1 | e8), e8 ^= e8 + Math.imul(e8 ^ e8 >>> 7, 61 | e8), ((e8 ^ e8 >>> 14) >>> 0) / 4294967296;
  }, degToRad: function(t5) {
    return t5 * a3;
  }, radToDeg: function(t5) {
    return t5 * o6;
  }, isPowerOfTwo: d2, ceilPowerOfTwo: p2, floorPowerOfTwo: m2, setQuaternionFromProperEuler: function(t5, e8, n8, i6, r5) {
    const s6 = Math.cos, a4 = Math.sin, o7 = s6(n8 / 2), l6 = a4(n8 / 2), h4 = s6((e8 + i6) / 2), c3 = a4((e8 + i6) / 2), u3 = s6((e8 - i6) / 2), d3 = a4((e8 - i6) / 2), p3 = s6((i6 - e8) / 2), m3 = a4((i6 - e8) / 2);
    switch (r5) {
      case "XYX":
        t5.set(o7 * c3, l6 * u3, l6 * d3, o7 * h4);
        break;
      case "YZY":
        t5.set(l6 * d3, o7 * c3, l6 * u3, o7 * h4);
        break;
      case "ZXZ":
        t5.set(l6 * u3, l6 * d3, o7 * c3, o7 * h4);
        break;
      case "XZX":
        t5.set(o7 * c3, l6 * m3, l6 * p3, o7 * h4);
        break;
      case "YXY":
        t5.set(l6 * p3, o7 * c3, l6 * m3, o7 * h4);
        break;
      case "ZYZ":
        t5.set(l6 * m3, l6 * p3, o7 * c3, o7 * h4);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r5);
    }
  }, normalize: function(t5, e8) {
    switch (e8.constructor) {
      case Float32Array:
        return t5;
      case Uint16Array:
        return Math.round(65535 * t5);
      case Uint8Array:
        return Math.round(255 * t5);
      case Int16Array:
        return Math.round(32767 * t5);
      case Int8Array:
        return Math.round(127 * t5);
      default:
        throw new Error("Invalid component type.");
    }
  }, denormalize: function(t5, e8) {
    switch (e8.constructor) {
      case Float32Array:
        return t5;
      case Uint16Array:
        return t5 / 65535;
      case Uint8Array:
        return t5 / 255;
      case Int16Array:
        return Math.max(t5 / 32767, -1);
      case Int8Array:
        return Math.max(t5 / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  } });
  var g2 = class {
    constructor(t5 = 0, e8 = 0) {
      this.x = t5, this.y = e8;
    }
    get width() {
      return this.x;
    }
    set width(t5) {
      this.x = t5;
    }
    get height() {
      return this.y;
    }
    set height(t5) {
      this.y = t5;
    }
    set(t5, e8) {
      return this.x = t5, this.y = e8, this;
    }
    setScalar(t5) {
      return this.x = t5, this.y = t5, this;
    }
    setX(t5) {
      return this.x = t5, this;
    }
    setY(t5) {
      return this.y = t5, this;
    }
    setComponent(t5, e8) {
      switch (t5) {
        case 0:
          this.x = e8;
          break;
        case 1:
          this.y = e8;
          break;
        default:
          throw new Error("index is out of range: " + t5);
      }
      return this;
    }
    getComponent(t5) {
      switch (t5) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t5);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t5) {
      return this.x = t5.x, this.y = t5.y, this;
    }
    add(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t5, e8)) : (this.x += t5.x, this.y += t5.y, this);
    }
    addScalar(t5) {
      return this.x += t5, this.y += t5, this;
    }
    addVectors(t5, e8) {
      return this.x = t5.x + e8.x, this.y = t5.y + e8.y, this;
    }
    addScaledVector(t5, e8) {
      return this.x += t5.x * e8, this.y += t5.y * e8, this;
    }
    sub(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t5, e8)) : (this.x -= t5.x, this.y -= t5.y, this);
    }
    subScalar(t5) {
      return this.x -= t5, this.y -= t5, this;
    }
    subVectors(t5, e8) {
      return this.x = t5.x - e8.x, this.y = t5.y - e8.y, this;
    }
    multiply(t5) {
      return this.x *= t5.x, this.y *= t5.y, this;
    }
    multiplyScalar(t5) {
      return this.x *= t5, this.y *= t5, this;
    }
    divide(t5) {
      return this.x /= t5.x, this.y /= t5.y, this;
    }
    divideScalar(t5) {
      return this.multiplyScalar(1 / t5);
    }
    applyMatrix3(t5) {
      const e8 = this.x, n8 = this.y, i6 = t5.elements;
      return this.x = i6[0] * e8 + i6[3] * n8 + i6[6], this.y = i6[1] * e8 + i6[4] * n8 + i6[7], this;
    }
    min(t5) {
      return this.x = Math.min(this.x, t5.x), this.y = Math.min(this.y, t5.y), this;
    }
    max(t5) {
      return this.x = Math.max(this.x, t5.x), this.y = Math.max(this.y, t5.y), this;
    }
    clamp(t5, e8) {
      return this.x = Math.max(t5.x, Math.min(e8.x, this.x)), this.y = Math.max(t5.y, Math.min(e8.y, this.y)), this;
    }
    clampScalar(t5, e8) {
      return this.x = Math.max(t5, Math.min(e8, this.x)), this.y = Math.max(t5, Math.min(e8, this.y)), this;
    }
    clampLength(t5, e8) {
      const n8 = this.length();
      return this.divideScalar(n8 || 1).multiplyScalar(Math.max(t5, Math.min(e8, n8)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t5) {
      return this.x * t5.x + this.y * t5.y;
    }
    cross(t5) {
      return this.x * t5.y - this.y * t5.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t5) {
      return Math.sqrt(this.distanceToSquared(t5));
    }
    distanceToSquared(t5) {
      const e8 = this.x - t5.x, n8 = this.y - t5.y;
      return e8 * e8 + n8 * n8;
    }
    manhattanDistanceTo(t5) {
      return Math.abs(this.x - t5.x) + Math.abs(this.y - t5.y);
    }
    setLength(t5) {
      return this.normalize().multiplyScalar(t5);
    }
    lerp(t5, e8) {
      return this.x += (t5.x - this.x) * e8, this.y += (t5.y - this.y) * e8, this;
    }
    lerpVectors(t5, e8, n8) {
      return this.x = t5.x + (e8.x - t5.x) * n8, this.y = t5.y + (e8.y - t5.y) * n8, this;
    }
    equals(t5) {
      return t5.x === this.x && t5.y === this.y;
    }
    fromArray(t5, e8 = 0) {
      return this.x = t5[e8], this.y = t5[e8 + 1], this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this.x, t5[e8 + 1] = this.y, t5;
    }
    fromBufferAttribute(t5, e8, n8) {
      return n8 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t5.getX(e8), this.y = t5.getY(e8), this;
    }
    rotateAround(t5, e8) {
      const n8 = Math.cos(e8), i6 = Math.sin(e8), r5 = this.x - t5.x, s6 = this.y - t5.y;
      return this.x = r5 * n8 - s6 * i6 + t5.x, this.y = r5 * i6 + s6 * n8 + t5.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  };
  g2.prototype.isVector2 = true;
  var v2 = class {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t5, e8, n8, i6, r5, s6, a4, o7, l6) {
      const h4 = this.elements;
      return h4[0] = t5, h4[1] = i6, h4[2] = a4, h4[3] = e8, h4[4] = r5, h4[5] = o7, h4[6] = n8, h4[7] = s6, h4[8] = l6, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t5) {
      const e8 = this.elements, n8 = t5.elements;
      return e8[0] = n8[0], e8[1] = n8[1], e8[2] = n8[2], e8[3] = n8[3], e8[4] = n8[4], e8[5] = n8[5], e8[6] = n8[6], e8[7] = n8[7], e8[8] = n8[8], this;
    }
    extractBasis(t5, e8, n8) {
      return t5.setFromMatrix3Column(this, 0), e8.setFromMatrix3Column(this, 1), n8.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t5) {
      const e8 = t5.elements;
      return this.set(e8[0], e8[4], e8[8], e8[1], e8[5], e8[9], e8[2], e8[6], e8[10]), this;
    }
    multiply(t5) {
      return this.multiplyMatrices(this, t5);
    }
    premultiply(t5) {
      return this.multiplyMatrices(t5, this);
    }
    multiplyMatrices(t5, e8) {
      const n8 = t5.elements, i6 = e8.elements, r5 = this.elements, s6 = n8[0], a4 = n8[3], o7 = n8[6], l6 = n8[1], h4 = n8[4], c3 = n8[7], u3 = n8[2], d3 = n8[5], p3 = n8[8], m3 = i6[0], f3 = i6[3], g3 = i6[6], v3 = i6[1], y3 = i6[4], x3 = i6[7], b3 = i6[2], _3 = i6[5], w3 = i6[8];
      return r5[0] = s6 * m3 + a4 * v3 + o7 * b3, r5[3] = s6 * f3 + a4 * y3 + o7 * _3, r5[6] = s6 * g3 + a4 * x3 + o7 * w3, r5[1] = l6 * m3 + h4 * v3 + c3 * b3, r5[4] = l6 * f3 + h4 * y3 + c3 * _3, r5[7] = l6 * g3 + h4 * x3 + c3 * w3, r5[2] = u3 * m3 + d3 * v3 + p3 * b3, r5[5] = u3 * f3 + d3 * y3 + p3 * _3, r5[8] = u3 * g3 + d3 * x3 + p3 * w3, this;
    }
    multiplyScalar(t5) {
      const e8 = this.elements;
      return e8[0] *= t5, e8[3] *= t5, e8[6] *= t5, e8[1] *= t5, e8[4] *= t5, e8[7] *= t5, e8[2] *= t5, e8[5] *= t5, e8[8] *= t5, this;
    }
    determinant() {
      const t5 = this.elements, e8 = t5[0], n8 = t5[1], i6 = t5[2], r5 = t5[3], s6 = t5[4], a4 = t5[5], o7 = t5[6], l6 = t5[7], h4 = t5[8];
      return e8 * s6 * h4 - e8 * a4 * l6 - n8 * r5 * h4 + n8 * a4 * o7 + i6 * r5 * l6 - i6 * s6 * o7;
    }
    invert() {
      const t5 = this.elements, e8 = t5[0], n8 = t5[1], i6 = t5[2], r5 = t5[3], s6 = t5[4], a4 = t5[5], o7 = t5[6], l6 = t5[7], h4 = t5[8], c3 = h4 * s6 - a4 * l6, u3 = a4 * o7 - h4 * r5, d3 = l6 * r5 - s6 * o7, p3 = e8 * c3 + n8 * u3 + i6 * d3;
      if (p3 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const m3 = 1 / p3;
      return t5[0] = c3 * m3, t5[1] = (i6 * l6 - h4 * n8) * m3, t5[2] = (a4 * n8 - i6 * s6) * m3, t5[3] = u3 * m3, t5[4] = (h4 * e8 - i6 * o7) * m3, t5[5] = (i6 * r5 - a4 * e8) * m3, t5[6] = d3 * m3, t5[7] = (n8 * o7 - l6 * e8) * m3, t5[8] = (s6 * e8 - n8 * r5) * m3, this;
    }
    transpose() {
      let t5;
      const e8 = this.elements;
      return t5 = e8[1], e8[1] = e8[3], e8[3] = t5, t5 = e8[2], e8[2] = e8[6], e8[6] = t5, t5 = e8[5], e8[5] = e8[7], e8[7] = t5, this;
    }
    getNormalMatrix(t5) {
      return this.setFromMatrix4(t5).invert().transpose();
    }
    transposeIntoArray(t5) {
      const e8 = this.elements;
      return t5[0] = e8[0], t5[1] = e8[3], t5[2] = e8[6], t5[3] = e8[1], t5[4] = e8[4], t5[5] = e8[7], t5[6] = e8[2], t5[7] = e8[5], t5[8] = e8[8], this;
    }
    setUvTransform(t5, e8, n8, i6, r5, s6, a4) {
      const o7 = Math.cos(r5), l6 = Math.sin(r5);
      return this.set(n8 * o7, n8 * l6, -n8 * (o7 * s6 + l6 * a4) + s6 + t5, -i6 * l6, i6 * o7, -i6 * (-l6 * s6 + o7 * a4) + a4 + e8, 0, 0, 1), this;
    }
    scale(t5, e8) {
      const n8 = this.elements;
      return n8[0] *= t5, n8[3] *= t5, n8[6] *= t5, n8[1] *= e8, n8[4] *= e8, n8[7] *= e8, this;
    }
    rotate(t5) {
      const e8 = Math.cos(t5), n8 = Math.sin(t5), i6 = this.elements, r5 = i6[0], s6 = i6[3], a4 = i6[6], o7 = i6[1], l6 = i6[4], h4 = i6[7];
      return i6[0] = e8 * r5 + n8 * o7, i6[3] = e8 * s6 + n8 * l6, i6[6] = e8 * a4 + n8 * h4, i6[1] = -n8 * r5 + e8 * o7, i6[4] = -n8 * s6 + e8 * l6, i6[7] = -n8 * a4 + e8 * h4, this;
    }
    translate(t5, e8) {
      const n8 = this.elements;
      return n8[0] += t5 * n8[2], n8[3] += t5 * n8[5], n8[6] += t5 * n8[8], n8[1] += e8 * n8[2], n8[4] += e8 * n8[5], n8[7] += e8 * n8[8], this;
    }
    equals(t5) {
      const e8 = this.elements, n8 = t5.elements;
      for (let t6 = 0; t6 < 9; t6++)
        if (e8[t6] !== n8[t6])
          return false;
      return true;
    }
    fromArray(t5, e8 = 0) {
      for (let n8 = 0; n8 < 9; n8++)
        this.elements[n8] = t5[n8 + e8];
      return this;
    }
    toArray(t5 = [], e8 = 0) {
      const n8 = this.elements;
      return t5[e8] = n8[0], t5[e8 + 1] = n8[1], t5[e8 + 2] = n8[2], t5[e8 + 3] = n8[3], t5[e8 + 4] = n8[4], t5[e8 + 5] = n8[5], t5[e8 + 6] = n8[6], t5[e8 + 7] = n8[7], t5[e8 + 8] = n8[8], t5;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  function y2(t5) {
    for (let e8 = t5.length - 1; e8 >= 0; --e8)
      if (t5[e8] > 65535)
        return true;
    return false;
  }
  function x2(t5) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t5);
  }
  function b2(t5) {
    return t5 < 0.04045 ? 0.0773993808 * t5 : Math.pow(0.9478672986 * t5 + 0.0521327014, 2.4);
  }
  function _2(t5) {
    return t5 < 31308e-7 ? 12.92 * t5 : 1.055 * Math.pow(t5, 0.41666) - 0.055;
  }
  v2.prototype.isMatrix3 = true;
  var w2 = { srgb: { "srgb-linear": b2 }, "srgb-linear": { srgb: _2 } };
  var M2 = { legacyMode: true, get workingColorSpace() {
    return "srgb-linear";
  }, set workingColorSpace(t5) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  }, convert: function(t5, e8, n8) {
    if (this.legacyMode || e8 === n8 || !e8 || !n8)
      return t5;
    if (w2[e8] && w2[e8][n8] !== void 0) {
      const i6 = w2[e8][n8];
      return t5.r = i6(t5.r), t5.g = i6(t5.g), t5.b = i6(t5.b), t5;
    }
    throw new Error("Unsupported color space conversion.");
  }, fromWorkingColorSpace: function(t5, e8) {
    return this.convert(t5, this.workingColorSpace, e8);
  }, toWorkingColorSpace: function(t5, e8) {
    return this.convert(t5, e8, this.workingColorSpace);
  } };
  var S3 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
  var T2 = { r: 0, g: 0, b: 0 };
  var E2 = { h: 0, s: 0, l: 0 };
  var A2 = { h: 0, s: 0, l: 0 };
  function R(t5, e8, n8) {
    return n8 < 0 && (n8 += 1), n8 > 1 && (n8 -= 1), n8 < 1 / 6 ? t5 + 6 * (e8 - t5) * n8 : n8 < 0.5 ? e8 : n8 < 2 / 3 ? t5 + 6 * (e8 - t5) * (2 / 3 - n8) : t5;
  }
  function C2(t5, e8) {
    return e8.r = t5.r, e8.g = t5.g, e8.b = t5.b, e8;
  }
  var L2 = class {
    constructor(t5, e8, n8) {
      return e8 === void 0 && n8 === void 0 ? this.set(t5) : this.setRGB(t5, e8, n8);
    }
    set(t5) {
      return t5 && t5.isColor ? this.copy(t5) : typeof t5 == "number" ? this.setHex(t5) : typeof t5 == "string" && this.setStyle(t5), this;
    }
    setScalar(t5) {
      return this.r = t5, this.g = t5, this.b = t5, this;
    }
    setHex(t5, e8 = "srgb") {
      return t5 = Math.floor(t5), this.r = (t5 >> 16 & 255) / 255, this.g = (t5 >> 8 & 255) / 255, this.b = (255 & t5) / 255, M2.toWorkingColorSpace(this, e8), this;
    }
    setRGB(t5, e8, n8, i6 = "srgb-linear") {
      return this.r = t5, this.g = e8, this.b = n8, M2.toWorkingColorSpace(this, i6), this;
    }
    setHSL(t5, e8, n8, i6 = "srgb-linear") {
      if (t5 = c2(t5, 1), e8 = h3(e8, 0, 1), n8 = h3(n8, 0, 1), e8 === 0)
        this.r = this.g = this.b = n8;
      else {
        const i7 = n8 <= 0.5 ? n8 * (1 + e8) : n8 + e8 - n8 * e8, r5 = 2 * n8 - i7;
        this.r = R(r5, i7, t5 + 1 / 3), this.g = R(r5, i7, t5), this.b = R(r5, i7, t5 - 1 / 3);
      }
      return M2.toWorkingColorSpace(this, i6), this;
    }
    setStyle(t5, e8 = "srgb") {
      function n8(e9) {
        e9 !== void 0 && parseFloat(e9) < 1 && console.warn("THREE.Color: Alpha component of " + t5 + " will be ignored.");
      }
      let i6;
      if (i6 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t5)) {
        let t6;
        const r5 = i6[1], s6 = i6[2];
        switch (r5) {
          case "rgb":
          case "rgba":
            if (t6 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s6))
              return this.r = Math.min(255, parseInt(t6[1], 10)) / 255, this.g = Math.min(255, parseInt(t6[2], 10)) / 255, this.b = Math.min(255, parseInt(t6[3], 10)) / 255, M2.toWorkingColorSpace(this, e8), n8(t6[4]), this;
            if (t6 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s6))
              return this.r = Math.min(100, parseInt(t6[1], 10)) / 100, this.g = Math.min(100, parseInt(t6[2], 10)) / 100, this.b = Math.min(100, parseInt(t6[3], 10)) / 100, M2.toWorkingColorSpace(this, e8), n8(t6[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (t6 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s6)) {
              const i7 = parseFloat(t6[1]) / 360, r6 = parseInt(t6[2], 10) / 100, s7 = parseInt(t6[3], 10) / 100;
              return n8(t6[4]), this.setHSL(i7, r6, s7, e8);
            }
        }
      } else if (i6 = /^\#([A-Fa-f\d]+)$/.exec(t5)) {
        const t6 = i6[1], n9 = t6.length;
        if (n9 === 3)
          return this.r = parseInt(t6.charAt(0) + t6.charAt(0), 16) / 255, this.g = parseInt(t6.charAt(1) + t6.charAt(1), 16) / 255, this.b = parseInt(t6.charAt(2) + t6.charAt(2), 16) / 255, M2.toWorkingColorSpace(this, e8), this;
        if (n9 === 6)
          return this.r = parseInt(t6.charAt(0) + t6.charAt(1), 16) / 255, this.g = parseInt(t6.charAt(2) + t6.charAt(3), 16) / 255, this.b = parseInt(t6.charAt(4) + t6.charAt(5), 16) / 255, M2.toWorkingColorSpace(this, e8), this;
      }
      return t5 && t5.length > 0 ? this.setColorName(t5, e8) : this;
    }
    setColorName(t5, e8 = "srgb") {
      const n8 = S3[t5.toLowerCase()];
      return n8 !== void 0 ? this.setHex(n8, e8) : console.warn("THREE.Color: Unknown color " + t5), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t5) {
      return this.r = t5.r, this.g = t5.g, this.b = t5.b, this;
    }
    copySRGBToLinear(t5) {
      return this.r = b2(t5.r), this.g = b2(t5.g), this.b = b2(t5.b), this;
    }
    copyLinearToSRGB(t5) {
      return this.r = _2(t5.r), this.g = _2(t5.g), this.b = _2(t5.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t5 = "srgb") {
      return M2.fromWorkingColorSpace(C2(this, T2), t5), h3(255 * T2.r, 0, 255) << 16 ^ h3(255 * T2.g, 0, 255) << 8 ^ h3(255 * T2.b, 0, 255) << 0;
    }
    getHexString(t5 = "srgb") {
      return ("000000" + this.getHex(t5).toString(16)).slice(-6);
    }
    getHSL(t5, e8 = "srgb-linear") {
      M2.fromWorkingColorSpace(C2(this, T2), e8);
      const n8 = T2.r, i6 = T2.g, r5 = T2.b, s6 = Math.max(n8, i6, r5), a4 = Math.min(n8, i6, r5);
      let o7, l6;
      const h4 = (a4 + s6) / 2;
      if (a4 === s6)
        o7 = 0, l6 = 0;
      else {
        const t6 = s6 - a4;
        switch (l6 = h4 <= 0.5 ? t6 / (s6 + a4) : t6 / (2 - s6 - a4), s6) {
          case n8:
            o7 = (i6 - r5) / t6 + (i6 < r5 ? 6 : 0);
            break;
          case i6:
            o7 = (r5 - n8) / t6 + 2;
            break;
          case r5:
            o7 = (n8 - i6) / t6 + 4;
        }
        o7 /= 6;
      }
      return t5.h = o7, t5.s = l6, t5.l = h4, t5;
    }
    getRGB(t5, e8 = "srgb-linear") {
      return M2.fromWorkingColorSpace(C2(this, T2), e8), t5.r = T2.r, t5.g = T2.g, t5.b = T2.b, t5;
    }
    getStyle(t5 = "srgb") {
      return M2.fromWorkingColorSpace(C2(this, T2), t5), t5 !== "srgb" ? `color(${t5} ${T2.r} ${T2.g} ${T2.b})` : `rgb(${255 * T2.r | 0},${255 * T2.g | 0},${255 * T2.b | 0})`;
    }
    offsetHSL(t5, e8, n8) {
      return this.getHSL(E2), E2.h += t5, E2.s += e8, E2.l += n8, this.setHSL(E2.h, E2.s, E2.l), this;
    }
    add(t5) {
      return this.r += t5.r, this.g += t5.g, this.b += t5.b, this;
    }
    addColors(t5, e8) {
      return this.r = t5.r + e8.r, this.g = t5.g + e8.g, this.b = t5.b + e8.b, this;
    }
    addScalar(t5) {
      return this.r += t5, this.g += t5, this.b += t5, this;
    }
    sub(t5) {
      return this.r = Math.max(0, this.r - t5.r), this.g = Math.max(0, this.g - t5.g), this.b = Math.max(0, this.b - t5.b), this;
    }
    multiply(t5) {
      return this.r *= t5.r, this.g *= t5.g, this.b *= t5.b, this;
    }
    multiplyScalar(t5) {
      return this.r *= t5, this.g *= t5, this.b *= t5, this;
    }
    lerp(t5, e8) {
      return this.r += (t5.r - this.r) * e8, this.g += (t5.g - this.g) * e8, this.b += (t5.b - this.b) * e8, this;
    }
    lerpColors(t5, e8, n8) {
      return this.r = t5.r + (e8.r - t5.r) * n8, this.g = t5.g + (e8.g - t5.g) * n8, this.b = t5.b + (e8.b - t5.b) * n8, this;
    }
    lerpHSL(t5, e8) {
      this.getHSL(E2), t5.getHSL(A2);
      const n8 = u2(E2.h, A2.h, e8), i6 = u2(E2.s, A2.s, e8), r5 = u2(E2.l, A2.l, e8);
      return this.setHSL(n8, i6, r5), this;
    }
    equals(t5) {
      return t5.r === this.r && t5.g === this.g && t5.b === this.b;
    }
    fromArray(t5, e8 = 0) {
      return this.r = t5[e8], this.g = t5[e8 + 1], this.b = t5[e8 + 2], this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this.r, t5[e8 + 1] = this.g, t5[e8 + 2] = this.b, t5;
    }
    fromBufferAttribute(t5, e8) {
      return this.r = t5.getX(e8), this.g = t5.getY(e8), this.b = t5.getZ(e8), t5.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
      return this.getHex();
    }
  };
  var P2;
  L2.NAMES = S3, L2.prototype.isColor = true, L2.prototype.r = 1, L2.prototype.g = 1, L2.prototype.b = 1;
  var D = class {
    static getDataURL(t5) {
      if (/^data:/i.test(t5.src))
        return t5.src;
      if (typeof HTMLCanvasElement == "undefined")
        return t5.src;
      let e8;
      if (t5 instanceof HTMLCanvasElement)
        e8 = t5;
      else {
        P2 === void 0 && (P2 = x2("canvas")), P2.width = t5.width, P2.height = t5.height;
        const n8 = P2.getContext("2d");
        t5 instanceof ImageData ? n8.putImageData(t5, 0, 0) : n8.drawImage(t5, 0, 0, t5.width, t5.height), e8 = P2;
      }
      return e8.width > 2048 || e8.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t5), e8.toDataURL("image/jpeg", 0.6)) : e8.toDataURL("image/png");
    }
    static sRGBToLinear(t5) {
      if (typeof HTMLImageElement != "undefined" && t5 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t5 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t5 instanceof ImageBitmap) {
        const e8 = x2("canvas");
        e8.width = t5.width, e8.height = t5.height;
        const n8 = e8.getContext("2d");
        n8.drawImage(t5, 0, 0, t5.width, t5.height);
        const i6 = n8.getImageData(0, 0, t5.width, t5.height), r5 = i6.data;
        for (let t6 = 0; t6 < r5.length; t6++)
          r5[t6] = 255 * b2(r5[t6] / 255);
        return n8.putImageData(i6, 0, 0), e8;
      }
      if (t5.data) {
        const e8 = t5.data.slice(0);
        for (let t6 = 0; t6 < e8.length; t6++)
          e8 instanceof Uint8Array || e8 instanceof Uint8ClampedArray ? e8[t6] = Math.floor(255 * b2(e8[t6] / 255)) : e8[t6] = b2(e8[t6]);
        return { data: e8, width: t5.width, height: t5.height };
      }
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t5;
    }
  };
  var I2 = class {
    constructor(t5 = null) {
      this.uuid = l5(), this.data = t5, this.version = 0;
    }
    set needsUpdate(t5) {
      t5 === true && this.version++;
    }
    toJSON(t5) {
      const e8 = t5 === void 0 || typeof t5 == "string";
      if (!e8 && t5.images[this.uuid] !== void 0)
        return t5.images[this.uuid];
      const n8 = { uuid: this.uuid, url: "" }, i6 = this.data;
      if (i6 !== null) {
        let t6;
        if (Array.isArray(i6)) {
          t6 = [];
          for (let e9 = 0, n9 = i6.length; e9 < n9; e9++)
            i6[e9].isDataTexture ? t6.push(O(i6[e9].image)) : t6.push(O(i6[e9]));
        } else
          t6 = O(i6);
        n8.url = t6;
      }
      return e8 || (t5.images[this.uuid] = n8), n8;
    }
  };
  function O(t5) {
    return typeof HTMLImageElement != "undefined" && t5 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t5 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t5 instanceof ImageBitmap ? D.getDataURL(t5) : t5.data ? { data: Array.prototype.slice.call(t5.data), width: t5.width, height: t5.height, type: t5.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  I2.prototype.isSource = true;
  var N2 = 0;
  var F = class extends i5 {
    constructor(t5 = F.DEFAULT_IMAGE, e8 = F.DEFAULT_MAPPING, n8 = 1001, i6 = 1001, r5 = 1006, s6 = 1008, a4 = 1023, o7 = 1009, h4 = 1, c3 = 3e3) {
      super(), Object.defineProperty(this, "id", { value: N2++ }), this.uuid = l5(), this.name = "", this.source = new I2(t5), this.mipmaps = [], this.mapping = e8, this.wrapS = n8, this.wrapT = i6, this.magFilter = r5, this.minFilter = s6, this.anisotropy = h4, this.format = a4, this.internalFormat = null, this.type = o7, this.offset = new g2(0, 0), this.repeat = new g2(1, 1), this.center = new g2(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new v2(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c3, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(t5) {
      this.source.data = t5;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      return this.name = t5.name, this.source = t5.source, this.mipmaps = t5.mipmaps.slice(0), this.mapping = t5.mapping, this.wrapS = t5.wrapS, this.wrapT = t5.wrapT, this.magFilter = t5.magFilter, this.minFilter = t5.minFilter, this.anisotropy = t5.anisotropy, this.format = t5.format, this.internalFormat = t5.internalFormat, this.type = t5.type, this.offset.copy(t5.offset), this.repeat.copy(t5.repeat), this.center.copy(t5.center), this.rotation = t5.rotation, this.matrixAutoUpdate = t5.matrixAutoUpdate, this.matrix.copy(t5.matrix), this.generateMipmaps = t5.generateMipmaps, this.premultiplyAlpha = t5.premultiplyAlpha, this.flipY = t5.flipY, this.unpackAlignment = t5.unpackAlignment, this.encoding = t5.encoding, this.userData = JSON.parse(JSON.stringify(t5.userData)), this.needsUpdate = true, this;
    }
    toJSON(t5) {
      const e8 = t5 === void 0 || typeof t5 == "string";
      if (!e8 && t5.textures[this.uuid] !== void 0)
        return t5.textures[this.uuid];
      const n8 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t5).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      return JSON.stringify(this.userData) !== "{}" && (n8.userData = this.userData), e8 || (t5.textures[this.uuid] = n8), n8;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t5) {
      if (this.mapping !== 300)
        return t5;
      if (t5.applyMatrix3(this.matrix), t5.x < 0 || t5.x > 1)
        switch (this.wrapS) {
          case 1e3:
            t5.x = t5.x - Math.floor(t5.x);
            break;
          case 1001:
            t5.x = t5.x < 0 ? 0 : 1;
            break;
          case 1002:
            Math.abs(Math.floor(t5.x) % 2) === 1 ? t5.x = Math.ceil(t5.x) - t5.x : t5.x = t5.x - Math.floor(t5.x);
        }
      if (t5.y < 0 || t5.y > 1)
        switch (this.wrapT) {
          case 1e3:
            t5.y = t5.y - Math.floor(t5.y);
            break;
          case 1001:
            t5.y = t5.y < 0 ? 0 : 1;
            break;
          case 1002:
            Math.abs(Math.floor(t5.y) % 2) === 1 ? t5.y = Math.ceil(t5.y) - t5.y : t5.y = t5.y - Math.floor(t5.y);
        }
      return this.flipY && (t5.y = 1 - t5.y), t5;
    }
    set needsUpdate(t5) {
      t5 === true && (this.version++, this.source.needsUpdate = true);
    }
  };
  F.DEFAULT_IMAGE = null, F.DEFAULT_MAPPING = 300, F.prototype.isTexture = true;
  var U = class {
    constructor(t5 = 0, e8 = 0, n8 = 0, i6 = 1) {
      this.x = t5, this.y = e8, this.z = n8, this.w = i6;
    }
    get width() {
      return this.z;
    }
    set width(t5) {
      this.z = t5;
    }
    get height() {
      return this.w;
    }
    set height(t5) {
      this.w = t5;
    }
    set(t5, e8, n8, i6) {
      return this.x = t5, this.y = e8, this.z = n8, this.w = i6, this;
    }
    setScalar(t5) {
      return this.x = t5, this.y = t5, this.z = t5, this.w = t5, this;
    }
    setX(t5) {
      return this.x = t5, this;
    }
    setY(t5) {
      return this.y = t5, this;
    }
    setZ(t5) {
      return this.z = t5, this;
    }
    setW(t5) {
      return this.w = t5, this;
    }
    setComponent(t5, e8) {
      switch (t5) {
        case 0:
          this.x = e8;
          break;
        case 1:
          this.y = e8;
          break;
        case 2:
          this.z = e8;
          break;
        case 3:
          this.w = e8;
          break;
        default:
          throw new Error("index is out of range: " + t5);
      }
      return this;
    }
    getComponent(t5) {
      switch (t5) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t5);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t5) {
      return this.x = t5.x, this.y = t5.y, this.z = t5.z, this.w = t5.w !== void 0 ? t5.w : 1, this;
    }
    add(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t5, e8)) : (this.x += t5.x, this.y += t5.y, this.z += t5.z, this.w += t5.w, this);
    }
    addScalar(t5) {
      return this.x += t5, this.y += t5, this.z += t5, this.w += t5, this;
    }
    addVectors(t5, e8) {
      return this.x = t5.x + e8.x, this.y = t5.y + e8.y, this.z = t5.z + e8.z, this.w = t5.w + e8.w, this;
    }
    addScaledVector(t5, e8) {
      return this.x += t5.x * e8, this.y += t5.y * e8, this.z += t5.z * e8, this.w += t5.w * e8, this;
    }
    sub(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t5, e8)) : (this.x -= t5.x, this.y -= t5.y, this.z -= t5.z, this.w -= t5.w, this);
    }
    subScalar(t5) {
      return this.x -= t5, this.y -= t5, this.z -= t5, this.w -= t5, this;
    }
    subVectors(t5, e8) {
      return this.x = t5.x - e8.x, this.y = t5.y - e8.y, this.z = t5.z - e8.z, this.w = t5.w - e8.w, this;
    }
    multiply(t5) {
      return this.x *= t5.x, this.y *= t5.y, this.z *= t5.z, this.w *= t5.w, this;
    }
    multiplyScalar(t5) {
      return this.x *= t5, this.y *= t5, this.z *= t5, this.w *= t5, this;
    }
    applyMatrix4(t5) {
      const e8 = this.x, n8 = this.y, i6 = this.z, r5 = this.w, s6 = t5.elements;
      return this.x = s6[0] * e8 + s6[4] * n8 + s6[8] * i6 + s6[12] * r5, this.y = s6[1] * e8 + s6[5] * n8 + s6[9] * i6 + s6[13] * r5, this.z = s6[2] * e8 + s6[6] * n8 + s6[10] * i6 + s6[14] * r5, this.w = s6[3] * e8 + s6[7] * n8 + s6[11] * i6 + s6[15] * r5, this;
    }
    divideScalar(t5) {
      return this.multiplyScalar(1 / t5);
    }
    setAxisAngleFromQuaternion(t5) {
      this.w = 2 * Math.acos(t5.w);
      const e8 = Math.sqrt(1 - t5.w * t5.w);
      return e8 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t5.x / e8, this.y = t5.y / e8, this.z = t5.z / e8), this;
    }
    setAxisAngleFromRotationMatrix(t5) {
      let e8, n8, i6, r5;
      const s6 = 0.01, a4 = 0.1, o7 = t5.elements, l6 = o7[0], h4 = o7[4], c3 = o7[8], u3 = o7[1], d3 = o7[5], p3 = o7[9], m3 = o7[2], f3 = o7[6], g3 = o7[10];
      if (Math.abs(h4 - u3) < s6 && Math.abs(c3 - m3) < s6 && Math.abs(p3 - f3) < s6) {
        if (Math.abs(h4 + u3) < a4 && Math.abs(c3 + m3) < a4 && Math.abs(p3 + f3) < a4 && Math.abs(l6 + d3 + g3 - 3) < a4)
          return this.set(1, 0, 0, 0), this;
        e8 = Math.PI;
        const t6 = (l6 + 1) / 2, o8 = (d3 + 1) / 2, v4 = (g3 + 1) / 2, y3 = (h4 + u3) / 4, x3 = (c3 + m3) / 4, b3 = (p3 + f3) / 4;
        return t6 > o8 && t6 > v4 ? t6 < s6 ? (n8 = 0, i6 = 0.707106781, r5 = 0.707106781) : (n8 = Math.sqrt(t6), i6 = y3 / n8, r5 = x3 / n8) : o8 > v4 ? o8 < s6 ? (n8 = 0.707106781, i6 = 0, r5 = 0.707106781) : (i6 = Math.sqrt(o8), n8 = y3 / i6, r5 = b3 / i6) : v4 < s6 ? (n8 = 0.707106781, i6 = 0.707106781, r5 = 0) : (r5 = Math.sqrt(v4), n8 = x3 / r5, i6 = b3 / r5), this.set(n8, i6, r5, e8), this;
      }
      let v3 = Math.sqrt((f3 - p3) * (f3 - p3) + (c3 - m3) * (c3 - m3) + (u3 - h4) * (u3 - h4));
      return Math.abs(v3) < 1e-3 && (v3 = 1), this.x = (f3 - p3) / v3, this.y = (c3 - m3) / v3, this.z = (u3 - h4) / v3, this.w = Math.acos((l6 + d3 + g3 - 1) / 2), this;
    }
    min(t5) {
      return this.x = Math.min(this.x, t5.x), this.y = Math.min(this.y, t5.y), this.z = Math.min(this.z, t5.z), this.w = Math.min(this.w, t5.w), this;
    }
    max(t5) {
      return this.x = Math.max(this.x, t5.x), this.y = Math.max(this.y, t5.y), this.z = Math.max(this.z, t5.z), this.w = Math.max(this.w, t5.w), this;
    }
    clamp(t5, e8) {
      return this.x = Math.max(t5.x, Math.min(e8.x, this.x)), this.y = Math.max(t5.y, Math.min(e8.y, this.y)), this.z = Math.max(t5.z, Math.min(e8.z, this.z)), this.w = Math.max(t5.w, Math.min(e8.w, this.w)), this;
    }
    clampScalar(t5, e8) {
      return this.x = Math.max(t5, Math.min(e8, this.x)), this.y = Math.max(t5, Math.min(e8, this.y)), this.z = Math.max(t5, Math.min(e8, this.z)), this.w = Math.max(t5, Math.min(e8, this.w)), this;
    }
    clampLength(t5, e8) {
      const n8 = this.length();
      return this.divideScalar(n8 || 1).multiplyScalar(Math.max(t5, Math.min(e8, n8)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t5) {
      return this.x * t5.x + this.y * t5.y + this.z * t5.z + this.w * t5.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t5) {
      return this.normalize().multiplyScalar(t5);
    }
    lerp(t5, e8) {
      return this.x += (t5.x - this.x) * e8, this.y += (t5.y - this.y) * e8, this.z += (t5.z - this.z) * e8, this.w += (t5.w - this.w) * e8, this;
    }
    lerpVectors(t5, e8, n8) {
      return this.x = t5.x + (e8.x - t5.x) * n8, this.y = t5.y + (e8.y - t5.y) * n8, this.z = t5.z + (e8.z - t5.z) * n8, this.w = t5.w + (e8.w - t5.w) * n8, this;
    }
    equals(t5) {
      return t5.x === this.x && t5.y === this.y && t5.z === this.z && t5.w === this.w;
    }
    fromArray(t5, e8 = 0) {
      return this.x = t5[e8], this.y = t5[e8 + 1], this.z = t5[e8 + 2], this.w = t5[e8 + 3], this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this.x, t5[e8 + 1] = this.y, t5[e8 + 2] = this.z, t5[e8 + 3] = this.w, t5;
    }
    fromBufferAttribute(t5, e8, n8) {
      return n8 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t5.getX(e8), this.y = t5.getY(e8), this.z = t5.getZ(e8), this.w = t5.getW(e8), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  };
  U.prototype.isVector4 = true;
  var k2 = class extends i5 {
    constructor(t5, e8, n8 = {}) {
      super(), this.width = t5, this.height = e8, this.depth = 1, this.scissor = new U(0, 0, t5, e8), this.scissorTest = false, this.viewport = new U(0, 0, t5, e8);
      const i6 = { width: t5, height: e8, depth: 1 };
      this.texture = new F(i6, n8.mapping, n8.wrapS, n8.wrapT, n8.magFilter, n8.minFilter, n8.format, n8.type, n8.anisotropy, n8.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = n8.generateMipmaps !== void 0 && n8.generateMipmaps, this.texture.internalFormat = n8.internalFormat !== void 0 ? n8.internalFormat : null, this.texture.minFilter = n8.minFilter !== void 0 ? n8.minFilter : 1006, this.depthBuffer = n8.depthBuffer === void 0 || n8.depthBuffer, this.stencilBuffer = n8.stencilBuffer !== void 0 && n8.stencilBuffer, this.depthTexture = n8.depthTexture !== void 0 ? n8.depthTexture : null, this.samples = n8.samples !== void 0 ? n8.samples : 0;
    }
    setSize(t5, e8, n8 = 1) {
      this.width === t5 && this.height === e8 && this.depth === n8 || (this.width = t5, this.height = e8, this.depth = n8, this.texture.image.width = t5, this.texture.image.height = e8, this.texture.image.depth = n8, this.dispose()), this.viewport.set(0, 0, t5, e8), this.scissor.set(0, 0, t5, e8);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      return this.width = t5.width, this.height = t5.height, this.depth = t5.depth, this.viewport.copy(t5.viewport), this.texture = t5.texture.clone(), this.texture.isRenderTargetTexture = true, this.texture.image = Object.assign({}, t5.texture.image), this.depthBuffer = t5.depthBuffer, this.stencilBuffer = t5.stencilBuffer, t5.depthTexture !== null && (this.depthTexture = t5.depthTexture.clone()), this.samples = t5.samples, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  k2.prototype.isWebGLRenderTarget = true;
  var B = class extends F {
    constructor(t5 = null, e8 = 1, n8 = 1, i6 = 1) {
      super(null), this.image = { data: t5, width: e8, height: n8, depth: i6 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  };
  B.prototype.isDataArrayTexture = true;
  (class extends k2 {
    constructor(t5, e8, n8) {
      super(t5, e8), this.depth = n8, this.texture = new B(null, t5, e8, n8), this.texture.isRenderTargetTexture = true;
    }
  }).prototype.isWebGLArrayRenderTarget = true;
  var z2 = class extends F {
    constructor(t5 = null, e8 = 1, n8 = 1, i6 = 1) {
      super(null), this.image = { data: t5, width: e8, height: n8, depth: i6 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  };
  z2.prototype.isData3DTexture = true;
  (class extends k2 {
    constructor(t5, e8, n8) {
      super(t5, e8), this.depth = n8, this.texture = new z2(null, t5, e8, n8), this.texture.isRenderTargetTexture = true;
    }
  }).prototype.isWebGL3DRenderTarget = true;
  (class extends k2 {
    constructor(t5, e8, n8, i6 = {}) {
      super(t5, e8, i6);
      const r5 = this.texture;
      this.texture = [];
      for (let t6 = 0; t6 < n8; t6++)
        this.texture[t6] = r5.clone(), this.texture[t6].isRenderTargetTexture = true;
    }
    setSize(t5, e8, n8 = 1) {
      if (this.width !== t5 || this.height !== e8 || this.depth !== n8) {
        this.width = t5, this.height = e8, this.depth = n8;
        for (let i6 = 0, r5 = this.texture.length; i6 < r5; i6++)
          this.texture[i6].image.width = t5, this.texture[i6].image.height = e8, this.texture[i6].image.depth = n8;
        this.dispose();
      }
      return this.viewport.set(0, 0, t5, e8), this.scissor.set(0, 0, t5, e8), this;
    }
    copy(t5) {
      this.dispose(), this.width = t5.width, this.height = t5.height, this.depth = t5.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t5.depthBuffer, this.stencilBuffer = t5.stencilBuffer, this.depthTexture = t5.depthTexture, this.texture.length = 0;
      for (let e8 = 0, n8 = t5.texture.length; e8 < n8; e8++)
        this.texture[e8] = t5.texture[e8].clone();
      return this;
    }
  }).prototype.isWebGLMultipleRenderTargets = true;
  var H2 = class {
    constructor(t5 = 0, e8 = 0, n8 = 0, i6 = 1) {
      this._x = t5, this._y = e8, this._z = n8, this._w = i6;
    }
    static slerp(t5, e8, n8, i6) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n8.slerpQuaternions(t5, e8, i6);
    }
    static slerpFlat(t5, e8, n8, i6, r5, s6, a4) {
      let o7 = n8[i6 + 0], l6 = n8[i6 + 1], h4 = n8[i6 + 2], c3 = n8[i6 + 3];
      const u3 = r5[s6 + 0], d3 = r5[s6 + 1], p3 = r5[s6 + 2], m3 = r5[s6 + 3];
      if (a4 === 0)
        return t5[e8 + 0] = o7, t5[e8 + 1] = l6, t5[e8 + 2] = h4, void (t5[e8 + 3] = c3);
      if (a4 === 1)
        return t5[e8 + 0] = u3, t5[e8 + 1] = d3, t5[e8 + 2] = p3, void (t5[e8 + 3] = m3);
      if (c3 !== m3 || o7 !== u3 || l6 !== d3 || h4 !== p3) {
        let t6 = 1 - a4;
        const e9 = o7 * u3 + l6 * d3 + h4 * p3 + c3 * m3, n9 = e9 >= 0 ? 1 : -1, i7 = 1 - e9 * e9;
        if (i7 > Number.EPSILON) {
          const r7 = Math.sqrt(i7), s7 = Math.atan2(r7, e9 * n9);
          t6 = Math.sin(t6 * s7) / r7, a4 = Math.sin(a4 * s7) / r7;
        }
        const r6 = a4 * n9;
        if (o7 = o7 * t6 + u3 * r6, l6 = l6 * t6 + d3 * r6, h4 = h4 * t6 + p3 * r6, c3 = c3 * t6 + m3 * r6, t6 === 1 - a4) {
          const t7 = 1 / Math.sqrt(o7 * o7 + l6 * l6 + h4 * h4 + c3 * c3);
          o7 *= t7, l6 *= t7, h4 *= t7, c3 *= t7;
        }
      }
      t5[e8] = o7, t5[e8 + 1] = l6, t5[e8 + 2] = h4, t5[e8 + 3] = c3;
    }
    static multiplyQuaternionsFlat(t5, e8, n8, i6, r5, s6) {
      const a4 = n8[i6], o7 = n8[i6 + 1], l6 = n8[i6 + 2], h4 = n8[i6 + 3], c3 = r5[s6], u3 = r5[s6 + 1], d3 = r5[s6 + 2], p3 = r5[s6 + 3];
      return t5[e8] = a4 * p3 + h4 * c3 + o7 * d3 - l6 * u3, t5[e8 + 1] = o7 * p3 + h4 * u3 + l6 * c3 - a4 * d3, t5[e8 + 2] = l6 * p3 + h4 * d3 + a4 * u3 - o7 * c3, t5[e8 + 3] = h4 * p3 - a4 * c3 - o7 * u3 - l6 * d3, t5;
    }
    get x() {
      return this._x;
    }
    set x(t5) {
      this._x = t5, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t5) {
      this._y = t5, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t5) {
      this._z = t5, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t5) {
      this._w = t5, this._onChangeCallback();
    }
    set(t5, e8, n8, i6) {
      return this._x = t5, this._y = e8, this._z = n8, this._w = i6, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t5) {
      return this._x = t5.x, this._y = t5.y, this._z = t5.z, this._w = t5.w, this._onChangeCallback(), this;
    }
    setFromEuler(t5, e8) {
      if (!t5 || !t5.isEuler)
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      const n8 = t5._x, i6 = t5._y, r5 = t5._z, s6 = t5._order, a4 = Math.cos, o7 = Math.sin, l6 = a4(n8 / 2), h4 = a4(i6 / 2), c3 = a4(r5 / 2), u3 = o7(n8 / 2), d3 = o7(i6 / 2), p3 = o7(r5 / 2);
      switch (s6) {
        case "XYZ":
          this._x = u3 * h4 * c3 + l6 * d3 * p3, this._y = l6 * d3 * c3 - u3 * h4 * p3, this._z = l6 * h4 * p3 + u3 * d3 * c3, this._w = l6 * h4 * c3 - u3 * d3 * p3;
          break;
        case "YXZ":
          this._x = u3 * h4 * c3 + l6 * d3 * p3, this._y = l6 * d3 * c3 - u3 * h4 * p3, this._z = l6 * h4 * p3 - u3 * d3 * c3, this._w = l6 * h4 * c3 + u3 * d3 * p3;
          break;
        case "ZXY":
          this._x = u3 * h4 * c3 - l6 * d3 * p3, this._y = l6 * d3 * c3 + u3 * h4 * p3, this._z = l6 * h4 * p3 + u3 * d3 * c3, this._w = l6 * h4 * c3 - u3 * d3 * p3;
          break;
        case "ZYX":
          this._x = u3 * h4 * c3 - l6 * d3 * p3, this._y = l6 * d3 * c3 + u3 * h4 * p3, this._z = l6 * h4 * p3 - u3 * d3 * c3, this._w = l6 * h4 * c3 + u3 * d3 * p3;
          break;
        case "YZX":
          this._x = u3 * h4 * c3 + l6 * d3 * p3, this._y = l6 * d3 * c3 + u3 * h4 * p3, this._z = l6 * h4 * p3 - u3 * d3 * c3, this._w = l6 * h4 * c3 - u3 * d3 * p3;
          break;
        case "XZY":
          this._x = u3 * h4 * c3 - l6 * d3 * p3, this._y = l6 * d3 * c3 - u3 * h4 * p3, this._z = l6 * h4 * p3 + u3 * d3 * c3, this._w = l6 * h4 * c3 + u3 * d3 * p3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s6);
      }
      return e8 !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t5, e8) {
      const n8 = e8 / 2, i6 = Math.sin(n8);
      return this._x = t5.x * i6, this._y = t5.y * i6, this._z = t5.z * i6, this._w = Math.cos(n8), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t5) {
      const e8 = t5.elements, n8 = e8[0], i6 = e8[4], r5 = e8[8], s6 = e8[1], a4 = e8[5], o7 = e8[9], l6 = e8[2], h4 = e8[6], c3 = e8[10], u3 = n8 + a4 + c3;
      if (u3 > 0) {
        const t6 = 0.5 / Math.sqrt(u3 + 1);
        this._w = 0.25 / t6, this._x = (h4 - o7) * t6, this._y = (r5 - l6) * t6, this._z = (s6 - i6) * t6;
      } else if (n8 > a4 && n8 > c3) {
        const t6 = 2 * Math.sqrt(1 + n8 - a4 - c3);
        this._w = (h4 - o7) / t6, this._x = 0.25 * t6, this._y = (i6 + s6) / t6, this._z = (r5 + l6) / t6;
      } else if (a4 > c3) {
        const t6 = 2 * Math.sqrt(1 + a4 - n8 - c3);
        this._w = (r5 - l6) / t6, this._x = (i6 + s6) / t6, this._y = 0.25 * t6, this._z = (o7 + h4) / t6;
      } else {
        const t6 = 2 * Math.sqrt(1 + c3 - n8 - a4);
        this._w = (s6 - i6) / t6, this._x = (r5 + l6) / t6, this._y = (o7 + h4) / t6, this._z = 0.25 * t6;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t5, e8) {
      let n8 = t5.dot(e8) + 1;
      return n8 < Number.EPSILON ? (n8 = 0, Math.abs(t5.x) > Math.abs(t5.z) ? (this._x = -t5.y, this._y = t5.x, this._z = 0, this._w = n8) : (this._x = 0, this._y = -t5.z, this._z = t5.y, this._w = n8)) : (this._x = t5.y * e8.z - t5.z * e8.y, this._y = t5.z * e8.x - t5.x * e8.z, this._z = t5.x * e8.y - t5.y * e8.x, this._w = n8), this.normalize();
    }
    angleTo(t5) {
      return 2 * Math.acos(Math.abs(h3(this.dot(t5), -1, 1)));
    }
    rotateTowards(t5, e8) {
      const n8 = this.angleTo(t5);
      if (n8 === 0)
        return this;
      const i6 = Math.min(1, e8 / n8);
      return this.slerp(t5, i6), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t5) {
      return this._x * t5._x + this._y * t5._y + this._z * t5._z + this._w * t5._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let t5 = this.length();
      return t5 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t5 = 1 / t5, this._x = this._x * t5, this._y = this._y * t5, this._z = this._z * t5, this._w = this._w * t5), this._onChangeCallback(), this;
    }
    multiply(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t5, e8)) : this.multiplyQuaternions(this, t5);
    }
    premultiply(t5) {
      return this.multiplyQuaternions(t5, this);
    }
    multiplyQuaternions(t5, e8) {
      const n8 = t5._x, i6 = t5._y, r5 = t5._z, s6 = t5._w, a4 = e8._x, o7 = e8._y, l6 = e8._z, h4 = e8._w;
      return this._x = n8 * h4 + s6 * a4 + i6 * l6 - r5 * o7, this._y = i6 * h4 + s6 * o7 + r5 * a4 - n8 * l6, this._z = r5 * h4 + s6 * l6 + n8 * o7 - i6 * a4, this._w = s6 * h4 - n8 * a4 - i6 * o7 - r5 * l6, this._onChangeCallback(), this;
    }
    slerp(t5, e8) {
      if (e8 === 0)
        return this;
      if (e8 === 1)
        return this.copy(t5);
      const n8 = this._x, i6 = this._y, r5 = this._z, s6 = this._w;
      let a4 = s6 * t5._w + n8 * t5._x + i6 * t5._y + r5 * t5._z;
      if (a4 < 0 ? (this._w = -t5._w, this._x = -t5._x, this._y = -t5._y, this._z = -t5._z, a4 = -a4) : this.copy(t5), a4 >= 1)
        return this._w = s6, this._x = n8, this._y = i6, this._z = r5, this;
      const o7 = 1 - a4 * a4;
      if (o7 <= Number.EPSILON) {
        const t6 = 1 - e8;
        return this._w = t6 * s6 + e8 * this._w, this._x = t6 * n8 + e8 * this._x, this._y = t6 * i6 + e8 * this._y, this._z = t6 * r5 + e8 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const l6 = Math.sqrt(o7), h4 = Math.atan2(l6, a4), c3 = Math.sin((1 - e8) * h4) / l6, u3 = Math.sin(e8 * h4) / l6;
      return this._w = s6 * c3 + this._w * u3, this._x = n8 * c3 + this._x * u3, this._y = i6 * c3 + this._y * u3, this._z = r5 * c3 + this._z * u3, this._onChangeCallback(), this;
    }
    slerpQuaternions(t5, e8, n8) {
      return this.copy(t5).slerp(e8, n8);
    }
    random() {
      const t5 = Math.random(), e8 = Math.sqrt(1 - t5), n8 = Math.sqrt(t5), i6 = 2 * Math.PI * Math.random(), r5 = 2 * Math.PI * Math.random();
      return this.set(e8 * Math.cos(i6), n8 * Math.sin(r5), n8 * Math.cos(r5), e8 * Math.sin(i6));
    }
    equals(t5) {
      return t5._x === this._x && t5._y === this._y && t5._z === this._z && t5._w === this._w;
    }
    fromArray(t5, e8 = 0) {
      return this._x = t5[e8], this._y = t5[e8 + 1], this._z = t5[e8 + 2], this._w = t5[e8 + 3], this._onChangeCallback(), this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this._x, t5[e8 + 1] = this._y, t5[e8 + 2] = this._z, t5[e8 + 3] = this._w, t5;
    }
    fromBufferAttribute(t5, e8) {
      return this._x = t5.getX(e8), this._y = t5.getY(e8), this._z = t5.getZ(e8), this._w = t5.getW(e8), this;
    }
    _onChange(t5) {
      return this._onChangeCallback = t5, this;
    }
    _onChangeCallback() {
    }
  };
  H2.prototype.isQuaternion = true;
  var V2 = class {
    constructor(t5 = 0, e8 = 0, n8 = 0) {
      this.x = t5, this.y = e8, this.z = n8;
    }
    set(t5, e8, n8) {
      return n8 === void 0 && (n8 = this.z), this.x = t5, this.y = e8, this.z = n8, this;
    }
    setScalar(t5) {
      return this.x = t5, this.y = t5, this.z = t5, this;
    }
    setX(t5) {
      return this.x = t5, this;
    }
    setY(t5) {
      return this.y = t5, this;
    }
    setZ(t5) {
      return this.z = t5, this;
    }
    setComponent(t5, e8) {
      switch (t5) {
        case 0:
          this.x = e8;
          break;
        case 1:
          this.y = e8;
          break;
        case 2:
          this.z = e8;
          break;
        default:
          throw new Error("index is out of range: " + t5);
      }
      return this;
    }
    getComponent(t5) {
      switch (t5) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t5);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t5) {
      return this.x = t5.x, this.y = t5.y, this.z = t5.z, this;
    }
    add(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t5, e8)) : (this.x += t5.x, this.y += t5.y, this.z += t5.z, this);
    }
    addScalar(t5) {
      return this.x += t5, this.y += t5, this.z += t5, this;
    }
    addVectors(t5, e8) {
      return this.x = t5.x + e8.x, this.y = t5.y + e8.y, this.z = t5.z + e8.z, this;
    }
    addScaledVector(t5, e8) {
      return this.x += t5.x * e8, this.y += t5.y * e8, this.z += t5.z * e8, this;
    }
    sub(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t5, e8)) : (this.x -= t5.x, this.y -= t5.y, this.z -= t5.z, this);
    }
    subScalar(t5) {
      return this.x -= t5, this.y -= t5, this.z -= t5, this;
    }
    subVectors(t5, e8) {
      return this.x = t5.x - e8.x, this.y = t5.y - e8.y, this.z = t5.z - e8.z, this;
    }
    multiply(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t5, e8)) : (this.x *= t5.x, this.y *= t5.y, this.z *= t5.z, this);
    }
    multiplyScalar(t5) {
      return this.x *= t5, this.y *= t5, this.z *= t5, this;
    }
    multiplyVectors(t5, e8) {
      return this.x = t5.x * e8.x, this.y = t5.y * e8.y, this.z = t5.z * e8.z, this;
    }
    applyEuler(t5) {
      return t5 && t5.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(W.setFromEuler(t5));
    }
    applyAxisAngle(t5, e8) {
      return this.applyQuaternion(W.setFromAxisAngle(t5, e8));
    }
    applyMatrix3(t5) {
      const e8 = this.x, n8 = this.y, i6 = this.z, r5 = t5.elements;
      return this.x = r5[0] * e8 + r5[3] * n8 + r5[6] * i6, this.y = r5[1] * e8 + r5[4] * n8 + r5[7] * i6, this.z = r5[2] * e8 + r5[5] * n8 + r5[8] * i6, this;
    }
    applyNormalMatrix(t5) {
      return this.applyMatrix3(t5).normalize();
    }
    applyMatrix4(t5) {
      const e8 = this.x, n8 = this.y, i6 = this.z, r5 = t5.elements, s6 = 1 / (r5[3] * e8 + r5[7] * n8 + r5[11] * i6 + r5[15]);
      return this.x = (r5[0] * e8 + r5[4] * n8 + r5[8] * i6 + r5[12]) * s6, this.y = (r5[1] * e8 + r5[5] * n8 + r5[9] * i6 + r5[13]) * s6, this.z = (r5[2] * e8 + r5[6] * n8 + r5[10] * i6 + r5[14]) * s6, this;
    }
    applyQuaternion(t5) {
      const e8 = this.x, n8 = this.y, i6 = this.z, r5 = t5.x, s6 = t5.y, a4 = t5.z, o7 = t5.w, l6 = o7 * e8 + s6 * i6 - a4 * n8, h4 = o7 * n8 + a4 * e8 - r5 * i6, c3 = o7 * i6 + r5 * n8 - s6 * e8, u3 = -r5 * e8 - s6 * n8 - a4 * i6;
      return this.x = l6 * o7 + u3 * -r5 + h4 * -a4 - c3 * -s6, this.y = h4 * o7 + u3 * -s6 + c3 * -r5 - l6 * -a4, this.z = c3 * o7 + u3 * -a4 + l6 * -s6 - h4 * -r5, this;
    }
    project(t5) {
      return this.applyMatrix4(t5.matrixWorldInverse).applyMatrix4(t5.projectionMatrix);
    }
    unproject(t5) {
      return this.applyMatrix4(t5.projectionMatrixInverse).applyMatrix4(t5.matrixWorld);
    }
    transformDirection(t5) {
      const e8 = this.x, n8 = this.y, i6 = this.z, r5 = t5.elements;
      return this.x = r5[0] * e8 + r5[4] * n8 + r5[8] * i6, this.y = r5[1] * e8 + r5[5] * n8 + r5[9] * i6, this.z = r5[2] * e8 + r5[6] * n8 + r5[10] * i6, this.normalize();
    }
    divide(t5) {
      return this.x /= t5.x, this.y /= t5.y, this.z /= t5.z, this;
    }
    divideScalar(t5) {
      return this.multiplyScalar(1 / t5);
    }
    min(t5) {
      return this.x = Math.min(this.x, t5.x), this.y = Math.min(this.y, t5.y), this.z = Math.min(this.z, t5.z), this;
    }
    max(t5) {
      return this.x = Math.max(this.x, t5.x), this.y = Math.max(this.y, t5.y), this.z = Math.max(this.z, t5.z), this;
    }
    clamp(t5, e8) {
      return this.x = Math.max(t5.x, Math.min(e8.x, this.x)), this.y = Math.max(t5.y, Math.min(e8.y, this.y)), this.z = Math.max(t5.z, Math.min(e8.z, this.z)), this;
    }
    clampScalar(t5, e8) {
      return this.x = Math.max(t5, Math.min(e8, this.x)), this.y = Math.max(t5, Math.min(e8, this.y)), this.z = Math.max(t5, Math.min(e8, this.z)), this;
    }
    clampLength(t5, e8) {
      const n8 = this.length();
      return this.divideScalar(n8 || 1).multiplyScalar(Math.max(t5, Math.min(e8, n8)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t5) {
      return this.x * t5.x + this.y * t5.y + this.z * t5.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t5) {
      return this.normalize().multiplyScalar(t5);
    }
    lerp(t5, e8) {
      return this.x += (t5.x - this.x) * e8, this.y += (t5.y - this.y) * e8, this.z += (t5.z - this.z) * e8, this;
    }
    lerpVectors(t5, e8, n8) {
      return this.x = t5.x + (e8.x - t5.x) * n8, this.y = t5.y + (e8.y - t5.y) * n8, this.z = t5.z + (e8.z - t5.z) * n8, this;
    }
    cross(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t5, e8)) : this.crossVectors(this, t5);
    }
    crossVectors(t5, e8) {
      const n8 = t5.x, i6 = t5.y, r5 = t5.z, s6 = e8.x, a4 = e8.y, o7 = e8.z;
      return this.x = i6 * o7 - r5 * a4, this.y = r5 * s6 - n8 * o7, this.z = n8 * a4 - i6 * s6, this;
    }
    projectOnVector(t5) {
      const e8 = t5.lengthSq();
      if (e8 === 0)
        return this.set(0, 0, 0);
      const n8 = t5.dot(this) / e8;
      return this.copy(t5).multiplyScalar(n8);
    }
    projectOnPlane(t5) {
      return G.copy(this).projectOnVector(t5), this.sub(G);
    }
    reflect(t5) {
      return this.sub(G.copy(t5).multiplyScalar(2 * this.dot(t5)));
    }
    angleTo(t5) {
      const e8 = Math.sqrt(this.lengthSq() * t5.lengthSq());
      if (e8 === 0)
        return Math.PI / 2;
      const n8 = this.dot(t5) / e8;
      return Math.acos(h3(n8, -1, 1));
    }
    distanceTo(t5) {
      return Math.sqrt(this.distanceToSquared(t5));
    }
    distanceToSquared(t5) {
      const e8 = this.x - t5.x, n8 = this.y - t5.y, i6 = this.z - t5.z;
      return e8 * e8 + n8 * n8 + i6 * i6;
    }
    manhattanDistanceTo(t5) {
      return Math.abs(this.x - t5.x) + Math.abs(this.y - t5.y) + Math.abs(this.z - t5.z);
    }
    setFromSpherical(t5) {
      return this.setFromSphericalCoords(t5.radius, t5.phi, t5.theta);
    }
    setFromSphericalCoords(t5, e8, n8) {
      const i6 = Math.sin(e8) * t5;
      return this.x = i6 * Math.sin(n8), this.y = Math.cos(e8) * t5, this.z = i6 * Math.cos(n8), this;
    }
    setFromCylindrical(t5) {
      return this.setFromCylindricalCoords(t5.radius, t5.theta, t5.y);
    }
    setFromCylindricalCoords(t5, e8, n8) {
      return this.x = t5 * Math.sin(e8), this.y = n8, this.z = t5 * Math.cos(e8), this;
    }
    setFromMatrixPosition(t5) {
      const e8 = t5.elements;
      return this.x = e8[12], this.y = e8[13], this.z = e8[14], this;
    }
    setFromMatrixScale(t5) {
      const e8 = this.setFromMatrixColumn(t5, 0).length(), n8 = this.setFromMatrixColumn(t5, 1).length(), i6 = this.setFromMatrixColumn(t5, 2).length();
      return this.x = e8, this.y = n8, this.z = i6, this;
    }
    setFromMatrixColumn(t5, e8) {
      return this.fromArray(t5.elements, 4 * e8);
    }
    setFromMatrix3Column(t5, e8) {
      return this.fromArray(t5.elements, 3 * e8);
    }
    setFromEuler(t5) {
      return this.x = t5._x, this.y = t5._y, this.z = t5._z, this;
    }
    equals(t5) {
      return t5.x === this.x && t5.y === this.y && t5.z === this.z;
    }
    fromArray(t5, e8 = 0) {
      return this.x = t5[e8], this.y = t5[e8 + 1], this.z = t5[e8 + 2], this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this.x, t5[e8 + 1] = this.y, t5[e8 + 2] = this.z, t5;
    }
    fromBufferAttribute(t5, e8, n8) {
      return n8 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t5.getX(e8), this.y = t5.getY(e8), this.z = t5.getZ(e8), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const t5 = 2 * (Math.random() - 0.5), e8 = Math.random() * Math.PI * 2, n8 = Math.sqrt(1 - t5 ** 2);
      return this.x = n8 * Math.cos(e8), this.y = n8 * Math.sin(e8), this.z = t5, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  };
  V2.prototype.isVector3 = true;
  var G = new V2();
  var W = new H2();
  var j = class {
    constructor(t5 = new V2(1 / 0, 1 / 0, 1 / 0), e8 = new V2(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = t5, this.max = e8;
    }
    set(t5, e8) {
      return this.min.copy(t5), this.max.copy(e8), this;
    }
    setFromArray(t5) {
      let e8 = 1 / 0, n8 = 1 / 0, i6 = 1 / 0, r5 = -1 / 0, s6 = -1 / 0, a4 = -1 / 0;
      for (let o7 = 0, l6 = t5.length; o7 < l6; o7 += 3) {
        const l7 = t5[o7], h4 = t5[o7 + 1], c3 = t5[o7 + 2];
        l7 < e8 && (e8 = l7), h4 < n8 && (n8 = h4), c3 < i6 && (i6 = c3), l7 > r5 && (r5 = l7), h4 > s6 && (s6 = h4), c3 > a4 && (a4 = c3);
      }
      return this.min.set(e8, n8, i6), this.max.set(r5, s6, a4), this;
    }
    setFromBufferAttribute(t5) {
      let e8 = 1 / 0, n8 = 1 / 0, i6 = 1 / 0, r5 = -1 / 0, s6 = -1 / 0, a4 = -1 / 0;
      for (let o7 = 0, l6 = t5.count; o7 < l6; o7++) {
        const l7 = t5.getX(o7), h4 = t5.getY(o7), c3 = t5.getZ(o7);
        l7 < e8 && (e8 = l7), h4 < n8 && (n8 = h4), c3 < i6 && (i6 = c3), l7 > r5 && (r5 = l7), h4 > s6 && (s6 = h4), c3 > a4 && (a4 = c3);
      }
      return this.min.set(e8, n8, i6), this.max.set(r5, s6, a4), this;
    }
    setFromPoints(t5) {
      this.makeEmpty();
      for (let e8 = 0, n8 = t5.length; e8 < n8; e8++)
        this.expandByPoint(t5[e8]);
      return this;
    }
    setFromCenterAndSize(t5, e8) {
      const n8 = X.copy(e8).multiplyScalar(0.5);
      return this.min.copy(t5).sub(n8), this.max.copy(t5).add(n8), this;
    }
    setFromObject(t5, e8 = false) {
      return this.makeEmpty(), this.expandByObject(t5, e8);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      return this.min.copy(t5.min), this.max.copy(t5.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t5) {
      return this.isEmpty() ? t5.set(0, 0, 0) : t5.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t5) {
      return this.isEmpty() ? t5.set(0, 0, 0) : t5.subVectors(this.max, this.min);
    }
    expandByPoint(t5) {
      return this.min.min(t5), this.max.max(t5), this;
    }
    expandByVector(t5) {
      return this.min.sub(t5), this.max.add(t5), this;
    }
    expandByScalar(t5) {
      return this.min.addScalar(-t5), this.max.addScalar(t5), this;
    }
    expandByObject(t5, e8 = false) {
      t5.updateWorldMatrix(false, false);
      const n8 = t5.geometry;
      if (n8 !== void 0)
        if (e8 && n8.attributes != null && n8.attributes.position !== void 0) {
          const e9 = n8.attributes.position;
          for (let n9 = 0, i7 = e9.count; n9 < i7; n9++)
            X.fromBufferAttribute(e9, n9).applyMatrix4(t5.matrixWorld), this.expandByPoint(X);
        } else
          n8.boundingBox === null && n8.computeBoundingBox(), $2.copy(n8.boundingBox), $2.applyMatrix4(t5.matrixWorld), this.union($2);
      const i6 = t5.children;
      for (let t6 = 0, n9 = i6.length; t6 < n9; t6++)
        this.expandByObject(i6[t6], e8);
      return this;
    }
    containsPoint(t5) {
      return !(t5.x < this.min.x || t5.x > this.max.x || t5.y < this.min.y || t5.y > this.max.y || t5.z < this.min.z || t5.z > this.max.z);
    }
    containsBox(t5) {
      return this.min.x <= t5.min.x && t5.max.x <= this.max.x && this.min.y <= t5.min.y && t5.max.y <= this.max.y && this.min.z <= t5.min.z && t5.max.z <= this.max.z;
    }
    getParameter(t5, e8) {
      return e8.set((t5.x - this.min.x) / (this.max.x - this.min.x), (t5.y - this.min.y) / (this.max.y - this.min.y), (t5.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t5) {
      return !(t5.max.x < this.min.x || t5.min.x > this.max.x || t5.max.y < this.min.y || t5.min.y > this.max.y || t5.max.z < this.min.z || t5.min.z > this.max.z);
    }
    intersectsSphere(t5) {
      return this.clampPoint(t5.center, X), X.distanceToSquared(t5.center) <= t5.radius * t5.radius;
    }
    intersectsPlane(t5) {
      let e8, n8;
      return t5.normal.x > 0 ? (e8 = t5.normal.x * this.min.x, n8 = t5.normal.x * this.max.x) : (e8 = t5.normal.x * this.max.x, n8 = t5.normal.x * this.min.x), t5.normal.y > 0 ? (e8 += t5.normal.y * this.min.y, n8 += t5.normal.y * this.max.y) : (e8 += t5.normal.y * this.max.y, n8 += t5.normal.y * this.min.y), t5.normal.z > 0 ? (e8 += t5.normal.z * this.min.z, n8 += t5.normal.z * this.max.z) : (e8 += t5.normal.z * this.max.z, n8 += t5.normal.z * this.min.z), e8 <= -t5.constant && n8 >= -t5.constant;
    }
    intersectsTriangle(t5) {
      if (this.isEmpty())
        return false;
      this.getCenter(et), nt.subVectors(this.max, et), Y.subVectors(t5.a, et), J.subVectors(t5.b, et), K.subVectors(t5.c, et), Z.subVectors(J, Y), Q.subVectors(K, J), tt.subVectors(Y, K);
      let e8 = [0, -Z.z, Z.y, 0, -Q.z, Q.y, 0, -tt.z, tt.y, Z.z, 0, -Z.x, Q.z, 0, -Q.x, tt.z, 0, -tt.x, -Z.y, Z.x, 0, -Q.y, Q.x, 0, -tt.y, tt.x, 0];
      return !!st(e8, Y, J, K, nt) && (e8 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!st(e8, Y, J, K, nt) && (it.crossVectors(Z, Q), e8 = [it.x, it.y, it.z], st(e8, Y, J, K, nt)));
    }
    clampPoint(t5, e8) {
      return e8.copy(t5).clamp(this.min, this.max);
    }
    distanceToPoint(t5) {
      return X.copy(t5).clamp(this.min, this.max).sub(t5).length();
    }
    getBoundingSphere(t5) {
      return this.getCenter(t5.center), t5.radius = 0.5 * this.getSize(X).length(), t5;
    }
    intersect(t5) {
      return this.min.max(t5.min), this.max.min(t5.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t5) {
      return this.min.min(t5.min), this.max.max(t5.max), this;
    }
    applyMatrix4(t5) {
      return this.isEmpty() || (q[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t5), q[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t5), q[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t5), q[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t5), q[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t5), q[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t5), q[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t5), q[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t5), this.setFromPoints(q)), this;
    }
    translate(t5) {
      return this.min.add(t5), this.max.add(t5), this;
    }
    equals(t5) {
      return t5.min.equals(this.min) && t5.max.equals(this.max);
    }
  };
  j.prototype.isBox3 = true;
  var q = [new V2(), new V2(), new V2(), new V2(), new V2(), new V2(), new V2(), new V2()];
  var X = new V2();
  var $2 = new j();
  var Y = new V2();
  var J = new V2();
  var K = new V2();
  var Z = new V2();
  var Q = new V2();
  var tt = new V2();
  var et = new V2();
  var nt = new V2();
  var it = new V2();
  var rt = new V2();
  function st(t5, e8, n8, i6, r5) {
    for (let s6 = 0, a4 = t5.length - 3; s6 <= a4; s6 += 3) {
      rt.fromArray(t5, s6);
      const a5 = r5.x * Math.abs(rt.x) + r5.y * Math.abs(rt.y) + r5.z * Math.abs(rt.z), o7 = e8.dot(rt), l6 = n8.dot(rt), h4 = i6.dot(rt);
      if (Math.max(-Math.max(o7, l6, h4), Math.min(o7, l6, h4)) > a5)
        return false;
    }
    return true;
  }
  var at = new j();
  var ot = new V2();
  var lt = new V2();
  var ht = new V2();
  var ct = class {
    constructor(t5 = new V2(), e8 = -1) {
      this.center = t5, this.radius = e8;
    }
    set(t5, e8) {
      return this.center.copy(t5), this.radius = e8, this;
    }
    setFromPoints(t5, e8) {
      const n8 = this.center;
      e8 !== void 0 ? n8.copy(e8) : at.setFromPoints(t5).getCenter(n8);
      let i6 = 0;
      for (let e9 = 0, r5 = t5.length; e9 < r5; e9++)
        i6 = Math.max(i6, n8.distanceToSquared(t5[e9]));
      return this.radius = Math.sqrt(i6), this;
    }
    copy(t5) {
      return this.center.copy(t5.center), this.radius = t5.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t5) {
      return t5.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t5) {
      return t5.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t5) {
      const e8 = this.radius + t5.radius;
      return t5.center.distanceToSquared(this.center) <= e8 * e8;
    }
    intersectsBox(t5) {
      return t5.intersectsSphere(this);
    }
    intersectsPlane(t5) {
      return Math.abs(t5.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t5, e8) {
      const n8 = this.center.distanceToSquared(t5);
      return e8.copy(t5), n8 > this.radius * this.radius && (e8.sub(this.center).normalize(), e8.multiplyScalar(this.radius).add(this.center)), e8;
    }
    getBoundingBox(t5) {
      return this.isEmpty() ? (t5.makeEmpty(), t5) : (t5.set(this.center, this.center), t5.expandByScalar(this.radius), t5);
    }
    applyMatrix4(t5) {
      return this.center.applyMatrix4(t5), this.radius = this.radius * t5.getMaxScaleOnAxis(), this;
    }
    translate(t5) {
      return this.center.add(t5), this;
    }
    expandByPoint(t5) {
      ht.subVectors(t5, this.center);
      const e8 = ht.lengthSq();
      if (e8 > this.radius * this.radius) {
        const t6 = Math.sqrt(e8), n8 = 0.5 * (t6 - this.radius);
        this.center.add(ht.multiplyScalar(n8 / t6)), this.radius += n8;
      }
      return this;
    }
    union(t5) {
      return this.center.equals(t5.center) === true ? lt.set(0, 0, 1).multiplyScalar(t5.radius) : lt.subVectors(t5.center, this.center).normalize().multiplyScalar(t5.radius), this.expandByPoint(ot.copy(t5.center).add(lt)), this.expandByPoint(ot.copy(t5.center).sub(lt)), this;
    }
    equals(t5) {
      return t5.center.equals(this.center) && t5.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var ut = new V2();
  var dt = new V2();
  var pt = new V2();
  var mt = new V2();
  var ft = new V2();
  var gt = new V2();
  var vt = new V2();
  var yt = class {
    constructor(t5 = new V2(), e8 = new V2(0, 0, -1)) {
      this.origin = t5, this.direction = e8;
    }
    set(t5, e8) {
      return this.origin.copy(t5), this.direction.copy(e8), this;
    }
    copy(t5) {
      return this.origin.copy(t5.origin), this.direction.copy(t5.direction), this;
    }
    at(t5, e8) {
      return e8.copy(this.direction).multiplyScalar(t5).add(this.origin);
    }
    lookAt(t5) {
      return this.direction.copy(t5).sub(this.origin).normalize(), this;
    }
    recast(t5) {
      return this.origin.copy(this.at(t5, ut)), this;
    }
    closestPointToPoint(t5, e8) {
      e8.subVectors(t5, this.origin);
      const n8 = e8.dot(this.direction);
      return n8 < 0 ? e8.copy(this.origin) : e8.copy(this.direction).multiplyScalar(n8).add(this.origin);
    }
    distanceToPoint(t5) {
      return Math.sqrt(this.distanceSqToPoint(t5));
    }
    distanceSqToPoint(t5) {
      const e8 = ut.subVectors(t5, this.origin).dot(this.direction);
      return e8 < 0 ? this.origin.distanceToSquared(t5) : (ut.copy(this.direction).multiplyScalar(e8).add(this.origin), ut.distanceToSquared(t5));
    }
    distanceSqToSegment(t5, e8, n8, i6) {
      dt.copy(t5).add(e8).multiplyScalar(0.5), pt.copy(e8).sub(t5).normalize(), mt.copy(this.origin).sub(dt);
      const r5 = 0.5 * t5.distanceTo(e8), s6 = -this.direction.dot(pt), a4 = mt.dot(this.direction), o7 = -mt.dot(pt), l6 = mt.lengthSq(), h4 = Math.abs(1 - s6 * s6);
      let c3, u3, d3, p3;
      if (h4 > 0)
        if (c3 = s6 * o7 - a4, u3 = s6 * a4 - o7, p3 = r5 * h4, c3 >= 0)
          if (u3 >= -p3)
            if (u3 <= p3) {
              const t6 = 1 / h4;
              c3 *= t6, u3 *= t6, d3 = c3 * (c3 + s6 * u3 + 2 * a4) + u3 * (s6 * c3 + u3 + 2 * o7) + l6;
            } else
              u3 = r5, c3 = Math.max(0, -(s6 * u3 + a4)), d3 = -c3 * c3 + u3 * (u3 + 2 * o7) + l6;
          else
            u3 = -r5, c3 = Math.max(0, -(s6 * u3 + a4)), d3 = -c3 * c3 + u3 * (u3 + 2 * o7) + l6;
        else
          u3 <= -p3 ? (c3 = Math.max(0, -(-s6 * r5 + a4)), u3 = c3 > 0 ? -r5 : Math.min(Math.max(-r5, -o7), r5), d3 = -c3 * c3 + u3 * (u3 + 2 * o7) + l6) : u3 <= p3 ? (c3 = 0, u3 = Math.min(Math.max(-r5, -o7), r5), d3 = u3 * (u3 + 2 * o7) + l6) : (c3 = Math.max(0, -(s6 * r5 + a4)), u3 = c3 > 0 ? r5 : Math.min(Math.max(-r5, -o7), r5), d3 = -c3 * c3 + u3 * (u3 + 2 * o7) + l6);
      else
        u3 = s6 > 0 ? -r5 : r5, c3 = Math.max(0, -(s6 * u3 + a4)), d3 = -c3 * c3 + u3 * (u3 + 2 * o7) + l6;
      return n8 && n8.copy(this.direction).multiplyScalar(c3).add(this.origin), i6 && i6.copy(pt).multiplyScalar(u3).add(dt), d3;
    }
    intersectSphere(t5, e8) {
      ut.subVectors(t5.center, this.origin);
      const n8 = ut.dot(this.direction), i6 = ut.dot(ut) - n8 * n8, r5 = t5.radius * t5.radius;
      if (i6 > r5)
        return null;
      const s6 = Math.sqrt(r5 - i6), a4 = n8 - s6, o7 = n8 + s6;
      return a4 < 0 && o7 < 0 ? null : a4 < 0 ? this.at(o7, e8) : this.at(a4, e8);
    }
    intersectsSphere(t5) {
      return this.distanceSqToPoint(t5.center) <= t5.radius * t5.radius;
    }
    distanceToPlane(t5) {
      const e8 = t5.normal.dot(this.direction);
      if (e8 === 0)
        return t5.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n8 = -(this.origin.dot(t5.normal) + t5.constant) / e8;
      return n8 >= 0 ? n8 : null;
    }
    intersectPlane(t5, e8) {
      const n8 = this.distanceToPlane(t5);
      return n8 === null ? null : this.at(n8, e8);
    }
    intersectsPlane(t5) {
      const e8 = t5.distanceToPoint(this.origin);
      if (e8 === 0)
        return true;
      return t5.normal.dot(this.direction) * e8 < 0;
    }
    intersectBox(t5, e8) {
      let n8, i6, r5, s6, a4, o7;
      const l6 = 1 / this.direction.x, h4 = 1 / this.direction.y, c3 = 1 / this.direction.z, u3 = this.origin;
      return l6 >= 0 ? (n8 = (t5.min.x - u3.x) * l6, i6 = (t5.max.x - u3.x) * l6) : (n8 = (t5.max.x - u3.x) * l6, i6 = (t5.min.x - u3.x) * l6), h4 >= 0 ? (r5 = (t5.min.y - u3.y) * h4, s6 = (t5.max.y - u3.y) * h4) : (r5 = (t5.max.y - u3.y) * h4, s6 = (t5.min.y - u3.y) * h4), n8 > s6 || r5 > i6 ? null : ((r5 > n8 || n8 != n8) && (n8 = r5), (s6 < i6 || i6 != i6) && (i6 = s6), c3 >= 0 ? (a4 = (t5.min.z - u3.z) * c3, o7 = (t5.max.z - u3.z) * c3) : (a4 = (t5.max.z - u3.z) * c3, o7 = (t5.min.z - u3.z) * c3), n8 > o7 || a4 > i6 ? null : ((a4 > n8 || n8 != n8) && (n8 = a4), (o7 < i6 || i6 != i6) && (i6 = o7), i6 < 0 ? null : this.at(n8 >= 0 ? n8 : i6, e8)));
    }
    intersectsBox(t5) {
      return this.intersectBox(t5, ut) !== null;
    }
    intersectTriangle(t5, e8, n8, i6, r5) {
      ft.subVectors(e8, t5), gt.subVectors(n8, t5), vt.crossVectors(ft, gt);
      let s6, a4 = this.direction.dot(vt);
      if (a4 > 0) {
        if (i6)
          return null;
        s6 = 1;
      } else {
        if (!(a4 < 0))
          return null;
        s6 = -1, a4 = -a4;
      }
      mt.subVectors(this.origin, t5);
      const o7 = s6 * this.direction.dot(gt.crossVectors(mt, gt));
      if (o7 < 0)
        return null;
      const l6 = s6 * this.direction.dot(ft.cross(mt));
      if (l6 < 0)
        return null;
      if (o7 + l6 > a4)
        return null;
      const h4 = -s6 * mt.dot(vt);
      return h4 < 0 ? null : this.at(h4 / a4, r5);
    }
    applyMatrix4(t5) {
      return this.origin.applyMatrix4(t5), this.direction.transformDirection(t5), this;
    }
    equals(t5) {
      return t5.origin.equals(this.origin) && t5.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var xt = class {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4, c3, u3, d3, p3, m3, f3) {
      const g3 = this.elements;
      return g3[0] = t5, g3[4] = e8, g3[8] = n8, g3[12] = i6, g3[1] = r5, g3[5] = s6, g3[9] = a4, g3[13] = o7, g3[2] = l6, g3[6] = h4, g3[10] = c3, g3[14] = u3, g3[3] = d3, g3[7] = p3, g3[11] = m3, g3[15] = f3, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new xt().fromArray(this.elements);
    }
    copy(t5) {
      const e8 = this.elements, n8 = t5.elements;
      return e8[0] = n8[0], e8[1] = n8[1], e8[2] = n8[2], e8[3] = n8[3], e8[4] = n8[4], e8[5] = n8[5], e8[6] = n8[6], e8[7] = n8[7], e8[8] = n8[8], e8[9] = n8[9], e8[10] = n8[10], e8[11] = n8[11], e8[12] = n8[12], e8[13] = n8[13], e8[14] = n8[14], e8[15] = n8[15], this;
    }
    copyPosition(t5) {
      const e8 = this.elements, n8 = t5.elements;
      return e8[12] = n8[12], e8[13] = n8[13], e8[14] = n8[14], this;
    }
    setFromMatrix3(t5) {
      const e8 = t5.elements;
      return this.set(e8[0], e8[3], e8[6], 0, e8[1], e8[4], e8[7], 0, e8[2], e8[5], e8[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t5, e8, n8) {
      return t5.setFromMatrixColumn(this, 0), e8.setFromMatrixColumn(this, 1), n8.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t5, e8, n8) {
      return this.set(t5.x, e8.x, n8.x, 0, t5.y, e8.y, n8.y, 0, t5.z, e8.z, n8.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t5) {
      const e8 = this.elements, n8 = t5.elements, i6 = 1 / bt.setFromMatrixColumn(t5, 0).length(), r5 = 1 / bt.setFromMatrixColumn(t5, 1).length(), s6 = 1 / bt.setFromMatrixColumn(t5, 2).length();
      return e8[0] = n8[0] * i6, e8[1] = n8[1] * i6, e8[2] = n8[2] * i6, e8[3] = 0, e8[4] = n8[4] * r5, e8[5] = n8[5] * r5, e8[6] = n8[6] * r5, e8[7] = 0, e8[8] = n8[8] * s6, e8[9] = n8[9] * s6, e8[10] = n8[10] * s6, e8[11] = 0, e8[12] = 0, e8[13] = 0, e8[14] = 0, e8[15] = 1, this;
    }
    makeRotationFromEuler(t5) {
      t5 && t5.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const e8 = this.elements, n8 = t5.x, i6 = t5.y, r5 = t5.z, s6 = Math.cos(n8), a4 = Math.sin(n8), o7 = Math.cos(i6), l6 = Math.sin(i6), h4 = Math.cos(r5), c3 = Math.sin(r5);
      if (t5.order === "XYZ") {
        const t6 = s6 * h4, n9 = s6 * c3, i7 = a4 * h4, r6 = a4 * c3;
        e8[0] = o7 * h4, e8[4] = -o7 * c3, e8[8] = l6, e8[1] = n9 + i7 * l6, e8[5] = t6 - r6 * l6, e8[9] = -a4 * o7, e8[2] = r6 - t6 * l6, e8[6] = i7 + n9 * l6, e8[10] = s6 * o7;
      } else if (t5.order === "YXZ") {
        const t6 = o7 * h4, n9 = o7 * c3, i7 = l6 * h4, r6 = l6 * c3;
        e8[0] = t6 + r6 * a4, e8[4] = i7 * a4 - n9, e8[8] = s6 * l6, e8[1] = s6 * c3, e8[5] = s6 * h4, e8[9] = -a4, e8[2] = n9 * a4 - i7, e8[6] = r6 + t6 * a4, e8[10] = s6 * o7;
      } else if (t5.order === "ZXY") {
        const t6 = o7 * h4, n9 = o7 * c3, i7 = l6 * h4, r6 = l6 * c3;
        e8[0] = t6 - r6 * a4, e8[4] = -s6 * c3, e8[8] = i7 + n9 * a4, e8[1] = n9 + i7 * a4, e8[5] = s6 * h4, e8[9] = r6 - t6 * a4, e8[2] = -s6 * l6, e8[6] = a4, e8[10] = s6 * o7;
      } else if (t5.order === "ZYX") {
        const t6 = s6 * h4, n9 = s6 * c3, i7 = a4 * h4, r6 = a4 * c3;
        e8[0] = o7 * h4, e8[4] = i7 * l6 - n9, e8[8] = t6 * l6 + r6, e8[1] = o7 * c3, e8[5] = r6 * l6 + t6, e8[9] = n9 * l6 - i7, e8[2] = -l6, e8[6] = a4 * o7, e8[10] = s6 * o7;
      } else if (t5.order === "YZX") {
        const t6 = s6 * o7, n9 = s6 * l6, i7 = a4 * o7, r6 = a4 * l6;
        e8[0] = o7 * h4, e8[4] = r6 - t6 * c3, e8[8] = i7 * c3 + n9, e8[1] = c3, e8[5] = s6 * h4, e8[9] = -a4 * h4, e8[2] = -l6 * h4, e8[6] = n9 * c3 + i7, e8[10] = t6 - r6 * c3;
      } else if (t5.order === "XZY") {
        const t6 = s6 * o7, n9 = s6 * l6, i7 = a4 * o7, r6 = a4 * l6;
        e8[0] = o7 * h4, e8[4] = -c3, e8[8] = l6 * h4, e8[1] = t6 * c3 + r6, e8[5] = s6 * h4, e8[9] = n9 * c3 - i7, e8[2] = i7 * c3 - n9, e8[6] = a4 * h4, e8[10] = r6 * c3 + t6;
      }
      return e8[3] = 0, e8[7] = 0, e8[11] = 0, e8[12] = 0, e8[13] = 0, e8[14] = 0, e8[15] = 1, this;
    }
    makeRotationFromQuaternion(t5) {
      return this.compose(wt, t5, Mt);
    }
    lookAt(t5, e8, n8) {
      const i6 = this.elements;
      return Et.subVectors(t5, e8), Et.lengthSq() === 0 && (Et.z = 1), Et.normalize(), St.crossVectors(n8, Et), St.lengthSq() === 0 && (Math.abs(n8.z) === 1 ? Et.x += 1e-4 : Et.z += 1e-4, Et.normalize(), St.crossVectors(n8, Et)), St.normalize(), Tt.crossVectors(Et, St), i6[0] = St.x, i6[4] = Tt.x, i6[8] = Et.x, i6[1] = St.y, i6[5] = Tt.y, i6[9] = Et.y, i6[2] = St.z, i6[6] = Tt.z, i6[10] = Et.z, this;
    }
    multiply(t5, e8) {
      return e8 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t5, e8)) : this.multiplyMatrices(this, t5);
    }
    premultiply(t5) {
      return this.multiplyMatrices(t5, this);
    }
    multiplyMatrices(t5, e8) {
      const n8 = t5.elements, i6 = e8.elements, r5 = this.elements, s6 = n8[0], a4 = n8[4], o7 = n8[8], l6 = n8[12], h4 = n8[1], c3 = n8[5], u3 = n8[9], d3 = n8[13], p3 = n8[2], m3 = n8[6], f3 = n8[10], g3 = n8[14], v3 = n8[3], y3 = n8[7], x3 = n8[11], b3 = n8[15], _3 = i6[0], w3 = i6[4], M3 = i6[8], S4 = i6[12], T3 = i6[1], E3 = i6[5], A3 = i6[9], R2 = i6[13], C3 = i6[2], L3 = i6[6], P3 = i6[10], D2 = i6[14], I3 = i6[3], O2 = i6[7], N3 = i6[11], F2 = i6[15];
      return r5[0] = s6 * _3 + a4 * T3 + o7 * C3 + l6 * I3, r5[4] = s6 * w3 + a4 * E3 + o7 * L3 + l6 * O2, r5[8] = s6 * M3 + a4 * A3 + o7 * P3 + l6 * N3, r5[12] = s6 * S4 + a4 * R2 + o7 * D2 + l6 * F2, r5[1] = h4 * _3 + c3 * T3 + u3 * C3 + d3 * I3, r5[5] = h4 * w3 + c3 * E3 + u3 * L3 + d3 * O2, r5[9] = h4 * M3 + c3 * A3 + u3 * P3 + d3 * N3, r5[13] = h4 * S4 + c3 * R2 + u3 * D2 + d3 * F2, r5[2] = p3 * _3 + m3 * T3 + f3 * C3 + g3 * I3, r5[6] = p3 * w3 + m3 * E3 + f3 * L3 + g3 * O2, r5[10] = p3 * M3 + m3 * A3 + f3 * P3 + g3 * N3, r5[14] = p3 * S4 + m3 * R2 + f3 * D2 + g3 * F2, r5[3] = v3 * _3 + y3 * T3 + x3 * C3 + b3 * I3, r5[7] = v3 * w3 + y3 * E3 + x3 * L3 + b3 * O2, r5[11] = v3 * M3 + y3 * A3 + x3 * P3 + b3 * N3, r5[15] = v3 * S4 + y3 * R2 + x3 * D2 + b3 * F2, this;
    }
    multiplyScalar(t5) {
      const e8 = this.elements;
      return e8[0] *= t5, e8[4] *= t5, e8[8] *= t5, e8[12] *= t5, e8[1] *= t5, e8[5] *= t5, e8[9] *= t5, e8[13] *= t5, e8[2] *= t5, e8[6] *= t5, e8[10] *= t5, e8[14] *= t5, e8[3] *= t5, e8[7] *= t5, e8[11] *= t5, e8[15] *= t5, this;
    }
    determinant() {
      const t5 = this.elements, e8 = t5[0], n8 = t5[4], i6 = t5[8], r5 = t5[12], s6 = t5[1], a4 = t5[5], o7 = t5[9], l6 = t5[13], h4 = t5[2], c3 = t5[6], u3 = t5[10], d3 = t5[14];
      return t5[3] * (+r5 * o7 * c3 - i6 * l6 * c3 - r5 * a4 * u3 + n8 * l6 * u3 + i6 * a4 * d3 - n8 * o7 * d3) + t5[7] * (+e8 * o7 * d3 - e8 * l6 * u3 + r5 * s6 * u3 - i6 * s6 * d3 + i6 * l6 * h4 - r5 * o7 * h4) + t5[11] * (+e8 * l6 * c3 - e8 * a4 * d3 - r5 * s6 * c3 + n8 * s6 * d3 + r5 * a4 * h4 - n8 * l6 * h4) + t5[15] * (-i6 * a4 * h4 - e8 * o7 * c3 + e8 * a4 * u3 + i6 * s6 * c3 - n8 * s6 * u3 + n8 * o7 * h4);
    }
    transpose() {
      const t5 = this.elements;
      let e8;
      return e8 = t5[1], t5[1] = t5[4], t5[4] = e8, e8 = t5[2], t5[2] = t5[8], t5[8] = e8, e8 = t5[6], t5[6] = t5[9], t5[9] = e8, e8 = t5[3], t5[3] = t5[12], t5[12] = e8, e8 = t5[7], t5[7] = t5[13], t5[13] = e8, e8 = t5[11], t5[11] = t5[14], t5[14] = e8, this;
    }
    setPosition(t5, e8, n8) {
      const i6 = this.elements;
      return t5.isVector3 ? (i6[12] = t5.x, i6[13] = t5.y, i6[14] = t5.z) : (i6[12] = t5, i6[13] = e8, i6[14] = n8), this;
    }
    invert() {
      const t5 = this.elements, e8 = t5[0], n8 = t5[1], i6 = t5[2], r5 = t5[3], s6 = t5[4], a4 = t5[5], o7 = t5[6], l6 = t5[7], h4 = t5[8], c3 = t5[9], u3 = t5[10], d3 = t5[11], p3 = t5[12], m3 = t5[13], f3 = t5[14], g3 = t5[15], v3 = c3 * f3 * l6 - m3 * u3 * l6 + m3 * o7 * d3 - a4 * f3 * d3 - c3 * o7 * g3 + a4 * u3 * g3, y3 = p3 * u3 * l6 - h4 * f3 * l6 - p3 * o7 * d3 + s6 * f3 * d3 + h4 * o7 * g3 - s6 * u3 * g3, x3 = h4 * m3 * l6 - p3 * c3 * l6 + p3 * a4 * d3 - s6 * m3 * d3 - h4 * a4 * g3 + s6 * c3 * g3, b3 = p3 * c3 * o7 - h4 * m3 * o7 - p3 * a4 * u3 + s6 * m3 * u3 + h4 * a4 * f3 - s6 * c3 * f3, _3 = e8 * v3 + n8 * y3 + i6 * x3 + r5 * b3;
      if (_3 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const w3 = 1 / _3;
      return t5[0] = v3 * w3, t5[1] = (m3 * u3 * r5 - c3 * f3 * r5 - m3 * i6 * d3 + n8 * f3 * d3 + c3 * i6 * g3 - n8 * u3 * g3) * w3, t5[2] = (a4 * f3 * r5 - m3 * o7 * r5 + m3 * i6 * l6 - n8 * f3 * l6 - a4 * i6 * g3 + n8 * o7 * g3) * w3, t5[3] = (c3 * o7 * r5 - a4 * u3 * r5 - c3 * i6 * l6 + n8 * u3 * l6 + a4 * i6 * d3 - n8 * o7 * d3) * w3, t5[4] = y3 * w3, t5[5] = (h4 * f3 * r5 - p3 * u3 * r5 + p3 * i6 * d3 - e8 * f3 * d3 - h4 * i6 * g3 + e8 * u3 * g3) * w3, t5[6] = (p3 * o7 * r5 - s6 * f3 * r5 - p3 * i6 * l6 + e8 * f3 * l6 + s6 * i6 * g3 - e8 * o7 * g3) * w3, t5[7] = (s6 * u3 * r5 - h4 * o7 * r5 + h4 * i6 * l6 - e8 * u3 * l6 - s6 * i6 * d3 + e8 * o7 * d3) * w3, t5[8] = x3 * w3, t5[9] = (p3 * c3 * r5 - h4 * m3 * r5 - p3 * n8 * d3 + e8 * m3 * d3 + h4 * n8 * g3 - e8 * c3 * g3) * w3, t5[10] = (s6 * m3 * r5 - p3 * a4 * r5 + p3 * n8 * l6 - e8 * m3 * l6 - s6 * n8 * g3 + e8 * a4 * g3) * w3, t5[11] = (h4 * a4 * r5 - s6 * c3 * r5 - h4 * n8 * l6 + e8 * c3 * l6 + s6 * n8 * d3 - e8 * a4 * d3) * w3, t5[12] = b3 * w3, t5[13] = (h4 * m3 * i6 - p3 * c3 * i6 + p3 * n8 * u3 - e8 * m3 * u3 - h4 * n8 * f3 + e8 * c3 * f3) * w3, t5[14] = (p3 * a4 * i6 - s6 * m3 * i6 - p3 * n8 * o7 + e8 * m3 * o7 + s6 * n8 * f3 - e8 * a4 * f3) * w3, t5[15] = (s6 * c3 * i6 - h4 * a4 * i6 + h4 * n8 * o7 - e8 * c3 * o7 - s6 * n8 * u3 + e8 * a4 * u3) * w3, this;
    }
    scale(t5) {
      const e8 = this.elements, n8 = t5.x, i6 = t5.y, r5 = t5.z;
      return e8[0] *= n8, e8[4] *= i6, e8[8] *= r5, e8[1] *= n8, e8[5] *= i6, e8[9] *= r5, e8[2] *= n8, e8[6] *= i6, e8[10] *= r5, e8[3] *= n8, e8[7] *= i6, e8[11] *= r5, this;
    }
    getMaxScaleOnAxis() {
      const t5 = this.elements, e8 = t5[0] * t5[0] + t5[1] * t5[1] + t5[2] * t5[2], n8 = t5[4] * t5[4] + t5[5] * t5[5] + t5[6] * t5[6], i6 = t5[8] * t5[8] + t5[9] * t5[9] + t5[10] * t5[10];
      return Math.sqrt(Math.max(e8, n8, i6));
    }
    makeTranslation(t5, e8, n8) {
      return this.set(1, 0, 0, t5, 0, 1, 0, e8, 0, 0, 1, n8, 0, 0, 0, 1), this;
    }
    makeRotationX(t5) {
      const e8 = Math.cos(t5), n8 = Math.sin(t5);
      return this.set(1, 0, 0, 0, 0, e8, -n8, 0, 0, n8, e8, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t5) {
      const e8 = Math.cos(t5), n8 = Math.sin(t5);
      return this.set(e8, 0, n8, 0, 0, 1, 0, 0, -n8, 0, e8, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t5) {
      const e8 = Math.cos(t5), n8 = Math.sin(t5);
      return this.set(e8, -n8, 0, 0, n8, e8, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t5, e8) {
      const n8 = Math.cos(e8), i6 = Math.sin(e8), r5 = 1 - n8, s6 = t5.x, a4 = t5.y, o7 = t5.z, l6 = r5 * s6, h4 = r5 * a4;
      return this.set(l6 * s6 + n8, l6 * a4 - i6 * o7, l6 * o7 + i6 * a4, 0, l6 * a4 + i6 * o7, h4 * a4 + n8, h4 * o7 - i6 * s6, 0, l6 * o7 - i6 * a4, h4 * o7 + i6 * s6, r5 * o7 * o7 + n8, 0, 0, 0, 0, 1), this;
    }
    makeScale(t5, e8, n8) {
      return this.set(t5, 0, 0, 0, 0, e8, 0, 0, 0, 0, n8, 0, 0, 0, 0, 1), this;
    }
    makeShear(t5, e8, n8, i6, r5, s6) {
      return this.set(1, n8, r5, 0, t5, 1, s6, 0, e8, i6, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t5, e8, n8) {
      const i6 = this.elements, r5 = e8._x, s6 = e8._y, a4 = e8._z, o7 = e8._w, l6 = r5 + r5, h4 = s6 + s6, c3 = a4 + a4, u3 = r5 * l6, d3 = r5 * h4, p3 = r5 * c3, m3 = s6 * h4, f3 = s6 * c3, g3 = a4 * c3, v3 = o7 * l6, y3 = o7 * h4, x3 = o7 * c3, b3 = n8.x, _3 = n8.y, w3 = n8.z;
      return i6[0] = (1 - (m3 + g3)) * b3, i6[1] = (d3 + x3) * b3, i6[2] = (p3 - y3) * b3, i6[3] = 0, i6[4] = (d3 - x3) * _3, i6[5] = (1 - (u3 + g3)) * _3, i6[6] = (f3 + v3) * _3, i6[7] = 0, i6[8] = (p3 + y3) * w3, i6[9] = (f3 - v3) * w3, i6[10] = (1 - (u3 + m3)) * w3, i6[11] = 0, i6[12] = t5.x, i6[13] = t5.y, i6[14] = t5.z, i6[15] = 1, this;
    }
    decompose(t5, e8, n8) {
      const i6 = this.elements;
      let r5 = bt.set(i6[0], i6[1], i6[2]).length();
      const s6 = bt.set(i6[4], i6[5], i6[6]).length(), a4 = bt.set(i6[8], i6[9], i6[10]).length();
      this.determinant() < 0 && (r5 = -r5), t5.x = i6[12], t5.y = i6[13], t5.z = i6[14], _t.copy(this);
      const o7 = 1 / r5, l6 = 1 / s6, h4 = 1 / a4;
      return _t.elements[0] *= o7, _t.elements[1] *= o7, _t.elements[2] *= o7, _t.elements[4] *= l6, _t.elements[5] *= l6, _t.elements[6] *= l6, _t.elements[8] *= h4, _t.elements[9] *= h4, _t.elements[10] *= h4, e8.setFromRotationMatrix(_t), n8.x = r5, n8.y = s6, n8.z = a4, this;
    }
    makePerspective(t5, e8, n8, i6, r5, s6) {
      s6 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const a4 = this.elements, o7 = 2 * r5 / (e8 - t5), l6 = 2 * r5 / (n8 - i6), h4 = (e8 + t5) / (e8 - t5), c3 = (n8 + i6) / (n8 - i6), u3 = -(s6 + r5) / (s6 - r5), d3 = -2 * s6 * r5 / (s6 - r5);
      return a4[0] = o7, a4[4] = 0, a4[8] = h4, a4[12] = 0, a4[1] = 0, a4[5] = l6, a4[9] = c3, a4[13] = 0, a4[2] = 0, a4[6] = 0, a4[10] = u3, a4[14] = d3, a4[3] = 0, a4[7] = 0, a4[11] = -1, a4[15] = 0, this;
    }
    makeOrthographic(t5, e8, n8, i6, r5, s6) {
      const a4 = this.elements, o7 = 1 / (e8 - t5), l6 = 1 / (n8 - i6), h4 = 1 / (s6 - r5), c3 = (e8 + t5) * o7, u3 = (n8 + i6) * l6, d3 = (s6 + r5) * h4;
      return a4[0] = 2 * o7, a4[4] = 0, a4[8] = 0, a4[12] = -c3, a4[1] = 0, a4[5] = 2 * l6, a4[9] = 0, a4[13] = -u3, a4[2] = 0, a4[6] = 0, a4[10] = -2 * h4, a4[14] = -d3, a4[3] = 0, a4[7] = 0, a4[11] = 0, a4[15] = 1, this;
    }
    equals(t5) {
      const e8 = this.elements, n8 = t5.elements;
      for (let t6 = 0; t6 < 16; t6++)
        if (e8[t6] !== n8[t6])
          return false;
      return true;
    }
    fromArray(t5, e8 = 0) {
      for (let n8 = 0; n8 < 16; n8++)
        this.elements[n8] = t5[n8 + e8];
      return this;
    }
    toArray(t5 = [], e8 = 0) {
      const n8 = this.elements;
      return t5[e8] = n8[0], t5[e8 + 1] = n8[1], t5[e8 + 2] = n8[2], t5[e8 + 3] = n8[3], t5[e8 + 4] = n8[4], t5[e8 + 5] = n8[5], t5[e8 + 6] = n8[6], t5[e8 + 7] = n8[7], t5[e8 + 8] = n8[8], t5[e8 + 9] = n8[9], t5[e8 + 10] = n8[10], t5[e8 + 11] = n8[11], t5[e8 + 12] = n8[12], t5[e8 + 13] = n8[13], t5[e8 + 14] = n8[14], t5[e8 + 15] = n8[15], t5;
    }
  };
  xt.prototype.isMatrix4 = true;
  var bt = new V2();
  var _t = new xt();
  var wt = new V2(0, 0, 0);
  var Mt = new V2(1, 1, 1);
  var St = new V2();
  var Tt = new V2();
  var Et = new V2();
  var At = new xt();
  var Rt = new H2();
  var Ct = class {
    constructor(t5 = 0, e8 = 0, n8 = 0, i6 = Ct.DefaultOrder) {
      this._x = t5, this._y = e8, this._z = n8, this._order = i6;
    }
    get x() {
      return this._x;
    }
    set x(t5) {
      this._x = t5, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t5) {
      this._y = t5, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t5) {
      this._z = t5, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t5) {
      this._order = t5, this._onChangeCallback();
    }
    set(t5, e8, n8, i6 = this._order) {
      return this._x = t5, this._y = e8, this._z = n8, this._order = i6, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t5) {
      return this._x = t5._x, this._y = t5._y, this._z = t5._z, this._order = t5._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t5, e8 = this._order, n8 = true) {
      const i6 = t5.elements, r5 = i6[0], s6 = i6[4], a4 = i6[8], o7 = i6[1], l6 = i6[5], c3 = i6[9], u3 = i6[2], d3 = i6[6], p3 = i6[10];
      switch (e8) {
        case "XYZ":
          this._y = Math.asin(h3(a4, -1, 1)), Math.abs(a4) < 0.9999999 ? (this._x = Math.atan2(-c3, p3), this._z = Math.atan2(-s6, r5)) : (this._x = Math.atan2(d3, l6), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-h3(c3, -1, 1)), Math.abs(c3) < 0.9999999 ? (this._y = Math.atan2(a4, p3), this._z = Math.atan2(o7, l6)) : (this._y = Math.atan2(-u3, r5), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(h3(d3, -1, 1)), Math.abs(d3) < 0.9999999 ? (this._y = Math.atan2(-u3, p3), this._z = Math.atan2(-s6, l6)) : (this._y = 0, this._z = Math.atan2(o7, r5));
          break;
        case "ZYX":
          this._y = Math.asin(-h3(u3, -1, 1)), Math.abs(u3) < 0.9999999 ? (this._x = Math.atan2(d3, p3), this._z = Math.atan2(o7, r5)) : (this._x = 0, this._z = Math.atan2(-s6, l6));
          break;
        case "YZX":
          this._z = Math.asin(h3(o7, -1, 1)), Math.abs(o7) < 0.9999999 ? (this._x = Math.atan2(-c3, l6), this._y = Math.atan2(-u3, r5)) : (this._x = 0, this._y = Math.atan2(a4, p3));
          break;
        case "XZY":
          this._z = Math.asin(-h3(s6, -1, 1)), Math.abs(s6) < 0.9999999 ? (this._x = Math.atan2(d3, l6), this._y = Math.atan2(a4, r5)) : (this._x = Math.atan2(-c3, p3), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e8);
      }
      return this._order = e8, n8 === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(t5, e8, n8) {
      return At.makeRotationFromQuaternion(t5), this.setFromRotationMatrix(At, e8, n8);
    }
    setFromVector3(t5, e8 = this._order) {
      return this.set(t5.x, t5.y, t5.z, e8);
    }
    reorder(t5) {
      return Rt.setFromEuler(this), this.setFromQuaternion(Rt, t5);
    }
    equals(t5) {
      return t5._x === this._x && t5._y === this._y && t5._z === this._z && t5._order === this._order;
    }
    fromArray(t5) {
      return this._x = t5[0], this._y = t5[1], this._z = t5[2], t5[3] !== void 0 && (this._order = t5[3]), this._onChangeCallback(), this;
    }
    toArray(t5 = [], e8 = 0) {
      return t5[e8] = this._x, t5[e8 + 1] = this._y, t5[e8 + 2] = this._z, t5[e8 + 3] = this._order, t5;
    }
    _onChange(t5) {
      return this._onChangeCallback = t5, this;
    }
    _onChangeCallback() {
    }
  };
  Ct.prototype.isEuler = true, Ct.DefaultOrder = "XYZ", Ct.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Lt = class {
    constructor() {
      this.mask = 1;
    }
    set(t5) {
      this.mask = (1 << t5 | 0) >>> 0;
    }
    enable(t5) {
      this.mask |= 1 << t5 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t5) {
      this.mask ^= 1 << t5 | 0;
    }
    disable(t5) {
      this.mask &= ~(1 << t5 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t5) {
      return (this.mask & t5.mask) != 0;
    }
    isEnabled(t5) {
      return (this.mask & (1 << t5 | 0)) != 0;
    }
  };
  var Pt = 0;
  var Dt = new V2();
  var It = new H2();
  var Ot = new xt();
  var Nt = new V2();
  var Ft = new V2();
  var Ut = new V2();
  var kt = new H2();
  var Bt = new V2(1, 0, 0);
  var zt = new V2(0, 1, 0);
  var Ht = new V2(0, 0, 1);
  var Vt = { type: "added" };
  var Gt = { type: "removed" };
  var Wt = class extends i5 {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: Pt++ }), this.uuid = l5(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wt.DefaultUp.clone();
      const t5 = new V2(), e8 = new Ct(), n8 = new H2(), i6 = new V2(1, 1, 1);
      e8._onChange(function() {
        n8.setFromEuler(e8, false);
      }), n8._onChange(function() {
        e8.setFromQuaternion(n8, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t5 }, rotation: { configurable: true, enumerable: true, value: e8 }, quaternion: { configurable: true, enumerable: true, value: n8 }, scale: { configurable: true, enumerable: true, value: i6 }, modelViewMatrix: { value: new xt() }, normalMatrix: { value: new v2() } }), this.matrix = new xt(), this.matrixWorld = new xt(), this.matrixAutoUpdate = Wt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Lt(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(t5) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t5), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t5) {
      return this.quaternion.premultiply(t5), this;
    }
    setRotationFromAxisAngle(t5, e8) {
      this.quaternion.setFromAxisAngle(t5, e8);
    }
    setRotationFromEuler(t5) {
      this.quaternion.setFromEuler(t5, true);
    }
    setRotationFromMatrix(t5) {
      this.quaternion.setFromRotationMatrix(t5);
    }
    setRotationFromQuaternion(t5) {
      this.quaternion.copy(t5);
    }
    rotateOnAxis(t5, e8) {
      return It.setFromAxisAngle(t5, e8), this.quaternion.multiply(It), this;
    }
    rotateOnWorldAxis(t5, e8) {
      return It.setFromAxisAngle(t5, e8), this.quaternion.premultiply(It), this;
    }
    rotateX(t5) {
      return this.rotateOnAxis(Bt, t5);
    }
    rotateY(t5) {
      return this.rotateOnAxis(zt, t5);
    }
    rotateZ(t5) {
      return this.rotateOnAxis(Ht, t5);
    }
    translateOnAxis(t5, e8) {
      return Dt.copy(t5).applyQuaternion(this.quaternion), this.position.add(Dt.multiplyScalar(e8)), this;
    }
    translateX(t5) {
      return this.translateOnAxis(Bt, t5);
    }
    translateY(t5) {
      return this.translateOnAxis(zt, t5);
    }
    translateZ(t5) {
      return this.translateOnAxis(Ht, t5);
    }
    localToWorld(t5) {
      return t5.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t5) {
      return t5.applyMatrix4(Ot.copy(this.matrixWorld).invert());
    }
    lookAt(t5, e8, n8) {
      t5.isVector3 ? Nt.copy(t5) : Nt.set(t5, e8, n8);
      const i6 = this.parent;
      this.updateWorldMatrix(true, false), Ft.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ot.lookAt(Ft, Nt, this.up) : Ot.lookAt(Nt, Ft, this.up), this.quaternion.setFromRotationMatrix(Ot), i6 && (Ot.extractRotation(i6.matrixWorld), It.setFromRotationMatrix(Ot), this.quaternion.premultiply(It.invert()));
    }
    add(t5) {
      if (arguments.length > 1) {
        for (let t6 = 0; t6 < arguments.length; t6++)
          this.add(arguments[t6]);
        return this;
      }
      return t5 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t5), this) : (t5 && t5.isObject3D ? (t5.parent !== null && t5.parent.remove(t5), t5.parent = this, this.children.push(t5), t5.dispatchEvent(Vt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t5), this);
    }
    remove(t5) {
      if (arguments.length > 1) {
        for (let t6 = 0; t6 < arguments.length; t6++)
          this.remove(arguments[t6]);
        return this;
      }
      const e8 = this.children.indexOf(t5);
      return e8 !== -1 && (t5.parent = null, this.children.splice(e8, 1), t5.dispatchEvent(Gt)), this;
    }
    removeFromParent() {
      const t5 = this.parent;
      return t5 !== null && t5.remove(this), this;
    }
    clear() {
      for (let t5 = 0; t5 < this.children.length; t5++) {
        const e8 = this.children[t5];
        e8.parent = null, e8.dispatchEvent(Gt);
      }
      return this.children.length = 0, this;
    }
    attach(t5) {
      return this.updateWorldMatrix(true, false), Ot.copy(this.matrixWorld).invert(), t5.parent !== null && (t5.parent.updateWorldMatrix(true, false), Ot.multiply(t5.parent.matrixWorld)), t5.applyMatrix4(Ot), this.add(t5), t5.updateWorldMatrix(false, true), this;
    }
    getObjectById(t5) {
      return this.getObjectByProperty("id", t5);
    }
    getObjectByName(t5) {
      return this.getObjectByProperty("name", t5);
    }
    getObjectByProperty(t5, e8) {
      if (this[t5] === e8)
        return this;
      for (let n8 = 0, i6 = this.children.length; n8 < i6; n8++) {
        const i7 = this.children[n8].getObjectByProperty(t5, e8);
        if (i7 !== void 0)
          return i7;
      }
    }
    getWorldPosition(t5) {
      return this.updateWorldMatrix(true, false), t5.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t5) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ft, t5, Ut), t5;
    }
    getWorldScale(t5) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ft, kt, t5), t5;
    }
    getWorldDirection(t5) {
      this.updateWorldMatrix(true, false);
      const e8 = this.matrixWorld.elements;
      return t5.set(e8[8], e8[9], e8[10]).normalize();
    }
    raycast() {
    }
    traverse(t5) {
      t5(this);
      const e8 = this.children;
      for (let n8 = 0, i6 = e8.length; n8 < i6; n8++)
        e8[n8].traverse(t5);
    }
    traverseVisible(t5) {
      if (this.visible === false)
        return;
      t5(this);
      const e8 = this.children;
      for (let n8 = 0, i6 = e8.length; n8 < i6; n8++)
        e8[n8].traverseVisible(t5);
    }
    traverseAncestors(t5) {
      const e8 = this.parent;
      e8 !== null && (t5(e8), e8.traverseAncestors(t5));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(t5) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t5) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t5 = true);
      const e8 = this.children;
      for (let n8 = 0, i6 = e8.length; n8 < i6; n8++)
        e8[n8].updateMatrixWorld(t5);
    }
    updateWorldMatrix(t5, e8) {
      const n8 = this.parent;
      if (t5 === true && n8 !== null && n8.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e8 === true) {
        const t6 = this.children;
        for (let e9 = 0, n9 = t6.length; e9 < n9; e9++)
          t6[e9].updateWorldMatrix(false, true);
      }
    }
    toJSON(t5) {
      const e8 = t5 === void 0 || typeof t5 == "string", n8 = {};
      e8 && (t5 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n8.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      const i6 = {};
      function r5(e9, n9) {
        return e9[n9.uuid] === void 0 && (e9[n9.uuid] = n9.toJSON(t5)), n9.uuid;
      }
      if (i6.uuid = this.uuid, i6.type = this.type, this.name !== "" && (i6.name = this.name), this.castShadow === true && (i6.castShadow = true), this.receiveShadow === true && (i6.receiveShadow = true), this.visible === false && (i6.visible = false), this.frustumCulled === false && (i6.frustumCulled = false), this.renderOrder !== 0 && (i6.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i6.userData = this.userData), i6.layers = this.layers.mask, i6.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (i6.matrixAutoUpdate = false), this.isInstancedMesh && (i6.type = "InstancedMesh", i6.count = this.count, i6.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i6.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? i6.background = this.background.toJSON() : this.background.isTexture && (i6.background = this.background.toJSON(t5).uuid)), this.environment && this.environment.isTexture && (i6.environment = this.environment.toJSON(t5).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i6.geometry = r5(t5.geometries, this.geometry);
        const e9 = this.geometry.parameters;
        if (e9 !== void 0 && e9.shapes !== void 0) {
          const n9 = e9.shapes;
          if (Array.isArray(n9))
            for (let e10 = 0, i7 = n9.length; e10 < i7; e10++) {
              const i8 = n9[e10];
              r5(t5.shapes, i8);
            }
          else
            r5(t5.shapes, n9);
        }
      }
      if (this.isSkinnedMesh && (i6.bindMode = this.bindMode, i6.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r5(t5.skeletons, this.skeleton), i6.skeleton = this.skeleton.uuid)), this.material !== void 0)
        if (Array.isArray(this.material)) {
          const e9 = [];
          for (let n9 = 0, i7 = this.material.length; n9 < i7; n9++)
            e9.push(r5(t5.materials, this.material[n9]));
          i6.material = e9;
        } else
          i6.material = r5(t5.materials, this.material);
      if (this.children.length > 0) {
        i6.children = [];
        for (let e9 = 0; e9 < this.children.length; e9++)
          i6.children.push(this.children[e9].toJSON(t5).object);
      }
      if (this.animations.length > 0) {
        i6.animations = [];
        for (let e9 = 0; e9 < this.animations.length; e9++) {
          const n9 = this.animations[e9];
          i6.animations.push(r5(t5.animations, n9));
        }
      }
      if (e8) {
        const e9 = s6(t5.geometries), i7 = s6(t5.materials), r6 = s6(t5.textures), a4 = s6(t5.images), o7 = s6(t5.shapes), l6 = s6(t5.skeletons), h4 = s6(t5.animations), c3 = s6(t5.nodes);
        e9.length > 0 && (n8.geometries = e9), i7.length > 0 && (n8.materials = i7), r6.length > 0 && (n8.textures = r6), a4.length > 0 && (n8.images = a4), o7.length > 0 && (n8.shapes = o7), l6.length > 0 && (n8.skeletons = l6), h4.length > 0 && (n8.animations = h4), c3.length > 0 && (n8.nodes = c3);
      }
      return n8.object = i6, n8;
      function s6(t6) {
        const e9 = [];
        for (const n9 in t6) {
          const i7 = t6[n9];
          delete i7.metadata, e9.push(i7);
        }
        return e9;
      }
    }
    clone(t5) {
      return new this.constructor().copy(this, t5);
    }
    copy(t5, e8 = true) {
      if (this.name = t5.name, this.up.copy(t5.up), this.position.copy(t5.position), this.rotation.order = t5.rotation.order, this.quaternion.copy(t5.quaternion), this.scale.copy(t5.scale), this.matrix.copy(t5.matrix), this.matrixWorld.copy(t5.matrixWorld), this.matrixAutoUpdate = t5.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t5.matrixWorldNeedsUpdate, this.layers.mask = t5.layers.mask, this.visible = t5.visible, this.castShadow = t5.castShadow, this.receiveShadow = t5.receiveShadow, this.frustumCulled = t5.frustumCulled, this.renderOrder = t5.renderOrder, this.userData = JSON.parse(JSON.stringify(t5.userData)), e8 === true)
        for (let e9 = 0; e9 < t5.children.length; e9++) {
          const n8 = t5.children[e9];
          this.add(n8.clone());
        }
      return this;
    }
  };
  Wt.DefaultUp = new V2(0, 1, 0), Wt.DefaultMatrixAutoUpdate = true, Wt.prototype.isObject3D = true;
  var jt = new V2();
  var qt = new V2();
  var Xt = new V2();
  var $t = new V2();
  var Yt = new V2();
  var Jt = new V2();
  var Kt = new V2();
  var Zt = new V2();
  var Qt = new V2();
  var te = new V2();
  var ee = class {
    constructor(t5 = new V2(), e8 = new V2(), n8 = new V2()) {
      this.a = t5, this.b = e8, this.c = n8;
    }
    static getNormal(t5, e8, n8, i6) {
      i6.subVectors(n8, e8), jt.subVectors(t5, e8), i6.cross(jt);
      const r5 = i6.lengthSq();
      return r5 > 0 ? i6.multiplyScalar(1 / Math.sqrt(r5)) : i6.set(0, 0, 0);
    }
    static getBarycoord(t5, e8, n8, i6, r5) {
      jt.subVectors(i6, e8), qt.subVectors(n8, e8), Xt.subVectors(t5, e8);
      const s6 = jt.dot(jt), a4 = jt.dot(qt), o7 = jt.dot(Xt), l6 = qt.dot(qt), h4 = qt.dot(Xt), c3 = s6 * l6 - a4 * a4;
      if (c3 === 0)
        return r5.set(-2, -1, -1);
      const u3 = 1 / c3, d3 = (l6 * o7 - a4 * h4) * u3, p3 = (s6 * h4 - a4 * o7) * u3;
      return r5.set(1 - d3 - p3, p3, d3);
    }
    static containsPoint(t5, e8, n8, i6) {
      return this.getBarycoord(t5, e8, n8, i6, $t), $t.x >= 0 && $t.y >= 0 && $t.x + $t.y <= 1;
    }
    static getUV(t5, e8, n8, i6, r5, s6, a4, o7) {
      return this.getBarycoord(t5, e8, n8, i6, $t), o7.set(0, 0), o7.addScaledVector(r5, $t.x), o7.addScaledVector(s6, $t.y), o7.addScaledVector(a4, $t.z), o7;
    }
    static isFrontFacing(t5, e8, n8, i6) {
      return jt.subVectors(n8, e8), qt.subVectors(t5, e8), jt.cross(qt).dot(i6) < 0;
    }
    set(t5, e8, n8) {
      return this.a.copy(t5), this.b.copy(e8), this.c.copy(n8), this;
    }
    setFromPointsAndIndices(t5, e8, n8, i6) {
      return this.a.copy(t5[e8]), this.b.copy(t5[n8]), this.c.copy(t5[i6]), this;
    }
    setFromAttributeAndIndices(t5, e8, n8, i6) {
      return this.a.fromBufferAttribute(t5, e8), this.b.fromBufferAttribute(t5, n8), this.c.fromBufferAttribute(t5, i6), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      return this.a.copy(t5.a), this.b.copy(t5.b), this.c.copy(t5.c), this;
    }
    getArea() {
      return jt.subVectors(this.c, this.b), qt.subVectors(this.a, this.b), 0.5 * jt.cross(qt).length();
    }
    getMidpoint(t5) {
      return t5.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t5) {
      return ee.getNormal(this.a, this.b, this.c, t5);
    }
    getPlane(t5) {
      return t5.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t5, e8) {
      return ee.getBarycoord(t5, this.a, this.b, this.c, e8);
    }
    getUV(t5, e8, n8, i6, r5) {
      return ee.getUV(t5, this.a, this.b, this.c, e8, n8, i6, r5);
    }
    containsPoint(t5) {
      return ee.containsPoint(t5, this.a, this.b, this.c);
    }
    isFrontFacing(t5) {
      return ee.isFrontFacing(this.a, this.b, this.c, t5);
    }
    intersectsBox(t5) {
      return t5.intersectsTriangle(this);
    }
    closestPointToPoint(t5, e8) {
      const n8 = this.a, i6 = this.b, r5 = this.c;
      let s6, a4;
      Yt.subVectors(i6, n8), Jt.subVectors(r5, n8), Zt.subVectors(t5, n8);
      const o7 = Yt.dot(Zt), l6 = Jt.dot(Zt);
      if (o7 <= 0 && l6 <= 0)
        return e8.copy(n8);
      Qt.subVectors(t5, i6);
      const h4 = Yt.dot(Qt), c3 = Jt.dot(Qt);
      if (h4 >= 0 && c3 <= h4)
        return e8.copy(i6);
      const u3 = o7 * c3 - h4 * l6;
      if (u3 <= 0 && o7 >= 0 && h4 <= 0)
        return s6 = o7 / (o7 - h4), e8.copy(n8).addScaledVector(Yt, s6);
      te.subVectors(t5, r5);
      const d3 = Yt.dot(te), p3 = Jt.dot(te);
      if (p3 >= 0 && d3 <= p3)
        return e8.copy(r5);
      const m3 = d3 * l6 - o7 * p3;
      if (m3 <= 0 && l6 >= 0 && p3 <= 0)
        return a4 = l6 / (l6 - p3), e8.copy(n8).addScaledVector(Jt, a4);
      const f3 = h4 * p3 - d3 * c3;
      if (f3 <= 0 && c3 - h4 >= 0 && d3 - p3 >= 0)
        return Kt.subVectors(r5, i6), a4 = (c3 - h4) / (c3 - h4 + (d3 - p3)), e8.copy(i6).addScaledVector(Kt, a4);
      const g3 = 1 / (f3 + m3 + u3);
      return s6 = m3 * g3, a4 = u3 * g3, e8.copy(n8).addScaledVector(Yt, s6).addScaledVector(Jt, a4);
    }
    equals(t5) {
      return t5.a.equals(this.a) && t5.b.equals(this.b) && t5.c.equals(this.c);
    }
  };
  var ne = 0;
  var ie = class extends i5 {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: ne++ }), this.uuid = l5(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t5) {
      this._alphaTest > 0 != t5 > 0 && this.version++, this._alphaTest = t5;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t5) {
      if (t5 !== void 0)
        for (const e8 in t5) {
          const n8 = t5[e8];
          if (n8 === void 0) {
            console.warn("THREE.Material: '" + e8 + "' parameter is undefined.");
            continue;
          }
          if (e8 === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n8 === 1;
            continue;
          }
          const i6 = this[e8];
          i6 !== void 0 ? i6 && i6.isColor ? i6.set(n8) : i6 && i6.isVector3 && n8 && n8.isVector3 ? i6.copy(n8) : this[e8] = n8 : console.warn("THREE." + this.type + ": '" + e8 + "' is not a property of this material.");
        }
    }
    toJSON(t5) {
      const e8 = t5 === void 0 || typeof t5 == "string";
      e8 && (t5 = { textures: {}, images: {} });
      const n8 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      function i6(t6) {
        const e9 = [];
        for (const n9 in t6) {
          const i7 = t6[n9];
          delete i7.metadata, e9.push(i7);
        }
        return e9;
      }
      if (n8.uuid = this.uuid, n8.type = this.type, this.name !== "" && (n8.name = this.name), this.color && this.color.isColor && (n8.color = this.color.getHex()), this.roughness !== void 0 && (n8.roughness = this.roughness), this.metalness !== void 0 && (n8.metalness = this.metalness), this.sheen !== void 0 && (n8.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n8.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n8.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n8.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n8.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n8.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n8.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n8.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n8.shininess = this.shininess), this.clearcoat !== void 0 && (n8.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n8.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n8.clearcoatMap = this.clearcoatMap.toJSON(t5).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n8.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t5).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n8.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t5).uuid, n8.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n8.map = this.map.toJSON(t5).uuid), this.matcap && this.matcap.isTexture && (n8.matcap = this.matcap.toJSON(t5).uuid), this.alphaMap && this.alphaMap.isTexture && (n8.alphaMap = this.alphaMap.toJSON(t5).uuid), this.lightMap && this.lightMap.isTexture && (n8.lightMap = this.lightMap.toJSON(t5).uuid, n8.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n8.aoMap = this.aoMap.toJSON(t5).uuid, n8.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n8.bumpMap = this.bumpMap.toJSON(t5).uuid, n8.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n8.normalMap = this.normalMap.toJSON(t5).uuid, n8.normalMapType = this.normalMapType, n8.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n8.displacementMap = this.displacementMap.toJSON(t5).uuid, n8.displacementScale = this.displacementScale, n8.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n8.roughnessMap = this.roughnessMap.toJSON(t5).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n8.metalnessMap = this.metalnessMap.toJSON(t5).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n8.emissiveMap = this.emissiveMap.toJSON(t5).uuid), this.specularMap && this.specularMap.isTexture && (n8.specularMap = this.specularMap.toJSON(t5).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n8.specularIntensityMap = this.specularIntensityMap.toJSON(t5).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n8.specularColorMap = this.specularColorMap.toJSON(t5).uuid), this.envMap && this.envMap.isTexture && (n8.envMap = this.envMap.toJSON(t5).uuid, this.combine !== void 0 && (n8.combine = this.combine)), this.envMapIntensity !== void 0 && (n8.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n8.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n8.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n8.gradientMap = this.gradientMap.toJSON(t5).uuid), this.transmission !== void 0 && (n8.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n8.transmissionMap = this.transmissionMap.toJSON(t5).uuid), this.thickness !== void 0 && (n8.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n8.thicknessMap = this.thicknessMap.toJSON(t5).uuid), this.attenuationDistance !== void 0 && (n8.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n8.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n8.size = this.size), this.shadowSide !== null && (n8.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n8.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (n8.blending = this.blending), this.side !== 0 && (n8.side = this.side), this.vertexColors && (n8.vertexColors = true), this.opacity < 1 && (n8.opacity = this.opacity), this.transparent === true && (n8.transparent = this.transparent), n8.depthFunc = this.depthFunc, n8.depthTest = this.depthTest, n8.depthWrite = this.depthWrite, n8.colorWrite = this.colorWrite, n8.stencilWrite = this.stencilWrite, n8.stencilWriteMask = this.stencilWriteMask, n8.stencilFunc = this.stencilFunc, n8.stencilRef = this.stencilRef, n8.stencilFuncMask = this.stencilFuncMask, n8.stencilFail = this.stencilFail, n8.stencilZFail = this.stencilZFail, n8.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n8.rotation = this.rotation), this.polygonOffset === true && (n8.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n8.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n8.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n8.linewidth = this.linewidth), this.dashSize !== void 0 && (n8.dashSize = this.dashSize), this.gapSize !== void 0 && (n8.gapSize = this.gapSize), this.scale !== void 0 && (n8.scale = this.scale), this.dithering === true && (n8.dithering = true), this.alphaTest > 0 && (n8.alphaTest = this.alphaTest), this.alphaToCoverage === true && (n8.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (n8.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (n8.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n8.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n8.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n8.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n8.flatShading = this.flatShading), this.visible === false && (n8.visible = false), this.toneMapped === false && (n8.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (n8.userData = this.userData), e8) {
        const e9 = i6(t5.textures), r5 = i6(t5.images);
        e9.length > 0 && (n8.textures = e9), r5.length > 0 && (n8.images = r5);
      }
      return n8;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      this.name = t5.name, this.fog = t5.fog, this.blending = t5.blending, this.side = t5.side, this.vertexColors = t5.vertexColors, this.opacity = t5.opacity, this.transparent = t5.transparent, this.blendSrc = t5.blendSrc, this.blendDst = t5.blendDst, this.blendEquation = t5.blendEquation, this.blendSrcAlpha = t5.blendSrcAlpha, this.blendDstAlpha = t5.blendDstAlpha, this.blendEquationAlpha = t5.blendEquationAlpha, this.depthFunc = t5.depthFunc, this.depthTest = t5.depthTest, this.depthWrite = t5.depthWrite, this.stencilWriteMask = t5.stencilWriteMask, this.stencilFunc = t5.stencilFunc, this.stencilRef = t5.stencilRef, this.stencilFuncMask = t5.stencilFuncMask, this.stencilFail = t5.stencilFail, this.stencilZFail = t5.stencilZFail, this.stencilZPass = t5.stencilZPass, this.stencilWrite = t5.stencilWrite;
      const e8 = t5.clippingPlanes;
      let n8 = null;
      if (e8 !== null) {
        const t6 = e8.length;
        n8 = new Array(t6);
        for (let i6 = 0; i6 !== t6; ++i6)
          n8[i6] = e8[i6].clone();
      }
      return this.clippingPlanes = n8, this.clipIntersection = t5.clipIntersection, this.clipShadows = t5.clipShadows, this.shadowSide = t5.shadowSide, this.colorWrite = t5.colorWrite, this.precision = t5.precision, this.polygonOffset = t5.polygonOffset, this.polygonOffsetFactor = t5.polygonOffsetFactor, this.polygonOffsetUnits = t5.polygonOffsetUnits, this.dithering = t5.dithering, this.alphaTest = t5.alphaTest, this.alphaToCoverage = t5.alphaToCoverage, this.premultipliedAlpha = t5.premultipliedAlpha, this.visible = t5.visible, this.toneMapped = t5.toneMapped, this.userData = JSON.parse(JSON.stringify(t5.userData)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t5) {
      t5 === true && this.version++;
    }
  };
  ie.prototype.isMaterial = true, ie.fromType = function() {
    return null;
  };
  var re = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshBasicMaterial", this.color = new L2(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.map = t5.map, this.lightMap = t5.lightMap, this.lightMapIntensity = t5.lightMapIntensity, this.aoMap = t5.aoMap, this.aoMapIntensity = t5.aoMapIntensity, this.specularMap = t5.specularMap, this.alphaMap = t5.alphaMap, this.envMap = t5.envMap, this.combine = t5.combine, this.reflectivity = t5.reflectivity, this.refractionRatio = t5.refractionRatio, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.wireframeLinecap = t5.wireframeLinecap, this.wireframeLinejoin = t5.wireframeLinejoin, this;
    }
  };
  re.prototype.isMeshBasicMaterial = true;
  var se = new V2();
  var ae = new g2();
  var oe = class {
    constructor(t5, e8, n8) {
      if (Array.isArray(t5))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = t5, this.itemSize = e8, this.count = t5 !== void 0 ? t5.length / e8 : 0, this.normalized = n8 === true, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(t5) {
      t5 === true && this.version++;
    }
    setUsage(t5) {
      return this.usage = t5, this;
    }
    copy(t5) {
      return this.name = t5.name, this.array = new t5.array.constructor(t5.array), this.itemSize = t5.itemSize, this.count = t5.count, this.normalized = t5.normalized, this.usage = t5.usage, this;
    }
    copyAt(t5, e8, n8) {
      t5 *= this.itemSize, n8 *= e8.itemSize;
      for (let i6 = 0, r5 = this.itemSize; i6 < r5; i6++)
        this.array[t5 + i6] = e8.array[n8 + i6];
      return this;
    }
    copyArray(t5) {
      return this.array.set(t5), this;
    }
    copyColorsArray(t5) {
      const e8 = this.array;
      let n8 = 0;
      for (let i6 = 0, r5 = t5.length; i6 < r5; i6++) {
        let r6 = t5[i6];
        r6 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i6), r6 = new L2()), e8[n8++] = r6.r, e8[n8++] = r6.g, e8[n8++] = r6.b;
      }
      return this;
    }
    copyVector2sArray(t5) {
      const e8 = this.array;
      let n8 = 0;
      for (let i6 = 0, r5 = t5.length; i6 < r5; i6++) {
        let r6 = t5[i6];
        r6 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i6), r6 = new g2()), e8[n8++] = r6.x, e8[n8++] = r6.y;
      }
      return this;
    }
    copyVector3sArray(t5) {
      const e8 = this.array;
      let n8 = 0;
      for (let i6 = 0, r5 = t5.length; i6 < r5; i6++) {
        let r6 = t5[i6];
        r6 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i6), r6 = new V2()), e8[n8++] = r6.x, e8[n8++] = r6.y, e8[n8++] = r6.z;
      }
      return this;
    }
    copyVector4sArray(t5) {
      const e8 = this.array;
      let n8 = 0;
      for (let i6 = 0, r5 = t5.length; i6 < r5; i6++) {
        let r6 = t5[i6];
        r6 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i6), r6 = new U()), e8[n8++] = r6.x, e8[n8++] = r6.y, e8[n8++] = r6.z, e8[n8++] = r6.w;
      }
      return this;
    }
    applyMatrix3(t5) {
      if (this.itemSize === 2)
        for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
          ae.fromBufferAttribute(this, e8), ae.applyMatrix3(t5), this.setXY(e8, ae.x, ae.y);
      else if (this.itemSize === 3)
        for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
          se.fromBufferAttribute(this, e8), se.applyMatrix3(t5), this.setXYZ(e8, se.x, se.y, se.z);
      return this;
    }
    applyMatrix4(t5) {
      for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
        se.fromBufferAttribute(this, e8), se.applyMatrix4(t5), this.setXYZ(e8, se.x, se.y, se.z);
      return this;
    }
    applyNormalMatrix(t5) {
      for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
        se.fromBufferAttribute(this, e8), se.applyNormalMatrix(t5), this.setXYZ(e8, se.x, se.y, se.z);
      return this;
    }
    transformDirection(t5) {
      for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
        se.fromBufferAttribute(this, e8), se.transformDirection(t5), this.setXYZ(e8, se.x, se.y, se.z);
      return this;
    }
    set(t5, e8 = 0) {
      return this.array.set(t5, e8), this;
    }
    getX(t5) {
      return this.array[t5 * this.itemSize];
    }
    setX(t5, e8) {
      return this.array[t5 * this.itemSize] = e8, this;
    }
    getY(t5) {
      return this.array[t5 * this.itemSize + 1];
    }
    setY(t5, e8) {
      return this.array[t5 * this.itemSize + 1] = e8, this;
    }
    getZ(t5) {
      return this.array[t5 * this.itemSize + 2];
    }
    setZ(t5, e8) {
      return this.array[t5 * this.itemSize + 2] = e8, this;
    }
    getW(t5) {
      return this.array[t5 * this.itemSize + 3];
    }
    setW(t5, e8) {
      return this.array[t5 * this.itemSize + 3] = e8, this;
    }
    setXY(t5, e8, n8) {
      return t5 *= this.itemSize, this.array[t5 + 0] = e8, this.array[t5 + 1] = n8, this;
    }
    setXYZ(t5, e8, n8, i6) {
      return t5 *= this.itemSize, this.array[t5 + 0] = e8, this.array[t5 + 1] = n8, this.array[t5 + 2] = i6, this;
    }
    setXYZW(t5, e8, n8, i6, r5) {
      return t5 *= this.itemSize, this.array[t5 + 0] = e8, this.array[t5 + 1] = n8, this.array[t5 + 2] = i6, this.array[t5 + 3] = r5, this;
    }
    onUpload(t5) {
      return this.onUploadCallback = t5, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t5 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      return this.name !== "" && (t5.name = this.name), this.usage !== 35044 && (t5.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (t5.updateRange = this.updateRange), t5;
    }
  };
  oe.prototype.isBufferAttribute = true;
  var le = class extends oe {
    constructor(t5, e8, n8) {
      super(new Uint16Array(t5), e8, n8);
    }
  };
  var he = class extends oe {
    constructor(t5, e8, n8) {
      super(new Uint32Array(t5), e8, n8);
    }
  };
  (class extends oe {
    constructor(t5, e8, n8) {
      super(new Uint16Array(t5), e8, n8);
    }
  }).prototype.isFloat16BufferAttribute = true;
  var ce = class extends oe {
    constructor(t5, e8, n8) {
      super(new Float32Array(t5), e8, n8);
    }
  };
  var ue = 0;
  var de = new xt();
  var pe = new Wt();
  var me = new V2();
  var fe = new j();
  var ge = new j();
  var ve = new V2();
  var ye = class extends i5 {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: ue++ }), this.uuid = l5(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(t5) {
      return Array.isArray(t5) ? this.index = new (y2(t5) ? he : le)(t5, 1) : this.index = t5, this;
    }
    getAttribute(t5) {
      return this.attributes[t5];
    }
    setAttribute(t5, e8) {
      return this.attributes[t5] = e8, this;
    }
    deleteAttribute(t5) {
      return delete this.attributes[t5], this;
    }
    hasAttribute(t5) {
      return this.attributes[t5] !== void 0;
    }
    addGroup(t5, e8, n8 = 0) {
      this.groups.push({ start: t5, count: e8, materialIndex: n8 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t5, e8) {
      this.drawRange.start = t5, this.drawRange.count = e8;
    }
    applyMatrix4(t5) {
      const e8 = this.attributes.position;
      e8 !== void 0 && (e8.applyMatrix4(t5), e8.needsUpdate = true);
      const n8 = this.attributes.normal;
      if (n8 !== void 0) {
        const e9 = new v2().getNormalMatrix(t5);
        n8.applyNormalMatrix(e9), n8.needsUpdate = true;
      }
      const i6 = this.attributes.tangent;
      return i6 !== void 0 && (i6.transformDirection(t5), i6.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t5) {
      return de.makeRotationFromQuaternion(t5), this.applyMatrix4(de), this;
    }
    rotateX(t5) {
      return de.makeRotationX(t5), this.applyMatrix4(de), this;
    }
    rotateY(t5) {
      return de.makeRotationY(t5), this.applyMatrix4(de), this;
    }
    rotateZ(t5) {
      return de.makeRotationZ(t5), this.applyMatrix4(de), this;
    }
    translate(t5, e8, n8) {
      return de.makeTranslation(t5, e8, n8), this.applyMatrix4(de), this;
    }
    scale(t5, e8, n8) {
      return de.makeScale(t5, e8, n8), this.applyMatrix4(de), this;
    }
    lookAt(t5) {
      return pe.lookAt(t5), pe.updateMatrix(), this.applyMatrix4(pe.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(me).negate(), this.translate(me.x, me.y, me.z), this;
    }
    setFromPoints(t5) {
      const e8 = [];
      for (let n8 = 0, i6 = t5.length; n8 < i6; n8++) {
        const i7 = t5[n8];
        e8.push(i7.x, i7.y, i7.z || 0);
      }
      return this.setAttribute("position", new ce(e8, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new j());
      const t5 = this.attributes.position, e8 = this.morphAttributes.position;
      if (t5 && t5.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new V2(-1 / 0, -1 / 0, -1 / 0), new V2(1 / 0, 1 / 0, 1 / 0));
      if (t5 !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(t5), e8)
          for (let t6 = 0, n8 = e8.length; t6 < n8; t6++) {
            const n9 = e8[t6];
            fe.setFromBufferAttribute(n9), this.morphTargetsRelative ? (ve.addVectors(this.boundingBox.min, fe.min), this.boundingBox.expandByPoint(ve), ve.addVectors(this.boundingBox.max, fe.max), this.boundingBox.expandByPoint(ve)) : (this.boundingBox.expandByPoint(fe.min), this.boundingBox.expandByPoint(fe.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new ct());
      const t5 = this.attributes.position, e8 = this.morphAttributes.position;
      if (t5 && t5.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new V2(), 1 / 0);
      if (t5) {
        const n8 = this.boundingSphere.center;
        if (fe.setFromBufferAttribute(t5), e8)
          for (let t6 = 0, n9 = e8.length; t6 < n9; t6++) {
            const n10 = e8[t6];
            ge.setFromBufferAttribute(n10), this.morphTargetsRelative ? (ve.addVectors(fe.min, ge.min), fe.expandByPoint(ve), ve.addVectors(fe.max, ge.max), fe.expandByPoint(ve)) : (fe.expandByPoint(ge.min), fe.expandByPoint(ge.max));
          }
        fe.getCenter(n8);
        let i6 = 0;
        for (let e9 = 0, r5 = t5.count; e9 < r5; e9++)
          ve.fromBufferAttribute(t5, e9), i6 = Math.max(i6, n8.distanceToSquared(ve));
        if (e8)
          for (let r5 = 0, s6 = e8.length; r5 < s6; r5++) {
            const s7 = e8[r5], a4 = this.morphTargetsRelative;
            for (let e9 = 0, r6 = s7.count; e9 < r6; e9++)
              ve.fromBufferAttribute(s7, e9), a4 && (me.fromBufferAttribute(t5, e9), ve.add(me)), i6 = Math.max(i6, n8.distanceToSquared(ve));
          }
        this.boundingSphere.radius = Math.sqrt(i6), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const t5 = this.index, e8 = this.attributes;
      if (t5 === null || e8.position === void 0 || e8.normal === void 0 || e8.uv === void 0)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const n8 = t5.array, i6 = e8.position.array, r5 = e8.normal.array, s6 = e8.uv.array, a4 = i6.length / 3;
      this.hasAttribute("tangent") === false && this.setAttribute("tangent", new oe(new Float32Array(4 * a4), 4));
      const o7 = this.getAttribute("tangent").array, l6 = [], h4 = [];
      for (let t6 = 0; t6 < a4; t6++)
        l6[t6] = new V2(), h4[t6] = new V2();
      const c3 = new V2(), u3 = new V2(), d3 = new V2(), p3 = new g2(), m3 = new g2(), f3 = new g2(), v3 = new V2(), y3 = new V2();
      function x3(t6, e9, n9) {
        c3.fromArray(i6, 3 * t6), u3.fromArray(i6, 3 * e9), d3.fromArray(i6, 3 * n9), p3.fromArray(s6, 2 * t6), m3.fromArray(s6, 2 * e9), f3.fromArray(s6, 2 * n9), u3.sub(c3), d3.sub(c3), m3.sub(p3), f3.sub(p3);
        const r6 = 1 / (m3.x * f3.y - f3.x * m3.y);
        isFinite(r6) && (v3.copy(u3).multiplyScalar(f3.y).addScaledVector(d3, -m3.y).multiplyScalar(r6), y3.copy(d3).multiplyScalar(m3.x).addScaledVector(u3, -f3.x).multiplyScalar(r6), l6[t6].add(v3), l6[e9].add(v3), l6[n9].add(v3), h4[t6].add(y3), h4[e9].add(y3), h4[n9].add(y3));
      }
      let b3 = this.groups;
      b3.length === 0 && (b3 = [{ start: 0, count: n8.length }]);
      for (let t6 = 0, e9 = b3.length; t6 < e9; ++t6) {
        const e10 = b3[t6], i7 = e10.start;
        for (let t7 = i7, r6 = i7 + e10.count; t7 < r6; t7 += 3)
          x3(n8[t7 + 0], n8[t7 + 1], n8[t7 + 2]);
      }
      const _3 = new V2(), w3 = new V2(), M3 = new V2(), S4 = new V2();
      function T3(t6) {
        M3.fromArray(r5, 3 * t6), S4.copy(M3);
        const e9 = l6[t6];
        _3.copy(e9), _3.sub(M3.multiplyScalar(M3.dot(e9))).normalize(), w3.crossVectors(S4, e9);
        const n9 = w3.dot(h4[t6]) < 0 ? -1 : 1;
        o7[4 * t6] = _3.x, o7[4 * t6 + 1] = _3.y, o7[4 * t6 + 2] = _3.z, o7[4 * t6 + 3] = n9;
      }
      for (let t6 = 0, e9 = b3.length; t6 < e9; ++t6) {
        const e10 = b3[t6], i7 = e10.start;
        for (let t7 = i7, r6 = i7 + e10.count; t7 < r6; t7 += 3)
          T3(n8[t7 + 0]), T3(n8[t7 + 1]), T3(n8[t7 + 2]);
      }
    }
    computeVertexNormals() {
      const t5 = this.index, e8 = this.getAttribute("position");
      if (e8 !== void 0) {
        let n8 = this.getAttribute("normal");
        if (n8 === void 0)
          n8 = new oe(new Float32Array(3 * e8.count), 3), this.setAttribute("normal", n8);
        else
          for (let t6 = 0, e9 = n8.count; t6 < e9; t6++)
            n8.setXYZ(t6, 0, 0, 0);
        const i6 = new V2(), r5 = new V2(), s6 = new V2(), a4 = new V2(), o7 = new V2(), l6 = new V2(), h4 = new V2(), c3 = new V2();
        if (t5)
          for (let u3 = 0, d3 = t5.count; u3 < d3; u3 += 3) {
            const d4 = t5.getX(u3 + 0), p3 = t5.getX(u3 + 1), m3 = t5.getX(u3 + 2);
            i6.fromBufferAttribute(e8, d4), r5.fromBufferAttribute(e8, p3), s6.fromBufferAttribute(e8, m3), h4.subVectors(s6, r5), c3.subVectors(i6, r5), h4.cross(c3), a4.fromBufferAttribute(n8, d4), o7.fromBufferAttribute(n8, p3), l6.fromBufferAttribute(n8, m3), a4.add(h4), o7.add(h4), l6.add(h4), n8.setXYZ(d4, a4.x, a4.y, a4.z), n8.setXYZ(p3, o7.x, o7.y, o7.z), n8.setXYZ(m3, l6.x, l6.y, l6.z);
          }
        else
          for (let t6 = 0, a5 = e8.count; t6 < a5; t6 += 3)
            i6.fromBufferAttribute(e8, t6 + 0), r5.fromBufferAttribute(e8, t6 + 1), s6.fromBufferAttribute(e8, t6 + 2), h4.subVectors(s6, r5), c3.subVectors(i6, r5), h4.cross(c3), n8.setXYZ(t6 + 0, h4.x, h4.y, h4.z), n8.setXYZ(t6 + 1, h4.x, h4.y, h4.z), n8.setXYZ(t6 + 2, h4.x, h4.y, h4.z);
        this.normalizeNormals(), n8.needsUpdate = true;
      }
    }
    merge(t5, e8) {
      if (!t5 || !t5.isBufferGeometry)
        return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t5);
      e8 === void 0 && (e8 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      const n8 = this.attributes;
      for (const i6 in n8) {
        if (t5.attributes[i6] === void 0)
          continue;
        const r5 = n8[i6].array, s6 = t5.attributes[i6], a4 = s6.array, o7 = s6.itemSize * e8, l6 = Math.min(a4.length, r5.length - o7);
        for (let t6 = 0, e9 = o7; t6 < l6; t6++, e9++)
          r5[e9] = a4[t6];
      }
      return this;
    }
    normalizeNormals() {
      const t5 = this.attributes.normal;
      for (let e8 = 0, n8 = t5.count; e8 < n8; e8++)
        ve.fromBufferAttribute(t5, e8), ve.normalize(), t5.setXYZ(e8, ve.x, ve.y, ve.z);
    }
    toNonIndexed() {
      function t5(t6, e9) {
        const n9 = t6.array, i7 = t6.itemSize, r6 = t6.normalized, s7 = new n9.constructor(e9.length * i7);
        let a4 = 0, o7 = 0;
        for (let r7 = 0, l6 = e9.length; r7 < l6; r7++) {
          a4 = t6.isInterleavedBufferAttribute ? e9[r7] * t6.data.stride + t6.offset : e9[r7] * i7;
          for (let t7 = 0; t7 < i7; t7++)
            s7[o7++] = n9[a4++];
        }
        return new oe(s7, i7, r6);
      }
      if (this.index === null)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const e8 = new ye(), n8 = this.index.array, i6 = this.attributes;
      for (const r6 in i6) {
        const s7 = t5(i6[r6], n8);
        e8.setAttribute(r6, s7);
      }
      const r5 = this.morphAttributes;
      for (const i7 in r5) {
        const s7 = [], a4 = r5[i7];
        for (let e9 = 0, i8 = a4.length; e9 < i8; e9++) {
          const i9 = t5(a4[e9], n8);
          s7.push(i9);
        }
        e8.morphAttributes[i7] = s7;
      }
      e8.morphTargetsRelative = this.morphTargetsRelative;
      const s6 = this.groups;
      for (let t6 = 0, n9 = s6.length; t6 < n9; t6++) {
        const n10 = s6[t6];
        e8.addGroup(n10.start, n10.count, n10.materialIndex);
      }
      return e8;
    }
    toJSON() {
      const t5 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (t5.uuid = this.uuid, t5.type = this.type, this.name !== "" && (t5.name = this.name), Object.keys(this.userData).length > 0 && (t5.userData = this.userData), this.parameters !== void 0) {
        const e9 = this.parameters;
        for (const n9 in e9)
          e9[n9] !== void 0 && (t5[n9] = e9[n9]);
        return t5;
      }
      t5.data = { attributes: {} };
      const e8 = this.index;
      e8 !== null && (t5.data.index = { type: e8.array.constructor.name, array: Array.prototype.slice.call(e8.array) });
      const n8 = this.attributes;
      for (const e9 in n8) {
        const i7 = n8[e9];
        t5.data.attributes[e9] = i7.toJSON(t5.data);
      }
      const i6 = {};
      let r5 = false;
      for (const e9 in this.morphAttributes) {
        const n9 = this.morphAttributes[e9], s7 = [];
        for (let e10 = 0, i7 = n9.length; e10 < i7; e10++) {
          const i8 = n9[e10];
          s7.push(i8.toJSON(t5.data));
        }
        s7.length > 0 && (i6[e9] = s7, r5 = true);
      }
      r5 && (t5.data.morphAttributes = i6, t5.data.morphTargetsRelative = this.morphTargetsRelative);
      const s6 = this.groups;
      s6.length > 0 && (t5.data.groups = JSON.parse(JSON.stringify(s6)));
      const a4 = this.boundingSphere;
      return a4 !== null && (t5.data.boundingSphere = { center: a4.center.toArray(), radius: a4.radius }), t5;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const e8 = {};
      this.name = t5.name;
      const n8 = t5.index;
      n8 !== null && this.setIndex(n8.clone(e8));
      const i6 = t5.attributes;
      for (const t6 in i6) {
        const n9 = i6[t6];
        this.setAttribute(t6, n9.clone(e8));
      }
      const r5 = t5.morphAttributes;
      for (const t6 in r5) {
        const n9 = [], i7 = r5[t6];
        for (let t7 = 0, r6 = i7.length; t7 < r6; t7++)
          n9.push(i7[t7].clone(e8));
        this.morphAttributes[t6] = n9;
      }
      this.morphTargetsRelative = t5.morphTargetsRelative;
      const s6 = t5.groups;
      for (let t6 = 0, e9 = s6.length; t6 < e9; t6++) {
        const e10 = s6[t6];
        this.addGroup(e10.start, e10.count, e10.materialIndex);
      }
      const a4 = t5.boundingBox;
      a4 !== null && (this.boundingBox = a4.clone());
      const o7 = t5.boundingSphere;
      return o7 !== null && (this.boundingSphere = o7.clone()), this.drawRange.start = t5.drawRange.start, this.drawRange.count = t5.drawRange.count, this.userData = t5.userData, t5.parameters !== void 0 && (this.parameters = Object.assign({}, t5.parameters)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  ye.prototype.isBufferGeometry = true;
  var xe = new xt();
  var be = new yt();
  var _e = new ct();
  var we = new V2();
  var Me = new V2();
  var Se = new V2();
  var Te = new V2();
  var Ee = new V2();
  var Ae = new V2();
  var Re = new V2();
  var Ce = new V2();
  var Le = new V2();
  var Pe = new g2();
  var De = new g2();
  var Ie = new g2();
  var Oe = new V2();
  var Ne = new V2();
  var Fe = class extends Wt {
    constructor(t5 = new ye(), e8 = new re()) {
      super(), this.type = "Mesh", this.geometry = t5, this.material = e8, this.updateMorphTargets();
    }
    copy(t5) {
      return super.copy(t5), t5.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t5.morphTargetInfluences.slice()), t5.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t5.morphTargetDictionary)), this.material = t5.material, this.geometry = t5.geometry, this;
    }
    updateMorphTargets() {
      const t5 = this.geometry;
      if (t5.isBufferGeometry) {
        const e8 = t5.morphAttributes, n8 = Object.keys(e8);
        if (n8.length > 0) {
          const t6 = e8[n8[0]];
          if (t6 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e9 = 0, n9 = t6.length; e9 < n9; e9++) {
              const n10 = t6[e9].name || String(e9);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n10] = e9;
            }
          }
        }
      } else {
        const e8 = t5.morphTargets;
        e8 !== void 0 && e8.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    raycast(t5, e8) {
      const n8 = this.geometry, i6 = this.material, r5 = this.matrixWorld;
      if (i6 === void 0)
        return;
      if (n8.boundingSphere === null && n8.computeBoundingSphere(), _e.copy(n8.boundingSphere), _e.applyMatrix4(r5), t5.ray.intersectsSphere(_e) === false)
        return;
      if (xe.copy(r5).invert(), be.copy(t5.ray).applyMatrix4(xe), n8.boundingBox !== null && be.intersectsBox(n8.boundingBox) === false)
        return;
      let s6;
      if (n8.isBufferGeometry) {
        const r6 = n8.index, a4 = n8.attributes.position, o7 = n8.morphAttributes.position, l6 = n8.morphTargetsRelative, h4 = n8.attributes.uv, c3 = n8.attributes.uv2, u3 = n8.groups, d3 = n8.drawRange;
        if (r6 !== null)
          if (Array.isArray(i6))
            for (let n9 = 0, p3 = u3.length; n9 < p3; n9++) {
              const p4 = u3[n9], m3 = i6[p4.materialIndex];
              for (let n10 = Math.max(p4.start, d3.start), i7 = Math.min(r6.count, Math.min(p4.start + p4.count, d3.start + d3.count)); n10 < i7; n10 += 3) {
                const i8 = r6.getX(n10), u4 = r6.getX(n10 + 1), d4 = r6.getX(n10 + 2);
                s6 = Ue(this, m3, t5, be, a4, o7, l6, h4, c3, i8, u4, d4), s6 && (s6.faceIndex = Math.floor(n10 / 3), s6.face.materialIndex = p4.materialIndex, e8.push(s6));
              }
            }
          else {
            for (let n9 = Math.max(0, d3.start), u4 = Math.min(r6.count, d3.start + d3.count); n9 < u4; n9 += 3) {
              const u5 = r6.getX(n9), d4 = r6.getX(n9 + 1), p3 = r6.getX(n9 + 2);
              s6 = Ue(this, i6, t5, be, a4, o7, l6, h4, c3, u5, d4, p3), s6 && (s6.faceIndex = Math.floor(n9 / 3), e8.push(s6));
            }
          }
        else if (a4 !== void 0)
          if (Array.isArray(i6))
            for (let n9 = 0, r7 = u3.length; n9 < r7; n9++) {
              const r8 = u3[n9], p3 = i6[r8.materialIndex];
              for (let n10 = Math.max(r8.start, d3.start), i7 = Math.min(a4.count, Math.min(r8.start + r8.count, d3.start + d3.count)); n10 < i7; n10 += 3) {
                s6 = Ue(this, p3, t5, be, a4, o7, l6, h4, c3, n10, n10 + 1, n10 + 2), s6 && (s6.faceIndex = Math.floor(n10 / 3), s6.face.materialIndex = r8.materialIndex, e8.push(s6));
              }
            }
          else {
            for (let n9 = Math.max(0, d3.start), r7 = Math.min(a4.count, d3.start + d3.count); n9 < r7; n9 += 3) {
              s6 = Ue(this, i6, t5, be, a4, o7, l6, h4, c3, n9, n9 + 1, n9 + 2), s6 && (s6.faceIndex = Math.floor(n9 / 3), e8.push(s6));
            }
          }
      } else
        n8.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  };
  function Ue(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4, c3, u3) {
    we.fromBufferAttribute(r5, h4), Me.fromBufferAttribute(r5, c3), Se.fromBufferAttribute(r5, u3);
    const d3 = t5.morphTargetInfluences;
    if (s6 && d3) {
      Re.set(0, 0, 0), Ce.set(0, 0, 0), Le.set(0, 0, 0);
      for (let t6 = 0, e9 = s6.length; t6 < e9; t6++) {
        const e10 = d3[t6], n9 = s6[t6];
        e10 !== 0 && (Te.fromBufferAttribute(n9, h4), Ee.fromBufferAttribute(n9, c3), Ae.fromBufferAttribute(n9, u3), a4 ? (Re.addScaledVector(Te, e10), Ce.addScaledVector(Ee, e10), Le.addScaledVector(Ae, e10)) : (Re.addScaledVector(Te.sub(we), e10), Ce.addScaledVector(Ee.sub(Me), e10), Le.addScaledVector(Ae.sub(Se), e10)));
      }
      we.add(Re), Me.add(Ce), Se.add(Le);
    }
    t5.isSkinnedMesh && (t5.boneTransform(h4, we), t5.boneTransform(c3, Me), t5.boneTransform(u3, Se));
    const p3 = function(t6, e9, n9, i7, r6, s7, a5, o8) {
      let l7;
      if (l7 = e9.side === 1 ? i7.intersectTriangle(a5, s7, r6, true, o8) : i7.intersectTriangle(r6, s7, a5, e9.side !== 2, o8), l7 === null)
        return null;
      Ne.copy(o8), Ne.applyMatrix4(t6.matrixWorld);
      const h5 = n9.ray.origin.distanceTo(Ne);
      return h5 < n9.near || h5 > n9.far ? null : { distance: h5, point: Ne.clone(), object: t6 };
    }(t5, e8, n8, i6, we, Me, Se, Oe);
    if (p3) {
      o7 && (Pe.fromBufferAttribute(o7, h4), De.fromBufferAttribute(o7, c3), Ie.fromBufferAttribute(o7, u3), p3.uv = ee.getUV(Oe, we, Me, Se, Pe, De, Ie, new g2())), l6 && (Pe.fromBufferAttribute(l6, h4), De.fromBufferAttribute(l6, c3), Ie.fromBufferAttribute(l6, u3), p3.uv2 = ee.getUV(Oe, we, Me, Se, Pe, De, Ie, new g2()));
      const t6 = { a: h4, b: c3, c: u3, normal: new V2(), materialIndex: 0 };
      ee.getNormal(we, Me, Se, t6.normal), p3.face = t6;
    }
    return p3;
  }
  Fe.prototype.isMesh = true;
  var ke = class extends ye {
    constructor(t5 = 1, e8 = 1, n8 = 1, i6 = 1, r5 = 1, s6 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: t5, height: e8, depth: n8, widthSegments: i6, heightSegments: r5, depthSegments: s6 };
      const a4 = this;
      i6 = Math.floor(i6), r5 = Math.floor(r5), s6 = Math.floor(s6);
      const o7 = [], l6 = [], h4 = [], c3 = [];
      let u3 = 0, d3 = 0;
      function p3(t6, e9, n9, i7, r6, s7, p4, m3, f3, g3, v3) {
        const y3 = s7 / f3, x3 = p4 / g3, b3 = s7 / 2, _3 = p4 / 2, w3 = m3 / 2, M3 = f3 + 1, S4 = g3 + 1;
        let T3 = 0, E3 = 0;
        const A3 = new V2();
        for (let s8 = 0; s8 < S4; s8++) {
          const a5 = s8 * x3 - _3;
          for (let o8 = 0; o8 < M3; o8++) {
            const u4 = o8 * y3 - b3;
            A3[t6] = u4 * i7, A3[e9] = a5 * r6, A3[n9] = w3, l6.push(A3.x, A3.y, A3.z), A3[t6] = 0, A3[e9] = 0, A3[n9] = m3 > 0 ? 1 : -1, h4.push(A3.x, A3.y, A3.z), c3.push(o8 / f3), c3.push(1 - s8 / g3), T3 += 1;
          }
        }
        for (let t7 = 0; t7 < g3; t7++)
          for (let e10 = 0; e10 < f3; e10++) {
            const n10 = u3 + e10 + M3 * t7, i8 = u3 + e10 + M3 * (t7 + 1), r7 = u3 + (e10 + 1) + M3 * (t7 + 1), s8 = u3 + (e10 + 1) + M3 * t7;
            o7.push(n10, i8, s8), o7.push(i8, r7, s8), E3 += 6;
          }
        a4.addGroup(d3, E3, v3), d3 += E3, u3 += T3;
      }
      p3("z", "y", "x", -1, -1, n8, e8, t5, s6, r5, 0), p3("z", "y", "x", 1, -1, n8, e8, -t5, s6, r5, 1), p3("x", "z", "y", 1, 1, t5, n8, e8, i6, s6, 2), p3("x", "z", "y", 1, -1, t5, n8, -e8, i6, s6, 3), p3("x", "y", "z", 1, -1, t5, e8, n8, i6, r5, 4), p3("x", "y", "z", -1, -1, t5, e8, -n8, i6, r5, 5), this.setIndex(o7), this.setAttribute("position", new ce(l6, 3)), this.setAttribute("normal", new ce(h4, 3)), this.setAttribute("uv", new ce(c3, 2));
    }
    static fromJSON(t5) {
      return new ke(t5.width, t5.height, t5.depth, t5.widthSegments, t5.heightSegments, t5.depthSegments);
    }
  };
  function Be(t5) {
    const e8 = {};
    for (const n8 in t5) {
      e8[n8] = {};
      for (const i6 in t5[n8]) {
        const r5 = t5[n8][i6];
        r5 && (r5.isColor || r5.isMatrix3 || r5.isMatrix4 || r5.isVector2 || r5.isVector3 || r5.isVector4 || r5.isTexture || r5.isQuaternion) ? e8[n8][i6] = r5.clone() : Array.isArray(r5) ? e8[n8][i6] = r5.slice() : e8[n8][i6] = r5;
      }
    }
    return e8;
  }
  function ze(t5) {
    const e8 = {};
    for (let n8 = 0; n8 < t5.length; n8++) {
      const i6 = Be(t5[n8]);
      for (const t6 in i6)
        e8[t6] = i6[t6];
    }
    return e8;
  }
  var He = { clone: Be, merge: ze };
  var Ve = class extends ie {
    constructor(t5) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t5 !== void 0 && (t5.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t5));
    }
    copy(t5) {
      return super.copy(t5), this.fragmentShader = t5.fragmentShader, this.vertexShader = t5.vertexShader, this.uniforms = Be(t5.uniforms), this.defines = Object.assign({}, t5.defines), this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.lights = t5.lights, this.clipping = t5.clipping, this.extensions = Object.assign({}, t5.extensions), this.glslVersion = t5.glslVersion, this;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      e8.glslVersion = this.glslVersion, e8.uniforms = {};
      for (const n9 in this.uniforms) {
        const i6 = this.uniforms[n9].value;
        i6 && i6.isTexture ? e8.uniforms[n9] = { type: "t", value: i6.toJSON(t5).uuid } : i6 && i6.isColor ? e8.uniforms[n9] = { type: "c", value: i6.getHex() } : i6 && i6.isVector2 ? e8.uniforms[n9] = { type: "v2", value: i6.toArray() } : i6 && i6.isVector3 ? e8.uniforms[n9] = { type: "v3", value: i6.toArray() } : i6 && i6.isVector4 ? e8.uniforms[n9] = { type: "v4", value: i6.toArray() } : i6 && i6.isMatrix3 ? e8.uniforms[n9] = { type: "m3", value: i6.toArray() } : i6 && i6.isMatrix4 ? e8.uniforms[n9] = { type: "m4", value: i6.toArray() } : e8.uniforms[n9] = { value: i6 };
      }
      Object.keys(this.defines).length > 0 && (e8.defines = this.defines), e8.vertexShader = this.vertexShader, e8.fragmentShader = this.fragmentShader;
      const n8 = {};
      for (const t6 in this.extensions)
        this.extensions[t6] === true && (n8[t6] = true);
      return Object.keys(n8).length > 0 && (e8.extensions = n8), e8;
    }
  };
  Ve.prototype.isShaderMaterial = true;
  var Ge = class extends Wt {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new xt(), this.projectionMatrix = new xt(), this.projectionMatrixInverse = new xt();
    }
    copy(t5, e8) {
      return super.copy(t5, e8), this.matrixWorldInverse.copy(t5.matrixWorldInverse), this.projectionMatrix.copy(t5.projectionMatrix), this.projectionMatrixInverse.copy(t5.projectionMatrixInverse), this;
    }
    getWorldDirection(t5) {
      this.updateWorldMatrix(true, false);
      const e8 = this.matrixWorld.elements;
      return t5.set(-e8[8], -e8[9], -e8[10]).normalize();
    }
    updateMatrixWorld(t5) {
      super.updateMatrixWorld(t5), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t5, e8) {
      super.updateWorldMatrix(t5, e8), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Ge.prototype.isCamera = true;
  var We = class extends Ge {
    constructor(t5 = 50, e8 = 1, n8 = 0.1, i6 = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = t5, this.zoom = 1, this.near = n8, this.far = i6, this.focus = 10, this.aspect = e8, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t5, e8) {
      return super.copy(t5, e8), this.fov = t5.fov, this.zoom = t5.zoom, this.near = t5.near, this.far = t5.far, this.focus = t5.focus, this.aspect = t5.aspect, this.view = t5.view === null ? null : Object.assign({}, t5.view), this.filmGauge = t5.filmGauge, this.filmOffset = t5.filmOffset, this;
    }
    setFocalLength(t5) {
      const e8 = 0.5 * this.getFilmHeight() / t5;
      this.fov = 2 * o6 * Math.atan(e8), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t5 = Math.tan(0.5 * a3 * this.fov);
      return 0.5 * this.getFilmHeight() / t5;
    }
    getEffectiveFOV() {
      return 2 * o6 * Math.atan(Math.tan(0.5 * a3 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t5, e8, n8, i6, r5, s6) {
      this.aspect = t5 / e8, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t5, this.view.fullHeight = e8, this.view.offsetX = n8, this.view.offsetY = i6, this.view.width = r5, this.view.height = s6, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t5 = this.near;
      let e8 = t5 * Math.tan(0.5 * a3 * this.fov) / this.zoom, n8 = 2 * e8, i6 = this.aspect * n8, r5 = -0.5 * i6;
      const s6 = this.view;
      if (this.view !== null && this.view.enabled) {
        const t6 = s6.fullWidth, a4 = s6.fullHeight;
        r5 += s6.offsetX * i6 / t6, e8 -= s6.offsetY * n8 / a4, i6 *= s6.width / t6, n8 *= s6.height / a4;
      }
      const o7 = this.filmOffset;
      o7 !== 0 && (r5 += t5 * o7 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r5, r5 + i6, e8, e8 - n8, t5, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.object.fov = this.fov, e8.object.zoom = this.zoom, e8.object.near = this.near, e8.object.far = this.far, e8.object.focus = this.focus, e8.object.aspect = this.aspect, this.view !== null && (e8.object.view = Object.assign({}, this.view)), e8.object.filmGauge = this.filmGauge, e8.object.filmOffset = this.filmOffset, e8;
    }
  };
  We.prototype.isPerspectiveCamera = true;
  var je = class extends Wt {
    constructor(t5, e8, n8) {
      if (super(), this.type = "CubeCamera", n8.isWebGLCubeRenderTarget !== true)
        return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      this.renderTarget = n8;
      const i6 = new We(90, 1, t5, e8);
      i6.layers = this.layers, i6.up.set(0, -1, 0), i6.lookAt(new V2(1, 0, 0)), this.add(i6);
      const r5 = new We(90, 1, t5, e8);
      r5.layers = this.layers, r5.up.set(0, -1, 0), r5.lookAt(new V2(-1, 0, 0)), this.add(r5);
      const s6 = new We(90, 1, t5, e8);
      s6.layers = this.layers, s6.up.set(0, 0, 1), s6.lookAt(new V2(0, 1, 0)), this.add(s6);
      const a4 = new We(90, 1, t5, e8);
      a4.layers = this.layers, a4.up.set(0, 0, -1), a4.lookAt(new V2(0, -1, 0)), this.add(a4);
      const o7 = new We(90, 1, t5, e8);
      o7.layers = this.layers, o7.up.set(0, -1, 0), o7.lookAt(new V2(0, 0, 1)), this.add(o7);
      const l6 = new We(90, 1, t5, e8);
      l6.layers = this.layers, l6.up.set(0, -1, 0), l6.lookAt(new V2(0, 0, -1)), this.add(l6);
    }
    update(t5, e8) {
      this.parent === null && this.updateMatrixWorld();
      const n8 = this.renderTarget, [i6, r5, s6, a4, o7, l6] = this.children, h4 = t5.getRenderTarget(), c3 = t5.outputEncoding, u3 = t5.toneMapping, d3 = t5.xr.enabled;
      t5.outputEncoding = 3e3, t5.toneMapping = 0, t5.xr.enabled = false;
      const p3 = n8.texture.generateMipmaps;
      n8.texture.generateMipmaps = false, t5.setRenderTarget(n8, 0), t5.render(e8, i6), t5.setRenderTarget(n8, 1), t5.render(e8, r5), t5.setRenderTarget(n8, 2), t5.render(e8, s6), t5.setRenderTarget(n8, 3), t5.render(e8, a4), t5.setRenderTarget(n8, 4), t5.render(e8, o7), n8.texture.generateMipmaps = p3, t5.setRenderTarget(n8, 5), t5.render(e8, l6), t5.setRenderTarget(h4), t5.outputEncoding = c3, t5.toneMapping = u3, t5.xr.enabled = d3, n8.texture.needsPMREMUpdate = true;
    }
  };
  var qe = class extends F {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4) {
      super(t5 = t5 !== void 0 ? t5 : [], e8 = e8 !== void 0 ? e8 : 301, n8, i6, r5, s6, a4, o7, l6, h4), this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(t5) {
      this.image = t5;
    }
  };
  qe.prototype.isCubeTexture = true;
  var Xe = class extends k2 {
    constructor(t5, e8 = {}) {
      super(t5, t5, e8);
      const n8 = { width: t5, height: t5, depth: 1 }, i6 = [n8, n8, n8, n8, n8, n8];
      this.texture = new qe(i6, e8.mapping, e8.wrapS, e8.wrapT, e8.magFilter, e8.minFilter, e8.format, e8.type, e8.anisotropy, e8.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e8.generateMipmaps !== void 0 && e8.generateMipmaps, this.texture.minFilter = e8.minFilter !== void 0 ? e8.minFilter : 1006;
    }
    fromEquirectangularTexture(t5, e8) {
      this.texture.type = e8.type, this.texture.encoding = e8.encoding, this.texture.generateMipmaps = e8.generateMipmaps, this.texture.minFilter = e8.minFilter, this.texture.magFilter = e8.magFilter;
      const n8 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i6 = new ke(5, 5, 5), r5 = new Ve({ name: "CubemapFromEquirect", uniforms: Be(n8.uniforms), vertexShader: n8.vertexShader, fragmentShader: n8.fragmentShader, side: 1, blending: 0 });
      r5.uniforms.tEquirect.value = e8;
      const s6 = new Fe(i6, r5), a4 = e8.minFilter;
      e8.minFilter === 1008 && (e8.minFilter = 1006);
      return new je(1, 10, this).update(t5, s6), e8.minFilter = a4, s6.geometry.dispose(), s6.material.dispose(), this;
    }
    clear(t5, e8, n8, i6) {
      const r5 = t5.getRenderTarget();
      for (let r6 = 0; r6 < 6; r6++)
        t5.setRenderTarget(this, r6), t5.clear(e8, n8, i6);
      t5.setRenderTarget(r5);
    }
  };
  Xe.prototype.isWebGLCubeRenderTarget = true;
  var $e = new V2();
  var Ye = new V2();
  var Je = new v2();
  var Ke = class {
    constructor(t5 = new V2(1, 0, 0), e8 = 0) {
      this.normal = t5, this.constant = e8;
    }
    set(t5, e8) {
      return this.normal.copy(t5), this.constant = e8, this;
    }
    setComponents(t5, e8, n8, i6) {
      return this.normal.set(t5, e8, n8), this.constant = i6, this;
    }
    setFromNormalAndCoplanarPoint(t5, e8) {
      return this.normal.copy(t5), this.constant = -e8.dot(this.normal), this;
    }
    setFromCoplanarPoints(t5, e8, n8) {
      const i6 = $e.subVectors(n8, e8).cross(Ye.subVectors(t5, e8)).normalize();
      return this.setFromNormalAndCoplanarPoint(i6, t5), this;
    }
    copy(t5) {
      return this.normal.copy(t5.normal), this.constant = t5.constant, this;
    }
    normalize() {
      const t5 = 1 / this.normal.length();
      return this.normal.multiplyScalar(t5), this.constant *= t5, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t5) {
      return this.normal.dot(t5) + this.constant;
    }
    distanceToSphere(t5) {
      return this.distanceToPoint(t5.center) - t5.radius;
    }
    projectPoint(t5, e8) {
      return e8.copy(this.normal).multiplyScalar(-this.distanceToPoint(t5)).add(t5);
    }
    intersectLine(t5, e8) {
      const n8 = t5.delta($e), i6 = this.normal.dot(n8);
      if (i6 === 0)
        return this.distanceToPoint(t5.start) === 0 ? e8.copy(t5.start) : null;
      const r5 = -(t5.start.dot(this.normal) + this.constant) / i6;
      return r5 < 0 || r5 > 1 ? null : e8.copy(n8).multiplyScalar(r5).add(t5.start);
    }
    intersectsLine(t5) {
      const e8 = this.distanceToPoint(t5.start), n8 = this.distanceToPoint(t5.end);
      return e8 < 0 && n8 > 0 || n8 < 0 && e8 > 0;
    }
    intersectsBox(t5) {
      return t5.intersectsPlane(this);
    }
    intersectsSphere(t5) {
      return t5.intersectsPlane(this);
    }
    coplanarPoint(t5) {
      return t5.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t5, e8) {
      const n8 = e8 || Je.getNormalMatrix(t5), i6 = this.coplanarPoint($e).applyMatrix4(t5), r5 = this.normal.applyMatrix3(n8).normalize();
      return this.constant = -i6.dot(r5), this;
    }
    translate(t5) {
      return this.constant -= t5.dot(this.normal), this;
    }
    equals(t5) {
      return t5.normal.equals(this.normal) && t5.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Ke.prototype.isPlane = true;
  var Ze = new ct();
  var Qe = new V2();
  var tn = class {
    constructor(t5 = new Ke(), e8 = new Ke(), n8 = new Ke(), i6 = new Ke(), r5 = new Ke(), s6 = new Ke()) {
      this.planes = [t5, e8, n8, i6, r5, s6];
    }
    set(t5, e8, n8, i6, r5, s6) {
      const a4 = this.planes;
      return a4[0].copy(t5), a4[1].copy(e8), a4[2].copy(n8), a4[3].copy(i6), a4[4].copy(r5), a4[5].copy(s6), this;
    }
    copy(t5) {
      const e8 = this.planes;
      for (let n8 = 0; n8 < 6; n8++)
        e8[n8].copy(t5.planes[n8]);
      return this;
    }
    setFromProjectionMatrix(t5) {
      const e8 = this.planes, n8 = t5.elements, i6 = n8[0], r5 = n8[1], s6 = n8[2], a4 = n8[3], o7 = n8[4], l6 = n8[5], h4 = n8[6], c3 = n8[7], u3 = n8[8], d3 = n8[9], p3 = n8[10], m3 = n8[11], f3 = n8[12], g3 = n8[13], v3 = n8[14], y3 = n8[15];
      return e8[0].setComponents(a4 - i6, c3 - o7, m3 - u3, y3 - f3).normalize(), e8[1].setComponents(a4 + i6, c3 + o7, m3 + u3, y3 + f3).normalize(), e8[2].setComponents(a4 + r5, c3 + l6, m3 + d3, y3 + g3).normalize(), e8[3].setComponents(a4 - r5, c3 - l6, m3 - d3, y3 - g3).normalize(), e8[4].setComponents(a4 - s6, c3 - h4, m3 - p3, y3 - v3).normalize(), e8[5].setComponents(a4 + s6, c3 + h4, m3 + p3, y3 + v3).normalize(), this;
    }
    intersectsObject(t5) {
      const e8 = t5.geometry;
      return e8.boundingSphere === null && e8.computeBoundingSphere(), Ze.copy(e8.boundingSphere).applyMatrix4(t5.matrixWorld), this.intersectsSphere(Ze);
    }
    intersectsSprite(t5) {
      return Ze.center.set(0, 0, 0), Ze.radius = 0.7071067811865476, Ze.applyMatrix4(t5.matrixWorld), this.intersectsSphere(Ze);
    }
    intersectsSphere(t5) {
      const e8 = this.planes, n8 = t5.center, i6 = -t5.radius;
      for (let t6 = 0; t6 < 6; t6++) {
        if (e8[t6].distanceToPoint(n8) < i6)
          return false;
      }
      return true;
    }
    intersectsBox(t5) {
      const e8 = this.planes;
      for (let n8 = 0; n8 < 6; n8++) {
        const i6 = e8[n8];
        if (Qe.x = i6.normal.x > 0 ? t5.max.x : t5.min.x, Qe.y = i6.normal.y > 0 ? t5.max.y : t5.min.y, Qe.z = i6.normal.z > 0 ? t5.max.z : t5.min.z, i6.distanceToPoint(Qe) < 0)
          return false;
      }
      return true;
    }
    containsPoint(t5) {
      const e8 = this.planes;
      for (let n8 = 0; n8 < 6; n8++)
        if (e8[n8].distanceToPoint(t5) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function en() {
    let t5 = null, e8 = false, n8 = null, i6 = null;
    function r5(e9, s6) {
      n8(e9, s6), i6 = t5.requestAnimationFrame(r5);
    }
    return { start: function() {
      e8 !== true && n8 !== null && (i6 = t5.requestAnimationFrame(r5), e8 = true);
    }, stop: function() {
      t5.cancelAnimationFrame(i6), e8 = false;
    }, setAnimationLoop: function(t6) {
      n8 = t6;
    }, setContext: function(e9) {
      t5 = e9;
    } };
  }
  function nn(t5, e8) {
    const n8 = e8.isWebGL2, i6 = /* @__PURE__ */ new WeakMap();
    return { get: function(t6) {
      return t6.isInterleavedBufferAttribute && (t6 = t6.data), i6.get(t6);
    }, remove: function(e9) {
      e9.isInterleavedBufferAttribute && (e9 = e9.data);
      const n9 = i6.get(e9);
      n9 && (t5.deleteBuffer(n9.buffer), i6.delete(e9));
    }, update: function(e9, r5) {
      if (e9.isGLBufferAttribute) {
        const t6 = i6.get(e9);
        return void ((!t6 || t6.version < e9.version) && i6.set(e9, { buffer: e9.buffer, type: e9.type, bytesPerElement: e9.elementSize, version: e9.version }));
      }
      e9.isInterleavedBufferAttribute && (e9 = e9.data);
      const s6 = i6.get(e9);
      s6 === void 0 ? i6.set(e9, function(e10, i7) {
        const r6 = e10.array, s7 = e10.usage, a4 = t5.createBuffer();
        let o7;
        if (t5.bindBuffer(i7, a4), t5.bufferData(i7, r6, s7), e10.onUploadCallback(), r6 instanceof Float32Array)
          o7 = 5126;
        else if (r6 instanceof Uint16Array)
          if (e10.isFloat16BufferAttribute) {
            if (!n8)
              throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            o7 = 5131;
          } else
            o7 = 5123;
        else if (r6 instanceof Int16Array)
          o7 = 5122;
        else if (r6 instanceof Uint32Array)
          o7 = 5125;
        else if (r6 instanceof Int32Array)
          o7 = 5124;
        else if (r6 instanceof Int8Array)
          o7 = 5120;
        else if (r6 instanceof Uint8Array)
          o7 = 5121;
        else {
          if (!(r6 instanceof Uint8ClampedArray))
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r6);
          o7 = 5121;
        }
        return { buffer: a4, type: o7, bytesPerElement: r6.BYTES_PER_ELEMENT, version: e10.version };
      }(e9, r5)) : s6.version < e9.version && (!function(e10, i7, r6) {
        const s7 = i7.array, a4 = i7.updateRange;
        t5.bindBuffer(r6, e10), a4.count === -1 ? t5.bufferSubData(r6, 0, s7) : (n8 ? t5.bufferSubData(r6, a4.offset * s7.BYTES_PER_ELEMENT, s7, a4.offset, a4.count) : t5.bufferSubData(r6, a4.offset * s7.BYTES_PER_ELEMENT, s7.subarray(a4.offset, a4.offset + a4.count)), a4.count = -1);
      }(s6.buffer, e9, r5), s6.version = e9.version);
    } };
  }
  var rn = class extends ye {
    constructor(t5 = 1, e8 = 1, n8 = 1, i6 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: t5, height: e8, widthSegments: n8, heightSegments: i6 };
      const r5 = t5 / 2, s6 = e8 / 2, a4 = Math.floor(n8), o7 = Math.floor(i6), l6 = a4 + 1, h4 = o7 + 1, c3 = t5 / a4, u3 = e8 / o7, d3 = [], p3 = [], m3 = [], f3 = [];
      for (let t6 = 0; t6 < h4; t6++) {
        const e9 = t6 * u3 - s6;
        for (let n9 = 0; n9 < l6; n9++) {
          const i7 = n9 * c3 - r5;
          p3.push(i7, -e9, 0), m3.push(0, 0, 1), f3.push(n9 / a4), f3.push(1 - t6 / o7);
        }
      }
      for (let t6 = 0; t6 < o7; t6++)
        for (let e9 = 0; e9 < a4; e9++) {
          const n9 = e9 + l6 * t6, i7 = e9 + l6 * (t6 + 1), r6 = e9 + 1 + l6 * (t6 + 1), s7 = e9 + 1 + l6 * t6;
          d3.push(n9, i7, s7), d3.push(i7, r6, s7);
        }
      this.setIndex(d3), this.setAttribute("position", new ce(p3, 3)), this.setAttribute("normal", new ce(m3, 3)), this.setAttribute("uv", new ce(f3, 2));
    }
    static fromJSON(t5) {
      return new rn(t5.width, t5.height, t5.widthSegments, t5.heightSegments);
    }
  };
  var sn = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" };
  var an = { common: { diffuse: { value: new L2(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new v2() }, uv2Transform: { value: new v2() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new g2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new L2(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new L2(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new v2() } }, sprite: { diffuse: { value: new L2(16777215) }, opacity: { value: 1 }, center: { value: new g2(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new v2() } } };
  var on = { basic: { uniforms: ze([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.fog]), vertexShader: sn.meshbasic_vert, fragmentShader: sn.meshbasic_frag }, lambert: { uniforms: ze([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.fog, an.lights, { emissive: { value: new L2(0) } }]), vertexShader: sn.meshlambert_vert, fragmentShader: sn.meshlambert_frag }, phong: { uniforms: ze([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.fog, an.lights, { emissive: { value: new L2(0) }, specular: { value: new L2(1118481) }, shininess: { value: 30 } }]), vertexShader: sn.meshphong_vert, fragmentShader: sn.meshphong_frag }, standard: { uniforms: ze([an.common, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.roughnessmap, an.metalnessmap, an.fog, an.lights, { emissive: { value: new L2(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: sn.meshphysical_vert, fragmentShader: sn.meshphysical_frag }, toon: { uniforms: ze([an.common, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.gradientmap, an.fog, an.lights, { emissive: { value: new L2(0) } }]), vertexShader: sn.meshtoon_vert, fragmentShader: sn.meshtoon_frag }, matcap: { uniforms: ze([an.common, an.bumpmap, an.normalmap, an.displacementmap, an.fog, { matcap: { value: null } }]), vertexShader: sn.meshmatcap_vert, fragmentShader: sn.meshmatcap_frag }, points: { uniforms: ze([an.points, an.fog]), vertexShader: sn.points_vert, fragmentShader: sn.points_frag }, dashed: { uniforms: ze([an.common, an.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: sn.linedashed_vert, fragmentShader: sn.linedashed_frag }, depth: { uniforms: ze([an.common, an.displacementmap]), vertexShader: sn.depth_vert, fragmentShader: sn.depth_frag }, normal: { uniforms: ze([an.common, an.bumpmap, an.normalmap, an.displacementmap, { opacity: { value: 1 } }]), vertexShader: sn.meshnormal_vert, fragmentShader: sn.meshnormal_frag }, sprite: { uniforms: ze([an.sprite, an.fog]), vertexShader: sn.sprite_vert, fragmentShader: sn.sprite_frag }, background: { uniforms: { uvTransform: { value: new v2() }, t2D: { value: null } }, vertexShader: sn.background_vert, fragmentShader: sn.background_frag }, cube: { uniforms: ze([an.envmap, { opacity: { value: 1 } }]), vertexShader: sn.cube_vert, fragmentShader: sn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: sn.equirect_vert, fragmentShader: sn.equirect_frag }, distanceRGBA: { uniforms: ze([an.common, an.displacementmap, { referencePosition: { value: new V2() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: sn.distanceRGBA_vert, fragmentShader: sn.distanceRGBA_frag }, shadow: { uniforms: ze([an.lights, an.fog, { color: { value: new L2(0) }, opacity: { value: 1 } }]), vertexShader: sn.shadow_vert, fragmentShader: sn.shadow_frag } };
  function ln(t5, e8, n8, i6, r5, s6) {
    const a4 = new L2(0);
    let o7, l6, h4 = r5 === true ? 0 : 1, c3 = null, u3 = 0, d3 = null;
    function p3(t6, e9) {
      n8.buffers.color.setClear(t6.r, t6.g, t6.b, e9, s6);
    }
    return { getClearColor: function() {
      return a4;
    }, setClearColor: function(t6, e9 = 1) {
      a4.set(t6), h4 = e9, p3(a4, h4);
    }, getClearAlpha: function() {
      return h4;
    }, setClearAlpha: function(t6) {
      h4 = t6, p3(a4, h4);
    }, render: function(n9, r6) {
      let s7 = false, m3 = r6.isScene === true ? r6.background : null;
      m3 && m3.isTexture && (m3 = e8.get(m3));
      const f3 = t5.xr, g3 = f3.getSession && f3.getSession();
      g3 && g3.environmentBlendMode === "additive" && (m3 = null), m3 === null ? p3(a4, h4) : m3 && m3.isColor && (p3(m3, 1), s7 = true), (t5.autoClear || s7) && t5.clear(t5.autoClearColor, t5.autoClearDepth, t5.autoClearStencil), m3 && (m3.isCubeTexture || m3.mapping === 306) ? (l6 === void 0 && (l6 = new Fe(new ke(1, 1, 1), new Ve({ name: "BackgroundCubeMaterial", uniforms: Be(on.cube.uniforms), vertexShader: on.cube.vertexShader, fragmentShader: on.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), l6.geometry.deleteAttribute("normal"), l6.geometry.deleteAttribute("uv"), l6.onBeforeRender = function(t6, e9, n10) {
        this.matrixWorld.copyPosition(n10.matrixWorld);
      }, Object.defineProperty(l6.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), i6.update(l6)), l6.material.uniforms.envMap.value = m3, l6.material.uniforms.flipEnvMap.value = m3.isCubeTexture && m3.isRenderTargetTexture === false ? -1 : 1, c3 === m3 && u3 === m3.version && d3 === t5.toneMapping || (l6.material.needsUpdate = true, c3 = m3, u3 = m3.version, d3 = t5.toneMapping), n9.unshift(l6, l6.geometry, l6.material, 0, 0, null)) : m3 && m3.isTexture && (o7 === void 0 && (o7 = new Fe(new rn(2, 2), new Ve({ name: "BackgroundMaterial", uniforms: Be(on.background.uniforms), vertexShader: on.background.vertexShader, fragmentShader: on.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), o7.geometry.deleteAttribute("normal"), Object.defineProperty(o7.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), i6.update(o7)), o7.material.uniforms.t2D.value = m3, m3.matrixAutoUpdate === true && m3.updateMatrix(), o7.material.uniforms.uvTransform.value.copy(m3.matrix), c3 === m3 && u3 === m3.version && d3 === t5.toneMapping || (o7.material.needsUpdate = true, c3 = m3, u3 = m3.version, d3 = t5.toneMapping), n9.unshift(o7, o7.geometry, o7.material, 0, 0, null));
    } };
  }
  function hn(t5, e8, n8, i6) {
    const r5 = t5.getParameter(34921), s6 = i6.isWebGL2 ? null : e8.get("OES_vertex_array_object"), a4 = i6.isWebGL2 || s6 !== null, o7 = {}, l6 = p3(null);
    let h4 = l6, c3 = false;
    function u3(e9) {
      return i6.isWebGL2 ? t5.bindVertexArray(e9) : s6.bindVertexArrayOES(e9);
    }
    function d3(e9) {
      return i6.isWebGL2 ? t5.deleteVertexArray(e9) : s6.deleteVertexArrayOES(e9);
    }
    function p3(t6) {
      const e9 = [], n9 = [], i7 = [];
      for (let t7 = 0; t7 < r5; t7++)
        e9[t7] = 0, n9[t7] = 0, i7[t7] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: e9, enabledAttributes: n9, attributeDivisors: i7, object: t6, attributes: {}, index: null };
    }
    function m3() {
      const t6 = h4.newAttributes;
      for (let e9 = 0, n9 = t6.length; e9 < n9; e9++)
        t6[e9] = 0;
    }
    function f3(t6) {
      g3(t6, 0);
    }
    function g3(n9, r6) {
      const s7 = h4.newAttributes, a5 = h4.enabledAttributes, o8 = h4.attributeDivisors;
      if (s7[n9] = 1, a5[n9] === 0 && (t5.enableVertexAttribArray(n9), a5[n9] = 1), o8[n9] !== r6) {
        (i6.isWebGL2 ? t5 : e8.get("ANGLE_instanced_arrays"))[i6.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n9, r6), o8[n9] = r6;
      }
    }
    function v3() {
      const e9 = h4.newAttributes, n9 = h4.enabledAttributes;
      for (let i7 = 0, r6 = n9.length; i7 < r6; i7++)
        n9[i7] !== e9[i7] && (t5.disableVertexAttribArray(i7), n9[i7] = 0);
    }
    function y3(e9, n9, r6, s7, a5, o8) {
      i6.isWebGL2 !== true || r6 !== 5124 && r6 !== 5125 ? t5.vertexAttribPointer(e9, n9, r6, s7, a5, o8) : t5.vertexAttribIPointer(e9, n9, r6, a5, o8);
    }
    function x3() {
      b3(), c3 = true, h4 !== l6 && (h4 = l6, u3(h4.object));
    }
    function b3() {
      l6.geometry = null, l6.program = null, l6.wireframe = false;
    }
    return { setup: function(r6, l7, d4, x4, b4) {
      let _3 = false;
      if (a4) {
        const e9 = function(e10, n9, r7) {
          const a5 = r7.wireframe === true;
          let l8 = o7[e10.id];
          l8 === void 0 && (l8 = {}, o7[e10.id] = l8);
          let h5 = l8[n9.id];
          h5 === void 0 && (h5 = {}, l8[n9.id] = h5);
          let c4 = h5[a5];
          c4 === void 0 && (c4 = p3(i6.isWebGL2 ? t5.createVertexArray() : s6.createVertexArrayOES()), h5[a5] = c4);
          return c4;
        }(x4, d4, l7);
        h4 !== e9 && (h4 = e9, u3(h4.object)), _3 = function(t6, e10) {
          const n9 = h4.attributes, i7 = t6.attributes;
          let r7 = 0;
          for (const t7 in i7) {
            const e11 = n9[t7], s7 = i7[t7];
            if (e11 === void 0)
              return true;
            if (e11.attribute !== s7)
              return true;
            if (e11.data !== s7.data)
              return true;
            r7++;
          }
          return h4.attributesNum !== r7 || h4.index !== e10;
        }(x4, b4), _3 && function(t6, e10) {
          const n9 = {}, i7 = t6.attributes;
          let r7 = 0;
          for (const t7 in i7) {
            const e11 = i7[t7], s7 = {};
            s7.attribute = e11, e11.data && (s7.data = e11.data), n9[t7] = s7, r7++;
          }
          h4.attributes = n9, h4.attributesNum = r7, h4.index = e10;
        }(x4, b4);
      } else {
        const t6 = l7.wireframe === true;
        h4.geometry === x4.id && h4.program === d4.id && h4.wireframe === t6 || (h4.geometry = x4.id, h4.program = d4.id, h4.wireframe = t6, _3 = true);
      }
      r6.isInstancedMesh === true && (_3 = true), b4 !== null && n8.update(b4, 34963), (_3 || c3) && (c3 = false, function(r7, s7, a5, o8) {
        if (i6.isWebGL2 === false && (r7.isInstancedMesh || o8.isInstancedBufferGeometry) && e8.get("ANGLE_instanced_arrays") === null)
          return;
        m3();
        const l8 = o8.attributes, h5 = a5.getAttributes(), c4 = s7.defaultAttributeValues;
        for (const e9 in h5) {
          const i7 = h5[e9];
          if (i7.location >= 0) {
            let s8 = l8[e9];
            if (s8 === void 0 && (e9 === "instanceMatrix" && r7.instanceMatrix && (s8 = r7.instanceMatrix), e9 === "instanceColor" && r7.instanceColor && (s8 = r7.instanceColor)), s8 !== void 0) {
              const e10 = s8.normalized, a6 = s8.itemSize, l9 = n8.get(s8);
              if (l9 === void 0)
                continue;
              const h6 = l9.buffer, c5 = l9.type, u4 = l9.bytesPerElement;
              if (s8.isInterleavedBufferAttribute) {
                const n9 = s8.data, l10 = n9.stride, d5 = s8.offset;
                if (n9.isInstancedInterleavedBuffer) {
                  for (let t6 = 0; t6 < i7.locationSize; t6++)
                    g3(i7.location + t6, n9.meshPerAttribute);
                  r7.isInstancedMesh !== true && o8._maxInstanceCount === void 0 && (o8._maxInstanceCount = n9.meshPerAttribute * n9.count);
                } else
                  for (let t6 = 0; t6 < i7.locationSize; t6++)
                    f3(i7.location + t6);
                t5.bindBuffer(34962, h6);
                for (let t6 = 0; t6 < i7.locationSize; t6++)
                  y3(i7.location + t6, a6 / i7.locationSize, c5, e10, l10 * u4, (d5 + a6 / i7.locationSize * t6) * u4);
              } else {
                if (s8.isInstancedBufferAttribute) {
                  for (let t6 = 0; t6 < i7.locationSize; t6++)
                    g3(i7.location + t6, s8.meshPerAttribute);
                  r7.isInstancedMesh !== true && o8._maxInstanceCount === void 0 && (o8._maxInstanceCount = s8.meshPerAttribute * s8.count);
                } else
                  for (let t6 = 0; t6 < i7.locationSize; t6++)
                    f3(i7.location + t6);
                t5.bindBuffer(34962, h6);
                for (let t6 = 0; t6 < i7.locationSize; t6++)
                  y3(i7.location + t6, a6 / i7.locationSize, c5, e10, a6 * u4, a6 / i7.locationSize * t6 * u4);
              }
            } else if (c4 !== void 0) {
              const n9 = c4[e9];
              if (n9 !== void 0)
                switch (n9.length) {
                  case 2:
                    t5.vertexAttrib2fv(i7.location, n9);
                    break;
                  case 3:
                    t5.vertexAttrib3fv(i7.location, n9);
                    break;
                  case 4:
                    t5.vertexAttrib4fv(i7.location, n9);
                    break;
                  default:
                    t5.vertexAttrib1fv(i7.location, n9);
                }
            }
          }
        }
        v3();
      }(r6, l7, d4, x4), b4 !== null && t5.bindBuffer(34963, n8.get(b4).buffer));
    }, reset: x3, resetDefaultState: b3, dispose: function() {
      x3();
      for (const t6 in o7) {
        const e9 = o7[t6];
        for (const t7 in e9) {
          const n9 = e9[t7];
          for (const t8 in n9)
            d3(n9[t8].object), delete n9[t8];
          delete e9[t7];
        }
        delete o7[t6];
      }
    }, releaseStatesOfGeometry: function(t6) {
      if (o7[t6.id] === void 0)
        return;
      const e9 = o7[t6.id];
      for (const t7 in e9) {
        const n9 = e9[t7];
        for (const t8 in n9)
          d3(n9[t8].object), delete n9[t8];
        delete e9[t7];
      }
      delete o7[t6.id];
    }, releaseStatesOfProgram: function(t6) {
      for (const e9 in o7) {
        const n9 = o7[e9];
        if (n9[t6.id] === void 0)
          continue;
        const i7 = n9[t6.id];
        for (const t7 in i7)
          d3(i7[t7].object), delete i7[t7];
        delete n9[t6.id];
      }
    }, initAttributes: m3, enableAttribute: f3, disableUnusedAttributes: v3 };
  }
  function cn(t5, e8, n8, i6) {
    const r5 = i6.isWebGL2;
    let s6;
    this.setMode = function(t6) {
      s6 = t6;
    }, this.render = function(e9, i7) {
      t5.drawArrays(s6, e9, i7), n8.update(i7, s6, 1);
    }, this.renderInstances = function(i7, a4, o7) {
      if (o7 === 0)
        return;
      let l6, h4;
      if (r5)
        l6 = t5, h4 = "drawArraysInstanced";
      else if (l6 = e8.get("ANGLE_instanced_arrays"), h4 = "drawArraysInstancedANGLE", l6 === null)
        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      l6[h4](s6, i7, a4, o7), n8.update(a4, s6, o7);
    };
  }
  function un(t5, e8, n8) {
    let i6;
    function r5(e9) {
      if (e9 === "highp") {
        if (t5.getShaderPrecisionFormat(35633, 36338).precision > 0 && t5.getShaderPrecisionFormat(35632, 36338).precision > 0)
          return "highp";
        e9 = "mediump";
      }
      return e9 === "mediump" && t5.getShaderPrecisionFormat(35633, 36337).precision > 0 && t5.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const s6 = typeof WebGL2RenderingContext != "undefined" && t5 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && t5 instanceof WebGL2ComputeRenderingContext;
    let a4 = n8.precision !== void 0 ? n8.precision : "highp";
    const o7 = r5(a4);
    o7 !== a4 && (console.warn("THREE.WebGLRenderer:", a4, "not supported, using", o7, "instead."), a4 = o7);
    const l6 = s6 || e8.has("WEBGL_draw_buffers"), h4 = n8.logarithmicDepthBuffer === true, c3 = t5.getParameter(34930), u3 = t5.getParameter(35660), d3 = t5.getParameter(3379), p3 = t5.getParameter(34076), m3 = t5.getParameter(34921), f3 = t5.getParameter(36347), g3 = t5.getParameter(36348), v3 = t5.getParameter(36349), y3 = u3 > 0, x3 = s6 || e8.has("OES_texture_float");
    return { isWebGL2: s6, drawBuffers: l6, getMaxAnisotropy: function() {
      if (i6 !== void 0)
        return i6;
      if (e8.has("EXT_texture_filter_anisotropic") === true) {
        const n9 = e8.get("EXT_texture_filter_anisotropic");
        i6 = t5.getParameter(n9.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else
        i6 = 0;
      return i6;
    }, getMaxPrecision: r5, precision: a4, logarithmicDepthBuffer: h4, maxTextures: c3, maxVertexTextures: u3, maxTextureSize: d3, maxCubemapSize: p3, maxAttributes: m3, maxVertexUniforms: f3, maxVaryings: g3, maxFragmentUniforms: v3, vertexTextures: y3, floatFragmentTextures: x3, floatVertexTextures: y3 && x3, maxSamples: s6 ? t5.getParameter(36183) : 0 };
  }
  function dn(t5) {
    const e8 = this;
    let n8 = null, i6 = 0, r5 = false, s6 = false;
    const a4 = new Ke(), o7 = new v2(), l6 = { value: null, needsUpdate: false };
    function h4() {
      l6.value !== n8 && (l6.value = n8, l6.needsUpdate = i6 > 0), e8.numPlanes = i6, e8.numIntersection = 0;
    }
    function c3(t6, n9, i7, r6) {
      const s7 = t6 !== null ? t6.length : 0;
      let h5 = null;
      if (s7 !== 0) {
        if (h5 = l6.value, r6 !== true || h5 === null) {
          const e9 = i7 + 4 * s7, r7 = n9.matrixWorldInverse;
          o7.getNormalMatrix(r7), (h5 === null || h5.length < e9) && (h5 = new Float32Array(e9));
          for (let e10 = 0, n10 = i7; e10 !== s7; ++e10, n10 += 4)
            a4.copy(t6[e10]).applyMatrix4(r7, o7), a4.normal.toArray(h5, n10), h5[n10 + 3] = a4.constant;
        }
        l6.value = h5, l6.needsUpdate = true;
      }
      return e8.numPlanes = s7, e8.numIntersection = 0, h5;
    }
    this.uniform = l6, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t6, e9, s7) {
      const a5 = t6.length !== 0 || e9 || i6 !== 0 || r5;
      return r5 = e9, n8 = c3(t6, s7, 0), i6 = t6.length, a5;
    }, this.beginShadows = function() {
      s6 = true, c3(null);
    }, this.endShadows = function() {
      s6 = false, h4();
    }, this.setState = function(e9, a5, o8) {
      const u3 = e9.clippingPlanes, d3 = e9.clipIntersection, p3 = e9.clipShadows, m3 = t5.get(e9);
      if (!r5 || u3 === null || u3.length === 0 || s6 && !p3)
        s6 ? c3(null) : h4();
      else {
        const t6 = s6 ? 0 : i6, e10 = 4 * t6;
        let r6 = m3.clippingState || null;
        l6.value = r6, r6 = c3(u3, a5, e10, o8);
        for (let t7 = 0; t7 !== e10; ++t7)
          r6[t7] = n8[t7];
        m3.clippingState = r6, this.numIntersection = d3 ? this.numPlanes : 0, this.numPlanes += t6;
      }
    };
  }
  function pn(t5) {
    let e8 = /* @__PURE__ */ new WeakMap();
    function n8(t6, e9) {
      return e9 === 303 ? t6.mapping = 301 : e9 === 304 && (t6.mapping = 302), t6;
    }
    function i6(t6) {
      const n9 = t6.target;
      n9.removeEventListener("dispose", i6);
      const r5 = e8.get(n9);
      r5 !== void 0 && (e8.delete(n9), r5.dispose());
    }
    return { get: function(r5) {
      if (r5 && r5.isTexture && r5.isRenderTargetTexture === false) {
        const s6 = r5.mapping;
        if (s6 === 303 || s6 === 304) {
          if (e8.has(r5)) {
            return n8(e8.get(r5).texture, r5.mapping);
          }
          {
            const s7 = r5.image;
            if (s7 && s7.height > 0) {
              const a4 = new Xe(s7.height / 2);
              return a4.fromEquirectangularTexture(t5, r5), e8.set(r5, a4), r5.addEventListener("dispose", i6), n8(a4.texture, r5.mapping);
            }
            return null;
          }
        }
      }
      return r5;
    }, dispose: function() {
      e8 = /* @__PURE__ */ new WeakMap();
    } };
  }
  on.physical = { uniforms: ze([on.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new g2(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new L2(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new g2() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new L2(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new L2(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: sn.meshphysical_vert, fragmentShader: sn.meshphysical_frag };
  var mn = class extends Ge {
    constructor(t5 = -1, e8 = 1, n8 = 1, i6 = -1, r5 = 0.1, s6 = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t5, this.right = e8, this.top = n8, this.bottom = i6, this.near = r5, this.far = s6, this.updateProjectionMatrix();
    }
    copy(t5, e8) {
      return super.copy(t5, e8), this.left = t5.left, this.right = t5.right, this.top = t5.top, this.bottom = t5.bottom, this.near = t5.near, this.far = t5.far, this.zoom = t5.zoom, this.view = t5.view === null ? null : Object.assign({}, t5.view), this;
    }
    setViewOffset(t5, e8, n8, i6, r5, s6) {
      this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t5, this.view.fullHeight = e8, this.view.offsetX = n8, this.view.offsetY = i6, this.view.width = r5, this.view.height = s6, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t5 = (this.right - this.left) / (2 * this.zoom), e8 = (this.top - this.bottom) / (2 * this.zoom), n8 = (this.right + this.left) / 2, i6 = (this.top + this.bottom) / 2;
      let r5 = n8 - t5, s6 = n8 + t5, a4 = i6 + e8, o7 = i6 - e8;
      if (this.view !== null && this.view.enabled) {
        const t6 = (this.right - this.left) / this.view.fullWidth / this.zoom, e9 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r5 += t6 * this.view.offsetX, s6 = r5 + t6 * this.view.width, a4 -= e9 * this.view.offsetY, o7 = a4 - e9 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r5, s6, a4, o7, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.object.zoom = this.zoom, e8.object.left = this.left, e8.object.right = this.right, e8.object.top = this.top, e8.object.bottom = this.bottom, e8.object.near = this.near, e8.object.far = this.far, this.view !== null && (e8.object.view = Object.assign({}, this.view)), e8;
    }
  };
  mn.prototype.isOrthographicCamera = true;
  var fn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var gn = new mn();
  var vn = new L2();
  var yn = null;
  var xn = (1 + Math.sqrt(5)) / 2;
  var bn = 1 / xn;
  var _n = [new V2(1, 1, 1), new V2(-1, 1, 1), new V2(1, 1, -1), new V2(-1, 1, -1), new V2(0, xn, bn), new V2(0, xn, -bn), new V2(bn, 0, xn), new V2(-bn, 0, xn), new V2(xn, bn, 0), new V2(-xn, bn, 0)];
  var wn = class {
    constructor(t5) {
      this._renderer = t5, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(t5, e8 = 0, n8 = 0.1, i6 = 100) {
      yn = this._renderer.getRenderTarget(), this._setSize(256);
      const r5 = this._allocateTargets();
      return r5.depthBuffer = true, this._sceneToCubeUV(t5, n8, i6, r5), e8 > 0 && this._blur(r5, 0, 0, e8), this._applyPMREM(r5), this._cleanup(r5), r5;
    }
    fromEquirectangular(t5, e8 = null) {
      return this._fromTexture(t5, e8);
    }
    fromCubemap(t5, e8 = null) {
      return this._fromTexture(t5, e8);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = En(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = Tn(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(t5) {
      this._lodMax = Math.floor(Math.log2(t5)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let t5 = 0; t5 < this._lodPlanes.length; t5++)
        this._lodPlanes[t5].dispose();
    }
    _cleanup(t5) {
      this._renderer.setRenderTarget(yn), t5.scissorTest = false, Sn(t5, 0, 0, t5.width, t5.height);
    }
    _fromTexture(t5, e8) {
      t5.mapping === 301 || t5.mapping === 302 ? this._setSize(t5.image.length === 0 ? 16 : t5.image[0].width || t5.image[0].image.width) : this._setSize(t5.image.width / 4), yn = this._renderer.getRenderTarget();
      const n8 = e8 || this._allocateTargets();
      return this._textureToCubeUV(t5, n8), this._applyPMREM(n8), this._cleanup(n8), n8;
    }
    _allocateTargets() {
      const t5 = 3 * Math.max(this._cubeSize, 112), e8 = 4 * this._cubeSize - 32, n8 = { magFilter: 1006, minFilter: 1006, generateMipmaps: false, type: 1016, format: 1023, encoding: 3e3, depthBuffer: false }, i6 = Mn(t5, e8, n8);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t5) {
        this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Mn(t5, e8, n8);
        const { _lodMax: i7 } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(t6) {
          const e9 = [], n9 = [], i8 = [];
          let r5 = t6;
          const s6 = t6 - 4 + 1 + fn.length;
          for (let a4 = 0; a4 < s6; a4++) {
            const s7 = Math.pow(2, r5);
            n9.push(s7);
            let o7 = 1 / s7;
            a4 > t6 - 4 ? o7 = fn[a4 - t6 + 4 - 1] : a4 === 0 && (o7 = 0), i8.push(o7);
            const l6 = 1 / (s7 - 1), h4 = -l6 / 2, c3 = 1 + l6 / 2, u3 = [h4, h4, c3, h4, c3, c3, h4, h4, c3, c3, h4, c3], d3 = 6, p3 = 6, m3 = 3, f3 = 2, g3 = 1, v3 = new Float32Array(m3 * p3 * d3), y3 = new Float32Array(f3 * p3 * d3), x3 = new Float32Array(g3 * p3 * d3);
            for (let t7 = 0; t7 < d3; t7++) {
              const e10 = t7 % 3 * 2 / 3 - 1, n10 = t7 > 2 ? 0 : -1, i9 = [e10, n10, 0, e10 + 2 / 3, n10, 0, e10 + 2 / 3, n10 + 1, 0, e10, n10, 0, e10 + 2 / 3, n10 + 1, 0, e10, n10 + 1, 0];
              v3.set(i9, m3 * p3 * t7), y3.set(u3, f3 * p3 * t7);
              const r6 = [t7, t7, t7, t7, t7, t7];
              x3.set(r6, g3 * p3 * t7);
            }
            const b3 = new ye();
            b3.setAttribute("position", new oe(v3, m3)), b3.setAttribute("uv", new oe(y3, f3)), b3.setAttribute("faceIndex", new oe(x3, g3)), e9.push(b3), r5 > 4 && r5--;
          }
          return { lodPlanes: e9, sizeLods: n9, sigmas: i8 };
        }(i7)), this._blurMaterial = function(t6, e9, n9) {
          const i8 = new Float32Array(20), r5 = new V2(0, 1, 0);
          return new Ve({ name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / e9, CUBEUV_TEXEL_HEIGHT: 1 / n9, CUBEUV_MAX_MIP: `${t6}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i8 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r5 } }, vertexShader: An(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
        }(i7, t5, e8);
      }
      return i6;
    }
    _compileMaterial(t5) {
      const e8 = new Fe(this._lodPlanes[0], t5);
      this._renderer.compile(e8, gn);
    }
    _sceneToCubeUV(t5, e8, n8, i6) {
      const r5 = new We(90, 1, e8, n8), s6 = [1, -1, 1, 1, 1, 1], a4 = [1, 1, 1, -1, -1, -1], o7 = this._renderer, l6 = o7.autoClear, h4 = o7.toneMapping;
      o7.getClearColor(vn), o7.toneMapping = 0, o7.autoClear = false;
      const c3 = new re({ name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false }), u3 = new Fe(new ke(), c3);
      let d3 = false;
      const p3 = t5.background;
      p3 ? p3.isColor && (c3.color.copy(p3), t5.background = null, d3 = true) : (c3.color.copy(vn), d3 = true);
      for (let e9 = 0; e9 < 6; e9++) {
        const n9 = e9 % 3;
        n9 === 0 ? (r5.up.set(0, s6[e9], 0), r5.lookAt(a4[e9], 0, 0)) : n9 === 1 ? (r5.up.set(0, 0, s6[e9]), r5.lookAt(0, a4[e9], 0)) : (r5.up.set(0, s6[e9], 0), r5.lookAt(0, 0, a4[e9]));
        const l7 = this._cubeSize;
        Sn(i6, n9 * l7, e9 > 2 ? l7 : 0, l7, l7), o7.setRenderTarget(i6), d3 && o7.render(u3, r5), o7.render(t5, r5);
      }
      u3.geometry.dispose(), u3.material.dispose(), o7.toneMapping = h4, o7.autoClear = l6, t5.background = p3;
    }
    _textureToCubeUV(t5, e8) {
      const n8 = this._renderer, i6 = t5.mapping === 301 || t5.mapping === 302;
      i6 ? (this._cubemapMaterial === null && (this._cubemapMaterial = En()), this._cubemapMaterial.uniforms.flipEnvMap.value = t5.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Tn());
      const r5 = i6 ? this._cubemapMaterial : this._equirectMaterial, s6 = new Fe(this._lodPlanes[0], r5);
      r5.uniforms.envMap.value = t5;
      const a4 = this._cubeSize;
      Sn(e8, 0, 0, 3 * a4, 2 * a4), n8.setRenderTarget(e8), n8.render(s6, gn);
    }
    _applyPMREM(t5) {
      const e8 = this._renderer, n8 = e8.autoClear;
      e8.autoClear = false;
      for (let e9 = 1; e9 < this._lodPlanes.length; e9++) {
        const n9 = Math.sqrt(this._sigmas[e9] * this._sigmas[e9] - this._sigmas[e9 - 1] * this._sigmas[e9 - 1]), i6 = _n[(e9 - 1) % _n.length];
        this._blur(t5, e9 - 1, e9, n9, i6);
      }
      e8.autoClear = n8;
    }
    _blur(t5, e8, n8, i6, r5) {
      const s6 = this._pingPongRenderTarget;
      this._halfBlur(t5, s6, e8, n8, i6, "latitudinal", r5), this._halfBlur(s6, t5, n8, n8, i6, "longitudinal", r5);
    }
    _halfBlur(t5, e8, n8, i6, r5, s6, a4) {
      const o7 = this._renderer, l6 = this._blurMaterial;
      s6 !== "latitudinal" && s6 !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const h4 = new Fe(this._lodPlanes[i6], l6), c3 = l6.uniforms, u3 = this._sizeLods[n8] - 1, d3 = isFinite(r5) ? Math.PI / (2 * u3) : 2 * Math.PI / 39, p3 = r5 / d3, m3 = isFinite(r5) ? 1 + Math.floor(3 * p3) : 20;
      m3 > 20 && console.warn(`sigmaRadians, ${r5}, is too large and will clip, as it requested ${m3} samples when the maximum is set to 20`);
      const f3 = [];
      let g3 = 0;
      for (let t6 = 0; t6 < 20; ++t6) {
        const e9 = t6 / p3, n9 = Math.exp(-e9 * e9 / 2);
        f3.push(n9), t6 === 0 ? g3 += n9 : t6 < m3 && (g3 += 2 * n9);
      }
      for (let t6 = 0; t6 < f3.length; t6++)
        f3[t6] = f3[t6] / g3;
      c3.envMap.value = t5.texture, c3.samples.value = m3, c3.weights.value = f3, c3.latitudinal.value = s6 === "latitudinal", a4 && (c3.poleAxis.value = a4);
      const { _lodMax: v3 } = this;
      c3.dTheta.value = d3, c3.mipInt.value = v3 - n8;
      const y3 = this._sizeLods[i6];
      Sn(e8, 3 * y3 * (i6 > v3 - 4 ? i6 - v3 + 4 : 0), 4 * (this._cubeSize - y3), 3 * y3, 2 * y3), o7.setRenderTarget(e8), o7.render(h4, gn);
    }
  };
  function Mn(t5, e8, n8) {
    const i6 = new k2(t5, e8, n8);
    return i6.texture.mapping = 306, i6.texture.name = "PMREM.cubeUv", i6.scissorTest = true, i6;
  }
  function Sn(t5, e8, n8, i6, r5) {
    t5.viewport.set(e8, n8, i6, r5), t5.scissor.set(e8, n8, i6, r5);
  }
  function Tn() {
    return new Ve({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: An(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
  }
  function En() {
    return new Ve({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: An(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
  }
  function An() {
    return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
  }
  function Rn(t5) {
    let e8 = /* @__PURE__ */ new WeakMap(), n8 = null;
    function i6(t6) {
      const n9 = t6.target;
      n9.removeEventListener("dispose", i6);
      const r5 = e8.get(n9);
      r5 !== void 0 && (e8.delete(n9), r5.dispose());
    }
    return { get: function(r5) {
      if (r5 && r5.isTexture) {
        const s6 = r5.mapping, a4 = s6 === 303 || s6 === 304, o7 = s6 === 301 || s6 === 302;
        if (a4 || o7) {
          if (r5.isRenderTargetTexture && r5.needsPMREMUpdate === true) {
            r5.needsPMREMUpdate = false;
            let i7 = e8.get(r5);
            return n8 === null && (n8 = new wn(t5)), i7 = a4 ? n8.fromEquirectangular(r5, i7) : n8.fromCubemap(r5, i7), e8.set(r5, i7), i7.texture;
          }
          if (e8.has(r5))
            return e8.get(r5).texture;
          {
            const s7 = r5.image;
            if (a4 && s7 && s7.height > 0 || o7 && s7 && function(t6) {
              let e9 = 0;
              const n9 = 6;
              for (let i7 = 0; i7 < n9; i7++)
                t6[i7] !== void 0 && e9++;
              return e9 === n9;
            }(s7)) {
              n8 === null && (n8 = new wn(t5));
              const s8 = a4 ? n8.fromEquirectangular(r5) : n8.fromCubemap(r5);
              return e8.set(r5, s8), r5.addEventListener("dispose", i6), s8.texture;
            }
            return null;
          }
        }
      }
      return r5;
    }, dispose: function() {
      e8 = /* @__PURE__ */ new WeakMap(), n8 !== null && (n8.dispose(), n8 = null);
    } };
  }
  function Cn(t5) {
    const e8 = {};
    function n8(n9) {
      if (e8[n9] !== void 0)
        return e8[n9];
      let i6;
      switch (n9) {
        case "WEBGL_depth_texture":
          i6 = t5.getExtension("WEBGL_depth_texture") || t5.getExtension("MOZ_WEBGL_depth_texture") || t5.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i6 = t5.getExtension("EXT_texture_filter_anisotropic") || t5.getExtension("MOZ_EXT_texture_filter_anisotropic") || t5.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i6 = t5.getExtension("WEBGL_compressed_texture_s3tc") || t5.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t5.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i6 = t5.getExtension("WEBGL_compressed_texture_pvrtc") || t5.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i6 = t5.getExtension(n9);
      }
      return e8[n9] = i6, i6;
    }
    return { has: function(t6) {
      return n8(t6) !== null;
    }, init: function(t6) {
      t6.isWebGL2 ? n8("EXT_color_buffer_float") : (n8("WEBGL_depth_texture"), n8("OES_texture_float"), n8("OES_texture_half_float"), n8("OES_texture_half_float_linear"), n8("OES_standard_derivatives"), n8("OES_element_index_uint"), n8("OES_vertex_array_object"), n8("ANGLE_instanced_arrays")), n8("OES_texture_float_linear"), n8("EXT_color_buffer_half_float"), n8("WEBGL_multisampled_render_to_texture");
    }, get: function(t6) {
      const e9 = n8(t6);
      return e9 === null && console.warn("THREE.WebGLRenderer: " + t6 + " extension not supported."), e9;
    } };
  }
  function Ln(t5, e8, n8, i6) {
    const r5 = {}, s6 = /* @__PURE__ */ new WeakMap();
    function a4(t6) {
      const o8 = t6.target;
      o8.index !== null && e8.remove(o8.index);
      for (const t7 in o8.attributes)
        e8.remove(o8.attributes[t7]);
      o8.removeEventListener("dispose", a4), delete r5[o8.id];
      const l6 = s6.get(o8);
      l6 && (e8.remove(l6), s6.delete(o8)), i6.releaseStatesOfGeometry(o8), o8.isInstancedBufferGeometry === true && delete o8._maxInstanceCount, n8.memory.geometries--;
    }
    function o7(t6) {
      const n9 = [], i7 = t6.index, r6 = t6.attributes.position;
      let a5 = 0;
      if (i7 !== null) {
        const t7 = i7.array;
        a5 = i7.version;
        for (let e9 = 0, i8 = t7.length; e9 < i8; e9 += 3) {
          const i9 = t7[e9 + 0], r7 = t7[e9 + 1], s7 = t7[e9 + 2];
          n9.push(i9, r7, r7, s7, s7, i9);
        }
      } else {
        const t7 = r6.array;
        a5 = r6.version;
        for (let e9 = 0, i8 = t7.length / 3 - 1; e9 < i8; e9 += 3) {
          const t8 = e9 + 0, i9 = e9 + 1, r7 = e9 + 2;
          n9.push(t8, i9, i9, r7, r7, t8);
        }
      }
      const o8 = new (y2(n9) ? he : le)(n9, 1);
      o8.version = a5;
      const l6 = s6.get(t6);
      l6 && e8.remove(l6), s6.set(t6, o8);
    }
    return { get: function(t6, e9) {
      return r5[e9.id] === true || (e9.addEventListener("dispose", a4), r5[e9.id] = true, n8.memory.geometries++), e9;
    }, update: function(t6) {
      const n9 = t6.attributes;
      for (const t7 in n9)
        e8.update(n9[t7], 34962);
      const i7 = t6.morphAttributes;
      for (const t7 in i7) {
        const n10 = i7[t7];
        for (let t8 = 0, i8 = n10.length; t8 < i8; t8++)
          e8.update(n10[t8], 34962);
      }
    }, getWireframeAttribute: function(t6) {
      const e9 = s6.get(t6);
      if (e9) {
        const n9 = t6.index;
        n9 !== null && e9.version < n9.version && o7(t6);
      } else
        o7(t6);
      return s6.get(t6);
    } };
  }
  function Pn(t5, e8, n8, i6) {
    const r5 = i6.isWebGL2;
    let s6, a4, o7;
    this.setMode = function(t6) {
      s6 = t6;
    }, this.setIndex = function(t6) {
      a4 = t6.type, o7 = t6.bytesPerElement;
    }, this.render = function(e9, i7) {
      t5.drawElements(s6, i7, a4, e9 * o7), n8.update(i7, s6, 1);
    }, this.renderInstances = function(i7, l6, h4) {
      if (h4 === 0)
        return;
      let c3, u3;
      if (r5)
        c3 = t5, u3 = "drawElementsInstanced";
      else if (c3 = e8.get("ANGLE_instanced_arrays"), u3 = "drawElementsInstancedANGLE", c3 === null)
        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      c3[u3](s6, l6, a4, i7 * o7, h4), n8.update(l6, s6, h4);
    };
  }
  function Dn(t5) {
    const e8 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: e8, programs: null, autoReset: true, reset: function() {
      e8.frame++, e8.calls = 0, e8.triangles = 0, e8.points = 0, e8.lines = 0;
    }, update: function(t6, n8, i6) {
      switch (e8.calls++, n8) {
        case 4:
          e8.triangles += i6 * (t6 / 3);
          break;
        case 1:
          e8.lines += i6 * (t6 / 2);
          break;
        case 3:
          e8.lines += i6 * (t6 - 1);
          break;
        case 2:
          e8.lines += i6 * t6;
          break;
        case 0:
          e8.points += i6 * t6;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n8);
      }
    } };
  }
  function In(t5, e8) {
    return t5[0] - e8[0];
  }
  function On(t5, e8) {
    return Math.abs(e8[1]) - Math.abs(t5[1]);
  }
  function Nn(t5, e8) {
    let n8 = 1;
    const i6 = e8.isInterleavedBufferAttribute ? e8.data.array : e8.array;
    i6 instanceof Int8Array ? n8 = 127 : i6 instanceof Int16Array ? n8 = 32767 : i6 instanceof Int32Array ? n8 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i6), t5.divideScalar(n8);
  }
  function Fn(t5, e8, n8) {
    const i6 = {}, r5 = new Float32Array(8), s6 = /* @__PURE__ */ new WeakMap(), a4 = new U(), o7 = [];
    for (let t6 = 0; t6 < 8; t6++)
      o7[t6] = [t6, 0];
    return { update: function(l6, h4, c3, u3) {
      const d3 = l6.morphTargetInfluences;
      if (e8.isWebGL2 === true) {
        const i7 = h4.morphAttributes.position || h4.morphAttributes.normal || h4.morphAttributes.color, r6 = i7 !== void 0 ? i7.length : 0;
        let o8 = s6.get(h4);
        if (o8 === void 0 || o8.count !== r6) {
          o8 !== void 0 && o8.texture.dispose();
          const t6 = h4.morphAttributes.position !== void 0, n9 = h4.morphAttributes.normal !== void 0, i8 = h4.morphAttributes.color !== void 0, l8 = h4.morphAttributes.position || [], c5 = h4.morphAttributes.normal || [], u4 = h4.morphAttributes.color || [];
          let d4 = 0;
          t6 === true && (d4 = 1), n9 === true && (d4 = 2), i8 === true && (d4 = 3);
          let p3 = h4.attributes.position.count * d4, m3 = 1;
          p3 > e8.maxTextureSize && (m3 = Math.ceil(p3 / e8.maxTextureSize), p3 = e8.maxTextureSize);
          const f3 = new Float32Array(p3 * m3 * 4 * r6), v3 = new B(f3, p3, m3, r6);
          v3.type = 1015, v3.needsUpdate = true;
          const y3 = 4 * d4;
          for (let e9 = 0; e9 < r6; e9++) {
            const r7 = l8[e9], s7 = c5[e9], o9 = u4[e9], h5 = p3 * m3 * 4 * e9;
            for (let e10 = 0; e10 < r7.count; e10++) {
              const l9 = e10 * y3;
              t6 === true && (a4.fromBufferAttribute(r7, e10), r7.normalized === true && Nn(a4, r7), f3[h5 + l9 + 0] = a4.x, f3[h5 + l9 + 1] = a4.y, f3[h5 + l9 + 2] = a4.z, f3[h5 + l9 + 3] = 0), n9 === true && (a4.fromBufferAttribute(s7, e10), s7.normalized === true && Nn(a4, s7), f3[h5 + l9 + 4] = a4.x, f3[h5 + l9 + 5] = a4.y, f3[h5 + l9 + 6] = a4.z, f3[h5 + l9 + 7] = 0), i8 === true && (a4.fromBufferAttribute(o9, e10), o9.normalized === true && Nn(a4, o9), f3[h5 + l9 + 8] = a4.x, f3[h5 + l9 + 9] = a4.y, f3[h5 + l9 + 10] = a4.z, f3[h5 + l9 + 11] = o9.itemSize === 4 ? a4.w : 1);
            }
          }
          o8 = { count: r6, texture: v3, size: new g2(p3, m3) }, s6.set(h4, o8), h4.addEventListener("dispose", function t7() {
            v3.dispose(), s6.delete(h4), h4.removeEventListener("dispose", t7);
          });
        }
        let l7 = 0;
        for (let t6 = 0; t6 < d3.length; t6++)
          l7 += d3[t6];
        const c4 = h4.morphTargetsRelative ? 1 : 1 - l7;
        u3.getUniforms().setValue(t5, "morphTargetBaseInfluence", c4), u3.getUniforms().setValue(t5, "morphTargetInfluences", d3), u3.getUniforms().setValue(t5, "morphTargetsTexture", o8.texture, n8), u3.getUniforms().setValue(t5, "morphTargetsTextureSize", o8.size);
      } else {
        const e9 = d3 === void 0 ? 0 : d3.length;
        let n9 = i6[h4.id];
        if (n9 === void 0 || n9.length !== e9) {
          n9 = [];
          for (let t6 = 0; t6 < e9; t6++)
            n9[t6] = [t6, 0];
          i6[h4.id] = n9;
        }
        for (let t6 = 0; t6 < e9; t6++) {
          const e10 = n9[t6];
          e10[0] = t6, e10[1] = d3[t6];
        }
        n9.sort(On);
        for (let t6 = 0; t6 < 8; t6++)
          t6 < e9 && n9[t6][1] ? (o7[t6][0] = n9[t6][0], o7[t6][1] = n9[t6][1]) : (o7[t6][0] = Number.MAX_SAFE_INTEGER, o7[t6][1] = 0);
        o7.sort(In);
        const s7 = h4.morphAttributes.position, a5 = h4.morphAttributes.normal;
        let l7 = 0;
        for (let t6 = 0; t6 < 8; t6++) {
          const e10 = o7[t6], n10 = e10[0], i7 = e10[1];
          n10 !== Number.MAX_SAFE_INTEGER && i7 ? (s7 && h4.getAttribute("morphTarget" + t6) !== s7[n10] && h4.setAttribute("morphTarget" + t6, s7[n10]), a5 && h4.getAttribute("morphNormal" + t6) !== a5[n10] && h4.setAttribute("morphNormal" + t6, a5[n10]), r5[t6] = i7, l7 += i7) : (s7 && h4.hasAttribute("morphTarget" + t6) === true && h4.deleteAttribute("morphTarget" + t6), a5 && h4.hasAttribute("morphNormal" + t6) === true && h4.deleteAttribute("morphNormal" + t6), r5[t6] = 0);
        }
        const c4 = h4.morphTargetsRelative ? 1 : 1 - l7;
        u3.getUniforms().setValue(t5, "morphTargetBaseInfluence", c4), u3.getUniforms().setValue(t5, "morphTargetInfluences", r5);
      }
    } };
  }
  function Un(t5, e8, n8, i6) {
    let r5 = /* @__PURE__ */ new WeakMap();
    function s6(t6) {
      const e9 = t6.target;
      e9.removeEventListener("dispose", s6), n8.remove(e9.instanceMatrix), e9.instanceColor !== null && n8.remove(e9.instanceColor);
    }
    return { update: function(t6) {
      const a4 = i6.render.frame, o7 = t6.geometry, l6 = e8.get(t6, o7);
      return r5.get(l6) !== a4 && (e8.update(l6), r5.set(l6, a4)), t6.isInstancedMesh && (t6.hasEventListener("dispose", s6) === false && t6.addEventListener("dispose", s6), n8.update(t6.instanceMatrix, 34962), t6.instanceColor !== null && n8.update(t6.instanceColor, 34962)), l6;
    }, dispose: function() {
      r5 = /* @__PURE__ */ new WeakMap();
    } };
  }
  var kn = new F();
  var Bn = new B();
  var zn = new z2();
  var Hn = new qe();
  var Vn = [];
  var Gn = [];
  var Wn = new Float32Array(16);
  var jn = new Float32Array(9);
  var qn = new Float32Array(4);
  function Xn(t5, e8, n8) {
    const i6 = t5[0];
    if (i6 <= 0 || i6 > 0)
      return t5;
    const r5 = e8 * n8;
    let s6 = Vn[r5];
    if (s6 === void 0 && (s6 = new Float32Array(r5), Vn[r5] = s6), e8 !== 0) {
      i6.toArray(s6, 0);
      for (let i7 = 1, r6 = 0; i7 !== e8; ++i7)
        r6 += n8, t5[i7].toArray(s6, r6);
    }
    return s6;
  }
  function $n(t5, e8) {
    if (t5.length !== e8.length)
      return false;
    for (let n8 = 0, i6 = t5.length; n8 < i6; n8++)
      if (t5[n8] !== e8[n8])
        return false;
    return true;
  }
  function Yn(t5, e8) {
    for (let n8 = 0, i6 = e8.length; n8 < i6; n8++)
      t5[n8] = e8[n8];
  }
  function Jn(t5, e8) {
    let n8 = Gn[e8];
    n8 === void 0 && (n8 = new Int32Array(e8), Gn[e8] = n8);
    for (let i6 = 0; i6 !== e8; ++i6)
      n8[i6] = t5.allocateTextureUnit();
    return n8;
  }
  function Kn(t5, e8) {
    const n8 = this.cache;
    n8[0] !== e8 && (t5.uniform1f(this.addr, e8), n8[0] = e8);
  }
  function Zn(t5, e8) {
    const n8 = this.cache;
    if (e8.x !== void 0)
      n8[0] === e8.x && n8[1] === e8.y || (t5.uniform2f(this.addr, e8.x, e8.y), n8[0] = e8.x, n8[1] = e8.y);
    else {
      if ($n(n8, e8))
        return;
      t5.uniform2fv(this.addr, e8), Yn(n8, e8);
    }
  }
  function Qn(t5, e8) {
    const n8 = this.cache;
    if (e8.x !== void 0)
      n8[0] === e8.x && n8[1] === e8.y && n8[2] === e8.z || (t5.uniform3f(this.addr, e8.x, e8.y, e8.z), n8[0] = e8.x, n8[1] = e8.y, n8[2] = e8.z);
    else if (e8.r !== void 0)
      n8[0] === e8.r && n8[1] === e8.g && n8[2] === e8.b || (t5.uniform3f(this.addr, e8.r, e8.g, e8.b), n8[0] = e8.r, n8[1] = e8.g, n8[2] = e8.b);
    else {
      if ($n(n8, e8))
        return;
      t5.uniform3fv(this.addr, e8), Yn(n8, e8);
    }
  }
  function ti(t5, e8) {
    const n8 = this.cache;
    if (e8.x !== void 0)
      n8[0] === e8.x && n8[1] === e8.y && n8[2] === e8.z && n8[3] === e8.w || (t5.uniform4f(this.addr, e8.x, e8.y, e8.z, e8.w), n8[0] = e8.x, n8[1] = e8.y, n8[2] = e8.z, n8[3] = e8.w);
    else {
      if ($n(n8, e8))
        return;
      t5.uniform4fv(this.addr, e8), Yn(n8, e8);
    }
  }
  function ei(t5, e8) {
    const n8 = this.cache, i6 = e8.elements;
    if (i6 === void 0) {
      if ($n(n8, e8))
        return;
      t5.uniformMatrix2fv(this.addr, false, e8), Yn(n8, e8);
    } else {
      if ($n(n8, i6))
        return;
      qn.set(i6), t5.uniformMatrix2fv(this.addr, false, qn), Yn(n8, i6);
    }
  }
  function ni(t5, e8) {
    const n8 = this.cache, i6 = e8.elements;
    if (i6 === void 0) {
      if ($n(n8, e8))
        return;
      t5.uniformMatrix3fv(this.addr, false, e8), Yn(n8, e8);
    } else {
      if ($n(n8, i6))
        return;
      jn.set(i6), t5.uniformMatrix3fv(this.addr, false, jn), Yn(n8, i6);
    }
  }
  function ii(t5, e8) {
    const n8 = this.cache, i6 = e8.elements;
    if (i6 === void 0) {
      if ($n(n8, e8))
        return;
      t5.uniformMatrix4fv(this.addr, false, e8), Yn(n8, e8);
    } else {
      if ($n(n8, i6))
        return;
      Wn.set(i6), t5.uniformMatrix4fv(this.addr, false, Wn), Yn(n8, i6);
    }
  }
  function ri(t5, e8) {
    const n8 = this.cache;
    n8[0] !== e8 && (t5.uniform1i(this.addr, e8), n8[0] = e8);
  }
  function si(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform2iv(this.addr, e8), Yn(n8, e8));
  }
  function ai(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform3iv(this.addr, e8), Yn(n8, e8));
  }
  function oi(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform4iv(this.addr, e8), Yn(n8, e8));
  }
  function li(t5, e8) {
    const n8 = this.cache;
    n8[0] !== e8 && (t5.uniform1ui(this.addr, e8), n8[0] = e8);
  }
  function hi(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform2uiv(this.addr, e8), Yn(n8, e8));
  }
  function ci(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform3uiv(this.addr, e8), Yn(n8, e8));
  }
  function ui(t5, e8) {
    const n8 = this.cache;
    $n(n8, e8) || (t5.uniform4uiv(this.addr, e8), Yn(n8, e8));
  }
  function di(t5, e8, n8) {
    const i6 = this.cache, r5 = n8.allocateTextureUnit();
    i6[0] !== r5 && (t5.uniform1i(this.addr, r5), i6[0] = r5), n8.setTexture2D(e8 || kn, r5);
  }
  function pi(t5, e8, n8) {
    const i6 = this.cache, r5 = n8.allocateTextureUnit();
    i6[0] !== r5 && (t5.uniform1i(this.addr, r5), i6[0] = r5), n8.setTexture3D(e8 || zn, r5);
  }
  function mi(t5, e8, n8) {
    const i6 = this.cache, r5 = n8.allocateTextureUnit();
    i6[0] !== r5 && (t5.uniform1i(this.addr, r5), i6[0] = r5), n8.setTextureCube(e8 || Hn, r5);
  }
  function fi(t5, e8, n8) {
    const i6 = this.cache, r5 = n8.allocateTextureUnit();
    i6[0] !== r5 && (t5.uniform1i(this.addr, r5), i6[0] = r5), n8.setTexture2DArray(e8 || Bn, r5);
  }
  function gi(t5, e8) {
    t5.uniform1fv(this.addr, e8);
  }
  function vi(t5, e8) {
    const n8 = Xn(e8, this.size, 2);
    t5.uniform2fv(this.addr, n8);
  }
  function yi(t5, e8) {
    const n8 = Xn(e8, this.size, 3);
    t5.uniform3fv(this.addr, n8);
  }
  function xi(t5, e8) {
    const n8 = Xn(e8, this.size, 4);
    t5.uniform4fv(this.addr, n8);
  }
  function bi(t5, e8) {
    const n8 = Xn(e8, this.size, 4);
    t5.uniformMatrix2fv(this.addr, false, n8);
  }
  function _i(t5, e8) {
    const n8 = Xn(e8, this.size, 9);
    t5.uniformMatrix3fv(this.addr, false, n8);
  }
  function wi(t5, e8) {
    const n8 = Xn(e8, this.size, 16);
    t5.uniformMatrix4fv(this.addr, false, n8);
  }
  function Mi(t5, e8) {
    t5.uniform1iv(this.addr, e8);
  }
  function Si(t5, e8) {
    t5.uniform2iv(this.addr, e8);
  }
  function Ti(t5, e8) {
    t5.uniform3iv(this.addr, e8);
  }
  function Ei(t5, e8) {
    t5.uniform4iv(this.addr, e8);
  }
  function Ai(t5, e8) {
    t5.uniform1uiv(this.addr, e8);
  }
  function Ri(t5, e8) {
    t5.uniform2uiv(this.addr, e8);
  }
  function Ci(t5, e8) {
    t5.uniform3uiv(this.addr, e8);
  }
  function Li(t5, e8) {
    t5.uniform4uiv(this.addr, e8);
  }
  function Pi(t5, e8, n8) {
    const i6 = e8.length, r5 = Jn(n8, i6);
    t5.uniform1iv(this.addr, r5);
    for (let t6 = 0; t6 !== i6; ++t6)
      n8.setTexture2D(e8[t6] || kn, r5[t6]);
  }
  function Di(t5, e8, n8) {
    const i6 = e8.length, r5 = Jn(n8, i6);
    t5.uniform1iv(this.addr, r5);
    for (let t6 = 0; t6 !== i6; ++t6)
      n8.setTexture3D(e8[t6] || zn, r5[t6]);
  }
  function Ii(t5, e8, n8) {
    const i6 = e8.length, r5 = Jn(n8, i6);
    t5.uniform1iv(this.addr, r5);
    for (let t6 = 0; t6 !== i6; ++t6)
      n8.setTextureCube(e8[t6] || Hn, r5[t6]);
  }
  function Oi(t5, e8, n8) {
    const i6 = e8.length, r5 = Jn(n8, i6);
    t5.uniform1iv(this.addr, r5);
    for (let t6 = 0; t6 !== i6; ++t6)
      n8.setTexture2DArray(e8[t6] || Bn, r5[t6]);
  }
  function Ni(t5, e8, n8) {
    this.id = t5, this.addr = n8, this.cache = [], this.setValue = function(t6) {
      switch (t6) {
        case 5126:
          return Kn;
        case 35664:
          return Zn;
        case 35665:
          return Qn;
        case 35666:
          return ti;
        case 35674:
          return ei;
        case 35675:
          return ni;
        case 35676:
          return ii;
        case 5124:
        case 35670:
          return ri;
        case 35667:
        case 35671:
          return si;
        case 35668:
        case 35672:
          return ai;
        case 35669:
        case 35673:
          return oi;
        case 5125:
          return li;
        case 36294:
          return hi;
        case 36295:
          return ci;
        case 36296:
          return ui;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return di;
        case 35679:
        case 36299:
        case 36307:
          return pi;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return mi;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return fi;
      }
    }(e8.type);
  }
  function Fi(t5, e8, n8) {
    this.id = t5, this.addr = n8, this.cache = [], this.size = e8.size, this.setValue = function(t6) {
      switch (t6) {
        case 5126:
          return gi;
        case 35664:
          return vi;
        case 35665:
          return yi;
        case 35666:
          return xi;
        case 35674:
          return bi;
        case 35675:
          return _i;
        case 35676:
          return wi;
        case 5124:
        case 35670:
          return Mi;
        case 35667:
        case 35671:
          return Si;
        case 35668:
        case 35672:
          return Ti;
        case 35669:
        case 35673:
          return Ei;
        case 5125:
          return Ai;
        case 36294:
          return Ri;
        case 36295:
          return Ci;
        case 36296:
          return Li;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Pi;
        case 35679:
        case 36299:
        case 36307:
          return Di;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Ii;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Oi;
      }
    }(e8.type);
  }
  function Ui(t5) {
    this.id = t5, this.seq = [], this.map = {};
  }
  Fi.prototype.updateCache = function(t5) {
    const e8 = this.cache;
    t5 instanceof Float32Array && e8.length !== t5.length && (this.cache = new Float32Array(t5.length)), Yn(e8, t5);
  }, Ui.prototype.setValue = function(t5, e8, n8) {
    const i6 = this.seq;
    for (let r5 = 0, s6 = i6.length; r5 !== s6; ++r5) {
      const s7 = i6[r5];
      s7.setValue(t5, e8[s7.id], n8);
    }
  };
  var ki = /(\w+)(\])?(\[|\.)?/g;
  function Bi(t5, e8) {
    t5.seq.push(e8), t5.map[e8.id] = e8;
  }
  function zi(t5, e8, n8) {
    const i6 = t5.name, r5 = i6.length;
    for (ki.lastIndex = 0; ; ) {
      const s6 = ki.exec(i6), a4 = ki.lastIndex;
      let o7 = s6[1];
      const l6 = s6[2] === "]", h4 = s6[3];
      if (l6 && (o7 |= 0), h4 === void 0 || h4 === "[" && a4 + 2 === r5) {
        Bi(n8, h4 === void 0 ? new Ni(o7, t5, e8) : new Fi(o7, t5, e8));
        break;
      }
      {
        let t6 = n8.map[o7];
        t6 === void 0 && (t6 = new Ui(o7), Bi(n8, t6)), n8 = t6;
      }
    }
  }
  function Hi(t5, e8) {
    this.seq = [], this.map = {};
    const n8 = t5.getProgramParameter(e8, 35718);
    for (let i6 = 0; i6 < n8; ++i6) {
      const n9 = t5.getActiveUniform(e8, i6);
      zi(n9, t5.getUniformLocation(e8, n9.name), this);
    }
  }
  function Vi(t5, e8, n8) {
    const i6 = t5.createShader(e8);
    return t5.shaderSource(i6, n8), t5.compileShader(i6), i6;
  }
  Hi.prototype.setValue = function(t5, e8, n8, i6) {
    const r5 = this.map[e8];
    r5 !== void 0 && r5.setValue(t5, n8, i6);
  }, Hi.prototype.setOptional = function(t5, e8, n8) {
    const i6 = e8[n8];
    i6 !== void 0 && this.setValue(t5, n8, i6);
  }, Hi.upload = function(t5, e8, n8, i6) {
    for (let r5 = 0, s6 = e8.length; r5 !== s6; ++r5) {
      const s7 = e8[r5], a4 = n8[s7.id];
      a4.needsUpdate !== false && s7.setValue(t5, a4.value, i6);
    }
  }, Hi.seqWithValue = function(t5, e8) {
    const n8 = [];
    for (let i6 = 0, r5 = t5.length; i6 !== r5; ++i6) {
      const r6 = t5[i6];
      r6.id in e8 && n8.push(r6);
    }
    return n8;
  };
  var Gi = 0;
  function Wi(t5, e8, n8) {
    const i6 = t5.getShaderParameter(e8, 35713), r5 = t5.getShaderInfoLog(e8).trim();
    if (i6 && r5 === "")
      return "";
    const s6 = parseInt(/ERROR: 0:(\d+)/.exec(r5)[1]);
    return n8.toUpperCase() + "\n\n" + r5 + "\n\n" + function(t6, e9) {
      const n9 = t6.split("\n"), i7 = [], r6 = Math.max(e9 - 6, 0), s7 = Math.min(e9 + 6, n9.length);
      for (let t7 = r6; t7 < s7; t7++)
        i7.push(t7 + 1 + ": " + n9[t7]);
      return i7.join("\n");
    }(t5.getShaderSource(e8), s6);
  }
  function ji(t5, e8) {
    const n8 = function(t6) {
      switch (t6) {
        case 3e3:
          return ["Linear", "( value )"];
        case 3001:
          return ["sRGB", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t6), ["Linear", "( value )"];
      }
    }(e8);
    return "vec4 " + t5 + "( vec4 value ) { return LinearTo" + n8[0] + n8[1] + "; }";
  }
  function qi(t5, e8) {
    let n8;
    switch (e8) {
      case 1:
        n8 = "Linear";
        break;
      case 2:
        n8 = "Reinhard";
        break;
      case 3:
        n8 = "OptimizedCineon";
        break;
      case 4:
        n8 = "ACESFilmic";
        break;
      case 5:
        n8 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e8), n8 = "Linear";
    }
    return "vec3 " + t5 + "( vec3 color ) { return " + n8 + "ToneMapping( color ); }";
  }
  function Xi(t5) {
    return t5 !== "";
  }
  function $i(t5, e8) {
    return t5.replace(/NUM_DIR_LIGHTS/g, e8.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e8.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e8.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e8.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e8.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e8.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e8.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e8.numPointLightShadows);
  }
  function Yi(t5, e8) {
    return t5.replace(/NUM_CLIPPING_PLANES/g, e8.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e8.numClippingPlanes - e8.numClipIntersection);
  }
  var Ji = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Ki(t5) {
    return t5.replace(Ji, Zi);
  }
  function Zi(t5, e8) {
    const n8 = sn[e8];
    if (n8 === void 0)
      throw new Error("Can not resolve #include <" + e8 + ">");
    return Ki(n8);
  }
  var Qi = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var tr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function er(t5) {
    return t5.replace(tr, ir).replace(Qi, nr);
  }
  function nr(t5, e8, n8, i6) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ir(t5, e8, n8, i6);
  }
  function ir(t5, e8, n8, i6) {
    let r5 = "";
    for (let t6 = parseInt(e8); t6 < parseInt(n8); t6++)
      r5 += i6.replace(/\[\s*i\s*\]/g, "[ " + t6 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t6);
    return r5;
  }
  function rr(t5) {
    let e8 = "precision " + t5.precision + " float;\nprecision " + t5.precision + " int;";
    return t5.precision === "highp" ? e8 += "\n#define HIGH_PRECISION" : t5.precision === "mediump" ? e8 += "\n#define MEDIUM_PRECISION" : t5.precision === "lowp" && (e8 += "\n#define LOW_PRECISION"), e8;
  }
  function sr(t5, e8, n8, i6) {
    const r5 = t5.getContext(), s6 = n8.defines;
    let a4 = n8.vertexShader, o7 = n8.fragmentShader;
    const l6 = function(t6) {
      let e9 = "SHADOWMAP_TYPE_BASIC";
      return t6.shadowMapType === 1 ? e9 = "SHADOWMAP_TYPE_PCF" : t6.shadowMapType === 2 ? e9 = "SHADOWMAP_TYPE_PCF_SOFT" : t6.shadowMapType === 3 && (e9 = "SHADOWMAP_TYPE_VSM"), e9;
    }(n8), h4 = function(t6) {
      let e9 = "ENVMAP_TYPE_CUBE";
      if (t6.envMap)
        switch (t6.envMapMode) {
          case 301:
          case 302:
            e9 = "ENVMAP_TYPE_CUBE";
            break;
          case 306:
            e9 = "ENVMAP_TYPE_CUBE_UV";
        }
      return e9;
    }(n8), c3 = function(t6) {
      let e9 = "ENVMAP_MODE_REFLECTION";
      t6.envMap && t6.envMapMode === 302 && (e9 = "ENVMAP_MODE_REFRACTION");
      return e9;
    }(n8), u3 = function(t6) {
      let e9 = "ENVMAP_BLENDING_NONE";
      if (t6.envMap)
        switch (t6.combine) {
          case 0:
            e9 = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            e9 = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            e9 = "ENVMAP_BLENDING_ADD";
        }
      return e9;
    }(n8), d3 = function(t6) {
      const e9 = t6.envMapCubeUVHeight;
      if (e9 === null)
        return null;
      const n9 = Math.log2(e9 / 32 + 1) + 3, i7 = 1 / e9;
      return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n9), 112)), texelHeight: i7, maxMip: n9 };
    }(n8), p3 = n8.isWebGL2 ? "" : function(t6) {
      return [t6.extensionDerivatives || t6.envMapCubeUVHeight || t6.bumpMap || t6.tangentSpaceNormalMap || t6.clearcoatNormalMap || t6.flatShading || t6.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t6.extensionFragDepth || t6.logarithmicDepthBuffer) && t6.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t6.extensionDrawBuffers && t6.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t6.extensionShaderTextureLOD || t6.envMap || t6.transmission) && t6.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Xi).join("\n");
    }(n8), m3 = function(t6) {
      const e9 = [];
      for (const n9 in t6) {
        const i7 = t6[n9];
        i7 !== false && e9.push("#define " + n9 + " " + i7);
      }
      return e9.join("\n");
    }(s6), f3 = r5.createProgram();
    let g3, v3, y3 = n8.glslVersion ? "#version " + n8.glslVersion + "\n" : "";
    n8.isRawShaderMaterial ? (g3 = [m3].filter(Xi).join("\n"), g3.length > 0 && (g3 += "\n"), v3 = [p3, m3].filter(Xi).join("\n"), v3.length > 0 && (v3 += "\n")) : (g3 = [rr(n8), "#define SHADER_NAME " + n8.shaderName, m3, n8.instancing ? "#define USE_INSTANCING" : "", n8.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n8.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n8.maxBones, n8.useFog && n8.fog ? "#define USE_FOG" : "", n8.useFog && n8.fogExp2 ? "#define FOG_EXP2" : "", n8.map ? "#define USE_MAP" : "", n8.envMap ? "#define USE_ENVMAP" : "", n8.envMap ? "#define " + c3 : "", n8.lightMap ? "#define USE_LIGHTMAP" : "", n8.aoMap ? "#define USE_AOMAP" : "", n8.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n8.bumpMap ? "#define USE_BUMPMAP" : "", n8.normalMap ? "#define USE_NORMALMAP" : "", n8.normalMap && n8.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n8.normalMap && n8.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n8.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n8.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n8.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n8.displacementMap && n8.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n8.specularMap ? "#define USE_SPECULARMAP" : "", n8.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n8.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n8.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n8.metalnessMap ? "#define USE_METALNESSMAP" : "", n8.alphaMap ? "#define USE_ALPHAMAP" : "", n8.transmission ? "#define USE_TRANSMISSION" : "", n8.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n8.thicknessMap ? "#define USE_THICKNESSMAP" : "", n8.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n8.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n8.vertexTangents ? "#define USE_TANGENT" : "", n8.vertexColors ? "#define USE_COLOR" : "", n8.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n8.vertexUvs ? "#define USE_UV" : "", n8.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n8.flatShading ? "#define FLAT_SHADED" : "", n8.skinning ? "#define USE_SKINNING" : "", n8.useVertexTexture ? "#define BONE_TEXTURE" : "", n8.morphTargets ? "#define USE_MORPHTARGETS" : "", n8.morphNormals && n8.flatShading === false ? "#define USE_MORPHNORMALS" : "", n8.morphColors && n8.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n8.morphTargetsCount > 0 && n8.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n8.morphTargetsCount > 0 && n8.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n8.morphTextureStride : "", n8.morphTargetsCount > 0 && n8.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n8.morphTargetsCount : "", n8.doubleSided ? "#define DOUBLE_SIDED" : "", n8.flipSided ? "#define FLIP_SIDED" : "", n8.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n8.shadowMapEnabled ? "#define " + l6 : "", n8.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n8.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n8.logarithmicDepthBuffer && n8.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Xi).join("\n"), v3 = [p3, rr(n8), "#define SHADER_NAME " + n8.shaderName, m3, n8.useFog && n8.fog ? "#define USE_FOG" : "", n8.useFog && n8.fogExp2 ? "#define FOG_EXP2" : "", n8.map ? "#define USE_MAP" : "", n8.matcap ? "#define USE_MATCAP" : "", n8.envMap ? "#define USE_ENVMAP" : "", n8.envMap ? "#define " + h4 : "", n8.envMap ? "#define " + c3 : "", n8.envMap ? "#define " + u3 : "", d3 ? "#define CUBEUV_TEXEL_WIDTH " + d3.texelWidth : "", d3 ? "#define CUBEUV_TEXEL_HEIGHT " + d3.texelHeight : "", d3 ? "#define CUBEUV_MAX_MIP " + d3.maxMip + ".0" : "", n8.lightMap ? "#define USE_LIGHTMAP" : "", n8.aoMap ? "#define USE_AOMAP" : "", n8.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n8.bumpMap ? "#define USE_BUMPMAP" : "", n8.normalMap ? "#define USE_NORMALMAP" : "", n8.normalMap && n8.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n8.normalMap && n8.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n8.clearcoat ? "#define USE_CLEARCOAT" : "", n8.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n8.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n8.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n8.specularMap ? "#define USE_SPECULARMAP" : "", n8.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n8.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n8.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n8.metalnessMap ? "#define USE_METALNESSMAP" : "", n8.alphaMap ? "#define USE_ALPHAMAP" : "", n8.alphaTest ? "#define USE_ALPHATEST" : "", n8.sheen ? "#define USE_SHEEN" : "", n8.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n8.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n8.transmission ? "#define USE_TRANSMISSION" : "", n8.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n8.thicknessMap ? "#define USE_THICKNESSMAP" : "", n8.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n8.vertexTangents ? "#define USE_TANGENT" : "", n8.vertexColors || n8.instancingColor ? "#define USE_COLOR" : "", n8.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n8.vertexUvs ? "#define USE_UV" : "", n8.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n8.gradientMap ? "#define USE_GRADIENTMAP" : "", n8.flatShading ? "#define FLAT_SHADED" : "", n8.doubleSided ? "#define DOUBLE_SIDED" : "", n8.flipSided ? "#define FLIP_SIDED" : "", n8.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n8.shadowMapEnabled ? "#define " + l6 : "", n8.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n8.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n8.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n8.logarithmicDepthBuffer && n8.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n8.toneMapping !== 0 ? "#define TONE_MAPPING" : "", n8.toneMapping !== 0 ? sn.tonemapping_pars_fragment : "", n8.toneMapping !== 0 ? qi("toneMapping", n8.toneMapping) : "", n8.dithering ? "#define DITHERING" : "", n8.opaque ? "#define OPAQUE" : "", sn.encodings_pars_fragment, ji("linearToOutputTexel", n8.outputEncoding), n8.depthPacking ? "#define DEPTH_PACKING " + n8.depthPacking : "", "\n"].filter(Xi).join("\n")), a4 = Ki(a4), a4 = $i(a4, n8), a4 = Yi(a4, n8), o7 = Ki(o7), o7 = $i(o7, n8), o7 = Yi(o7, n8), a4 = er(a4), o7 = er(o7), n8.isWebGL2 && n8.isRawShaderMaterial !== true && (y3 = "#version 300 es\n", g3 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g3, v3 = ["#define varying in", n8.glslVersion === "300 es" ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n8.glslVersion === "300 es" ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v3);
    const x3 = y3 + v3 + o7, b3 = Vi(r5, 35633, y3 + g3 + a4), _3 = Vi(r5, 35632, x3);
    if (r5.attachShader(f3, b3), r5.attachShader(f3, _3), n8.index0AttributeName !== void 0 ? r5.bindAttribLocation(f3, 0, n8.index0AttributeName) : n8.morphTargets === true && r5.bindAttribLocation(f3, 0, "position"), r5.linkProgram(f3), t5.debug.checkShaderErrors) {
      const t6 = r5.getProgramInfoLog(f3).trim(), e9 = r5.getShaderInfoLog(b3).trim(), n9 = r5.getShaderInfoLog(_3).trim();
      let i7 = true, s7 = true;
      if (r5.getProgramParameter(f3, 35714) === false) {
        i7 = false;
        const e10 = Wi(r5, b3, "vertex"), n10 = Wi(r5, _3, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + r5.getError() + " - VALIDATE_STATUS " + r5.getProgramParameter(f3, 35715) + "\n\nProgram Info Log: " + t6 + "\n" + e10 + "\n" + n10);
      } else
        t6 !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", t6) : e9 !== "" && n9 !== "" || (s7 = false);
      s7 && (this.diagnostics = { runnable: i7, programLog: t6, vertexShader: { log: e9, prefix: g3 }, fragmentShader: { log: n9, prefix: v3 } });
    }
    let w3, M3;
    return r5.deleteShader(b3), r5.deleteShader(_3), this.getUniforms = function() {
      return w3 === void 0 && (w3 = new Hi(r5, f3)), w3;
    }, this.getAttributes = function() {
      return M3 === void 0 && (M3 = function(t6, e9) {
        const n9 = {}, i7 = t6.getProgramParameter(e9, 35721);
        for (let r6 = 0; r6 < i7; r6++) {
          const i8 = t6.getActiveAttrib(e9, r6), s7 = i8.name;
          let a5 = 1;
          i8.type === 35674 && (a5 = 2), i8.type === 35675 && (a5 = 3), i8.type === 35676 && (a5 = 4), n9[s7] = { type: i8.type, location: t6.getAttribLocation(e9, s7), locationSize: a5 };
        }
        return n9;
      }(r5, f3)), M3;
    }, this.destroy = function() {
      i6.releaseStatesOfProgram(this), r5.deleteProgram(f3), this.program = void 0;
    }, this.name = n8.shaderName, this.id = Gi++, this.cacheKey = e8, this.usedTimes = 1, this.program = f3, this.vertexShader = b3, this.fragmentShader = _3, this;
  }
  var ar = 0;
  var or = class {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(t5) {
      const e8 = t5.vertexShader, n8 = t5.fragmentShader, i6 = this._getShaderStage(e8), r5 = this._getShaderStage(n8), s6 = this._getShaderCacheForMaterial(t5);
      return s6.has(i6) === false && (s6.add(i6), i6.usedTimes++), s6.has(r5) === false && (s6.add(r5), r5.usedTimes++), this;
    }
    remove(t5) {
      const e8 = this.materialCache.get(t5);
      for (const t6 of e8)
        t6.usedTimes--, t6.usedTimes === 0 && this.shaderCache.delete(t6.code);
      return this.materialCache.delete(t5), this;
    }
    getVertexShaderID(t5) {
      return this._getShaderStage(t5.vertexShader).id;
    }
    getFragmentShaderID(t5) {
      return this._getShaderStage(t5.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t5) {
      const e8 = this.materialCache;
      return e8.has(t5) === false && e8.set(t5, /* @__PURE__ */ new Set()), e8.get(t5);
    }
    _getShaderStage(t5) {
      const e8 = this.shaderCache;
      if (e8.has(t5) === false) {
        const n8 = new lr(t5);
        e8.set(t5, n8);
      }
      return e8.get(t5);
    }
  };
  var lr = class {
    constructor(t5) {
      this.id = ar++, this.code = t5, this.usedTimes = 0;
    }
  };
  function hr(t5, e8, n8, i6, r5, s6, a4) {
    const o7 = new Lt(), l6 = new or(), h4 = [], c3 = r5.isWebGL2, u3 = r5.logarithmicDepthBuffer, d3 = r5.floatVertexTextures, p3 = r5.maxVertexUniforms, m3 = r5.vertexTextures;
    let f3 = r5.precision;
    const g3 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
    return { getParameters: function(s7, o8, h5, v3, y3) {
      const x3 = v3.fog, b3 = y3.geometry, _3 = s7.isMeshStandardMaterial ? v3.environment : null, w3 = (s7.isMeshStandardMaterial ? n8 : e8).get(s7.envMap || _3), M3 = w3 && w3.mapping === 306 ? w3.image.height : null, S4 = g3[s7.type], T3 = y3.isSkinnedMesh ? function(t6) {
        const e9 = t6.skeleton.bones;
        if (d3)
          return 1024;
        {
          const t7 = p3, n9 = Math.floor((t7 - 20) / 4), i7 = Math.min(n9, e9.length);
          return i7 < e9.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e9.length + " bones. This GPU supports " + i7 + "."), 0) : i7;
        }
      }(y3) : 0;
      s7.precision !== null && (f3 = r5.getMaxPrecision(s7.precision), f3 !== s7.precision && console.warn("THREE.WebGLProgram.getParameters:", s7.precision, "not supported, using", f3, "instead."));
      const E3 = b3.morphAttributes.position || b3.morphAttributes.normal || b3.morphAttributes.color, A3 = E3 !== void 0 ? E3.length : 0;
      let R2, C3, L3, P3, D2 = 0;
      if (b3.morphAttributes.position !== void 0 && (D2 = 1), b3.morphAttributes.normal !== void 0 && (D2 = 2), b3.morphAttributes.color !== void 0 && (D2 = 3), S4) {
        const t6 = on[S4];
        R2 = t6.vertexShader, C3 = t6.fragmentShader;
      } else
        R2 = s7.vertexShader, C3 = s7.fragmentShader, l6.update(s7), L3 = l6.getVertexShaderID(s7), P3 = l6.getFragmentShaderID(s7);
      const I3 = t5.getRenderTarget(), O2 = s7.alphaTest > 0, N3 = s7.clearcoat > 0;
      return { isWebGL2: c3, shaderID: S4, shaderName: s7.type, vertexShader: R2, fragmentShader: C3, defines: s7.defines, customVertexShaderID: L3, customFragmentShaderID: P3, isRawShaderMaterial: s7.isRawShaderMaterial === true, glslVersion: s7.glslVersion, precision: f3, instancing: y3.isInstancedMesh === true, instancingColor: y3.isInstancedMesh === true && y3.instanceColor !== null, supportsVertexTextures: m3, outputEncoding: I3 === null ? t5.outputEncoding : I3.isXRRenderTarget === true ? I3.texture.encoding : 3e3, map: !!s7.map, matcap: !!s7.matcap, envMap: !!w3, envMapMode: w3 && w3.mapping, envMapCubeUVHeight: M3, lightMap: !!s7.lightMap, aoMap: !!s7.aoMap, emissiveMap: !!s7.emissiveMap, bumpMap: !!s7.bumpMap, normalMap: !!s7.normalMap, objectSpaceNormalMap: s7.normalMapType === 1, tangentSpaceNormalMap: s7.normalMapType === 0, decodeVideoTexture: !!s7.map && s7.map.isVideoTexture === true && s7.map.encoding === 3001, clearcoat: N3, clearcoatMap: N3 && !!s7.clearcoatMap, clearcoatRoughnessMap: N3 && !!s7.clearcoatRoughnessMap, clearcoatNormalMap: N3 && !!s7.clearcoatNormalMap, displacementMap: !!s7.displacementMap, roughnessMap: !!s7.roughnessMap, metalnessMap: !!s7.metalnessMap, specularMap: !!s7.specularMap, specularIntensityMap: !!s7.specularIntensityMap, specularColorMap: !!s7.specularColorMap, opaque: s7.transparent === false && s7.blending === 1, alphaMap: !!s7.alphaMap, alphaTest: O2, gradientMap: !!s7.gradientMap, sheen: s7.sheen > 0, sheenColorMap: !!s7.sheenColorMap, sheenRoughnessMap: !!s7.sheenRoughnessMap, transmission: s7.transmission > 0, transmissionMap: !!s7.transmissionMap, thicknessMap: !!s7.thicknessMap, combine: s7.combine, vertexTangents: !!s7.normalMap && !!b3.attributes.tangent, vertexColors: s7.vertexColors, vertexAlphas: s7.vertexColors === true && !!b3.attributes.color && b3.attributes.color.itemSize === 4, vertexUvs: !!(s7.map || s7.bumpMap || s7.normalMap || s7.specularMap || s7.alphaMap || s7.emissiveMap || s7.roughnessMap || s7.metalnessMap || s7.clearcoatMap || s7.clearcoatRoughnessMap || s7.clearcoatNormalMap || s7.displacementMap || s7.transmissionMap || s7.thicknessMap || s7.specularIntensityMap || s7.specularColorMap || s7.sheenColorMap || s7.sheenRoughnessMap), uvsVertexOnly: !(s7.map || s7.bumpMap || s7.normalMap || s7.specularMap || s7.alphaMap || s7.emissiveMap || s7.roughnessMap || s7.metalnessMap || s7.clearcoatNormalMap || s7.transmission > 0 || s7.transmissionMap || s7.thicknessMap || s7.specularIntensityMap || s7.specularColorMap || s7.sheen > 0 || s7.sheenColorMap || s7.sheenRoughnessMap || !s7.displacementMap), fog: !!x3, useFog: s7.fog, fogExp2: x3 && x3.isFogExp2, flatShading: !!s7.flatShading, sizeAttenuation: s7.sizeAttenuation, logarithmicDepthBuffer: u3, skinning: y3.isSkinnedMesh === true && T3 > 0, maxBones: T3, useVertexTexture: d3, morphTargets: b3.morphAttributes.position !== void 0, morphNormals: b3.morphAttributes.normal !== void 0, morphColors: b3.morphAttributes.color !== void 0, morphTargetsCount: A3, morphTextureStride: D2, numDirLights: o8.directional.length, numPointLights: o8.point.length, numSpotLights: o8.spot.length, numRectAreaLights: o8.rectArea.length, numHemiLights: o8.hemi.length, numDirLightShadows: o8.directionalShadowMap.length, numPointLightShadows: o8.pointShadowMap.length, numSpotLightShadows: o8.spotShadowMap.length, numClippingPlanes: a4.numPlanes, numClipIntersection: a4.numIntersection, dithering: s7.dithering, shadowMapEnabled: t5.shadowMap.enabled && h5.length > 0, shadowMapType: t5.shadowMap.type, toneMapping: s7.toneMapped ? t5.toneMapping : 0, physicallyCorrectLights: t5.physicallyCorrectLights, premultipliedAlpha: s7.premultipliedAlpha, doubleSided: s7.side === 2, flipSided: s7.side === 1, depthPacking: s7.depthPacking !== void 0 && s7.depthPacking, index0AttributeName: s7.index0AttributeName, extensionDerivatives: s7.extensions && s7.extensions.derivatives, extensionFragDepth: s7.extensions && s7.extensions.fragDepth, extensionDrawBuffers: s7.extensions && s7.extensions.drawBuffers, extensionShaderTextureLOD: s7.extensions && s7.extensions.shaderTextureLOD, rendererExtensionFragDepth: c3 || i6.has("EXT_frag_depth"), rendererExtensionDrawBuffers: c3 || i6.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: c3 || i6.has("EXT_shader_texture_lod"), customProgramCacheKey: s7.customProgramCacheKey() };
    }, getProgramCacheKey: function(e9) {
      const n9 = [];
      if (e9.shaderID ? n9.push(e9.shaderID) : (n9.push(e9.customVertexShaderID), n9.push(e9.customFragmentShaderID)), e9.defines !== void 0)
        for (const t6 in e9.defines)
          n9.push(t6), n9.push(e9.defines[t6]);
      return e9.isRawShaderMaterial === false && (!function(t6, e10) {
        t6.push(e10.precision), t6.push(e10.outputEncoding), t6.push(e10.envMapMode), t6.push(e10.envMapCubeUVHeight), t6.push(e10.combine), t6.push(e10.vertexUvs), t6.push(e10.fogExp2), t6.push(e10.sizeAttenuation), t6.push(e10.maxBones), t6.push(e10.morphTargetsCount), t6.push(e10.morphAttributeCount), t6.push(e10.numDirLights), t6.push(e10.numPointLights), t6.push(e10.numSpotLights), t6.push(e10.numHemiLights), t6.push(e10.numRectAreaLights), t6.push(e10.numDirLightShadows), t6.push(e10.numPointLightShadows), t6.push(e10.numSpotLightShadows), t6.push(e10.shadowMapType), t6.push(e10.toneMapping), t6.push(e10.numClippingPlanes), t6.push(e10.numClipIntersection);
      }(n9, e9), function(t6, e10) {
        o7.disableAll(), e10.isWebGL2 && o7.enable(0);
        e10.supportsVertexTextures && o7.enable(1);
        e10.instancing && o7.enable(2);
        e10.instancingColor && o7.enable(3);
        e10.map && o7.enable(4);
        e10.matcap && o7.enable(5);
        e10.envMap && o7.enable(6);
        e10.lightMap && o7.enable(7);
        e10.aoMap && o7.enable(8);
        e10.emissiveMap && o7.enable(9);
        e10.bumpMap && o7.enable(10);
        e10.normalMap && o7.enable(11);
        e10.objectSpaceNormalMap && o7.enable(12);
        e10.tangentSpaceNormalMap && o7.enable(13);
        e10.clearcoat && o7.enable(14);
        e10.clearcoatMap && o7.enable(15);
        e10.clearcoatRoughnessMap && o7.enable(16);
        e10.clearcoatNormalMap && o7.enable(17);
        e10.displacementMap && o7.enable(18);
        e10.specularMap && o7.enable(19);
        e10.roughnessMap && o7.enable(20);
        e10.metalnessMap && o7.enable(21);
        e10.gradientMap && o7.enable(22);
        e10.alphaMap && o7.enable(23);
        e10.alphaTest && o7.enable(24);
        e10.vertexColors && o7.enable(25);
        e10.vertexAlphas && o7.enable(26);
        e10.vertexUvs && o7.enable(27);
        e10.vertexTangents && o7.enable(28);
        e10.uvsVertexOnly && o7.enable(29);
        e10.fog && o7.enable(30);
        t6.push(o7.mask), o7.disableAll(), e10.useFog && o7.enable(0);
        e10.flatShading && o7.enable(1);
        e10.logarithmicDepthBuffer && o7.enable(2);
        e10.skinning && o7.enable(3);
        e10.useVertexTexture && o7.enable(4);
        e10.morphTargets && o7.enable(5);
        e10.morphNormals && o7.enable(6);
        e10.morphColors && o7.enable(7);
        e10.premultipliedAlpha && o7.enable(8);
        e10.shadowMapEnabled && o7.enable(9);
        e10.physicallyCorrectLights && o7.enable(10);
        e10.doubleSided && o7.enable(11);
        e10.flipSided && o7.enable(12);
        e10.depthPacking && o7.enable(13);
        e10.dithering && o7.enable(14);
        e10.specularIntensityMap && o7.enable(15);
        e10.specularColorMap && o7.enable(16);
        e10.transmission && o7.enable(17);
        e10.transmissionMap && o7.enable(18);
        e10.thicknessMap && o7.enable(19);
        e10.sheen && o7.enable(20);
        e10.sheenColorMap && o7.enable(21);
        e10.sheenRoughnessMap && o7.enable(22);
        e10.decodeVideoTexture && o7.enable(23);
        e10.opaque && o7.enable(24);
        t6.push(o7.mask);
      }(n9, e9), n9.push(t5.outputEncoding)), n9.push(e9.customProgramCacheKey), n9.join();
    }, getUniforms: function(t6) {
      const e9 = g3[t6.type];
      let n9;
      if (e9) {
        const t7 = on[e9];
        n9 = He.clone(t7.uniforms);
      } else
        n9 = t6.uniforms;
      return n9;
    }, acquireProgram: function(e9, n9) {
      let i7;
      for (let t6 = 0, e10 = h4.length; t6 < e10; t6++) {
        const e11 = h4[t6];
        if (e11.cacheKey === n9) {
          i7 = e11, ++i7.usedTimes;
          break;
        }
      }
      return i7 === void 0 && (i7 = new sr(t5, n9, e9, s6), h4.push(i7)), i7;
    }, releaseProgram: function(t6) {
      if (--t6.usedTimes == 0) {
        const e9 = h4.indexOf(t6);
        h4[e9] = h4[h4.length - 1], h4.pop(), t6.destroy();
      }
    }, releaseShaderCache: function(t6) {
      l6.remove(t6);
    }, programs: h4, dispose: function() {
      l6.dispose();
    } };
  }
  function cr() {
    let t5 = /* @__PURE__ */ new WeakMap();
    return { get: function(e8) {
      let n8 = t5.get(e8);
      return n8 === void 0 && (n8 = {}, t5.set(e8, n8)), n8;
    }, remove: function(e8) {
      t5.delete(e8);
    }, update: function(e8, n8, i6) {
      t5.get(e8)[n8] = i6;
    }, dispose: function() {
      t5 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function ur(t5, e8) {
    return t5.groupOrder !== e8.groupOrder ? t5.groupOrder - e8.groupOrder : t5.renderOrder !== e8.renderOrder ? t5.renderOrder - e8.renderOrder : t5.material.id !== e8.material.id ? t5.material.id - e8.material.id : t5.z !== e8.z ? t5.z - e8.z : t5.id - e8.id;
  }
  function dr(t5, e8) {
    return t5.groupOrder !== e8.groupOrder ? t5.groupOrder - e8.groupOrder : t5.renderOrder !== e8.renderOrder ? t5.renderOrder - e8.renderOrder : t5.z !== e8.z ? e8.z - t5.z : t5.id - e8.id;
  }
  function pr() {
    const t5 = [];
    let e8 = 0;
    const n8 = [], i6 = [], r5 = [];
    function s6(n9, i7, r6, s7, a4, o7) {
      let l6 = t5[e8];
      return l6 === void 0 ? (l6 = { id: n9.id, object: n9, geometry: i7, material: r6, groupOrder: s7, renderOrder: n9.renderOrder, z: a4, group: o7 }, t5[e8] = l6) : (l6.id = n9.id, l6.object = n9, l6.geometry = i7, l6.material = r6, l6.groupOrder = s7, l6.renderOrder = n9.renderOrder, l6.z = a4, l6.group = o7), e8++, l6;
    }
    return { opaque: n8, transmissive: i6, transparent: r5, init: function() {
      e8 = 0, n8.length = 0, i6.length = 0, r5.length = 0;
    }, push: function(t6, e9, a4, o7, l6, h4) {
      const c3 = s6(t6, e9, a4, o7, l6, h4);
      a4.transmission > 0 ? i6.push(c3) : a4.transparent === true ? r5.push(c3) : n8.push(c3);
    }, unshift: function(t6, e9, a4, o7, l6, h4) {
      const c3 = s6(t6, e9, a4, o7, l6, h4);
      a4.transmission > 0 ? i6.unshift(c3) : a4.transparent === true ? r5.unshift(c3) : n8.unshift(c3);
    }, finish: function() {
      for (let n9 = e8, i7 = t5.length; n9 < i7; n9++) {
        const e9 = t5[n9];
        if (e9.id === null)
          break;
        e9.id = null, e9.object = null, e9.geometry = null, e9.material = null, e9.group = null;
      }
    }, sort: function(t6, e9) {
      n8.length > 1 && n8.sort(t6 || ur), i6.length > 1 && i6.sort(e9 || dr), r5.length > 1 && r5.sort(e9 || dr);
    } };
  }
  function mr() {
    let t5 = /* @__PURE__ */ new WeakMap();
    return { get: function(e8, n8) {
      let i6;
      return t5.has(e8) === false ? (i6 = new pr(), t5.set(e8, [i6])) : n8 >= t5.get(e8).length ? (i6 = new pr(), t5.get(e8).push(i6)) : i6 = t5.get(e8)[n8], i6;
    }, dispose: function() {
      t5 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function fr() {
    const t5 = {};
    return { get: function(e8) {
      if (t5[e8.id] !== void 0)
        return t5[e8.id];
      let n8;
      switch (e8.type) {
        case "DirectionalLight":
          n8 = { direction: new V2(), color: new L2() };
          break;
        case "SpotLight":
          n8 = { position: new V2(), direction: new V2(), color: new L2(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          n8 = { position: new V2(), color: new L2(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n8 = { direction: new V2(), skyColor: new L2(), groundColor: new L2() };
          break;
        case "RectAreaLight":
          n8 = { color: new L2(), position: new V2(), halfWidth: new V2(), halfHeight: new V2() };
      }
      return t5[e8.id] = n8, n8;
    } };
  }
  var gr = 0;
  function vr(t5, e8) {
    return (e8.castShadow ? 1 : 0) - (t5.castShadow ? 1 : 0);
  }
  function yr(t5, e8) {
    const n8 = new fr(), i6 = function() {
      const t6 = {};
      return { get: function(e9) {
        if (t6[e9.id] !== void 0)
          return t6[e9.id];
        let n9;
        switch (e9.type) {
          case "DirectionalLight":
          case "SpotLight":
            n9 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g2() };
            break;
          case "PointLight":
            n9 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g2(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        }
        return t6[e9.id] = n9, n9;
      } };
    }(), r5 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
    for (let t6 = 0; t6 < 9; t6++)
      r5.probe.push(new V2());
    const s6 = new V2(), a4 = new xt(), o7 = new xt();
    return { setup: function(s7, a5) {
      let o8 = 0, l6 = 0, h4 = 0;
      for (let t6 = 0; t6 < 9; t6++)
        r5.probe[t6].set(0, 0, 0);
      let c3 = 0, u3 = 0, d3 = 0, p3 = 0, m3 = 0, f3 = 0, g3 = 0, v3 = 0;
      s7.sort(vr);
      const y3 = a5 !== true ? Math.PI : 1;
      for (let t6 = 0, e9 = s7.length; t6 < e9; t6++) {
        const e10 = s7[t6], a6 = e10.color, x4 = e10.intensity, b3 = e10.distance, _3 = e10.shadow && e10.shadow.map ? e10.shadow.map.texture : null;
        if (e10.isAmbientLight)
          o8 += a6.r * x4 * y3, l6 += a6.g * x4 * y3, h4 += a6.b * x4 * y3;
        else if (e10.isLightProbe)
          for (let t7 = 0; t7 < 9; t7++)
            r5.probe[t7].addScaledVector(e10.sh.coefficients[t7], x4);
        else if (e10.isDirectionalLight) {
          const t7 = n8.get(e10);
          if (t7.color.copy(e10.color).multiplyScalar(e10.intensity * y3), e10.castShadow) {
            const t8 = e10.shadow, n9 = i6.get(e10);
            n9.shadowBias = t8.bias, n9.shadowNormalBias = t8.normalBias, n9.shadowRadius = t8.radius, n9.shadowMapSize = t8.mapSize, r5.directionalShadow[c3] = n9, r5.directionalShadowMap[c3] = _3, r5.directionalShadowMatrix[c3] = e10.shadow.matrix, f3++;
          }
          r5.directional[c3] = t7, c3++;
        } else if (e10.isSpotLight) {
          const t7 = n8.get(e10);
          if (t7.position.setFromMatrixPosition(e10.matrixWorld), t7.color.copy(a6).multiplyScalar(x4 * y3), t7.distance = b3, t7.coneCos = Math.cos(e10.angle), t7.penumbraCos = Math.cos(e10.angle * (1 - e10.penumbra)), t7.decay = e10.decay, e10.castShadow) {
            const t8 = e10.shadow, n9 = i6.get(e10);
            n9.shadowBias = t8.bias, n9.shadowNormalBias = t8.normalBias, n9.shadowRadius = t8.radius, n9.shadowMapSize = t8.mapSize, r5.spotShadow[d3] = n9, r5.spotShadowMap[d3] = _3, r5.spotShadowMatrix[d3] = e10.shadow.matrix, v3++;
          }
          r5.spot[d3] = t7, d3++;
        } else if (e10.isRectAreaLight) {
          const t7 = n8.get(e10);
          t7.color.copy(a6).multiplyScalar(x4), t7.halfWidth.set(0.5 * e10.width, 0, 0), t7.halfHeight.set(0, 0.5 * e10.height, 0), r5.rectArea[p3] = t7, p3++;
        } else if (e10.isPointLight) {
          const t7 = n8.get(e10);
          if (t7.color.copy(e10.color).multiplyScalar(e10.intensity * y3), t7.distance = e10.distance, t7.decay = e10.decay, e10.castShadow) {
            const t8 = e10.shadow, n9 = i6.get(e10);
            n9.shadowBias = t8.bias, n9.shadowNormalBias = t8.normalBias, n9.shadowRadius = t8.radius, n9.shadowMapSize = t8.mapSize, n9.shadowCameraNear = t8.camera.near, n9.shadowCameraFar = t8.camera.far, r5.pointShadow[u3] = n9, r5.pointShadowMap[u3] = _3, r5.pointShadowMatrix[u3] = e10.shadow.matrix, g3++;
          }
          r5.point[u3] = t7, u3++;
        } else if (e10.isHemisphereLight) {
          const t7 = n8.get(e10);
          t7.skyColor.copy(e10.color).multiplyScalar(x4 * y3), t7.groundColor.copy(e10.groundColor).multiplyScalar(x4 * y3), r5.hemi[m3] = t7, m3++;
        }
      }
      p3 > 0 && (e8.isWebGL2 || t5.has("OES_texture_float_linear") === true ? (r5.rectAreaLTC1 = an.LTC_FLOAT_1, r5.rectAreaLTC2 = an.LTC_FLOAT_2) : t5.has("OES_texture_half_float_linear") === true ? (r5.rectAreaLTC1 = an.LTC_HALF_1, r5.rectAreaLTC2 = an.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r5.ambient[0] = o8, r5.ambient[1] = l6, r5.ambient[2] = h4;
      const x3 = r5.hash;
      x3.directionalLength === c3 && x3.pointLength === u3 && x3.spotLength === d3 && x3.rectAreaLength === p3 && x3.hemiLength === m3 && x3.numDirectionalShadows === f3 && x3.numPointShadows === g3 && x3.numSpotShadows === v3 || (r5.directional.length = c3, r5.spot.length = d3, r5.rectArea.length = p3, r5.point.length = u3, r5.hemi.length = m3, r5.directionalShadow.length = f3, r5.directionalShadowMap.length = f3, r5.pointShadow.length = g3, r5.pointShadowMap.length = g3, r5.spotShadow.length = v3, r5.spotShadowMap.length = v3, r5.directionalShadowMatrix.length = f3, r5.pointShadowMatrix.length = g3, r5.spotShadowMatrix.length = v3, x3.directionalLength = c3, x3.pointLength = u3, x3.spotLength = d3, x3.rectAreaLength = p3, x3.hemiLength = m3, x3.numDirectionalShadows = f3, x3.numPointShadows = g3, x3.numSpotShadows = v3, r5.version = gr++);
    }, setupView: function(t6, e9) {
      let n9 = 0, i7 = 0, l6 = 0, h4 = 0, c3 = 0;
      const u3 = e9.matrixWorldInverse;
      for (let e10 = 0, d3 = t6.length; e10 < d3; e10++) {
        const d4 = t6[e10];
        if (d4.isDirectionalLight) {
          const t7 = r5.directional[n9];
          t7.direction.setFromMatrixPosition(d4.matrixWorld), s6.setFromMatrixPosition(d4.target.matrixWorld), t7.direction.sub(s6), t7.direction.transformDirection(u3), n9++;
        } else if (d4.isSpotLight) {
          const t7 = r5.spot[l6];
          t7.position.setFromMatrixPosition(d4.matrixWorld), t7.position.applyMatrix4(u3), t7.direction.setFromMatrixPosition(d4.matrixWorld), s6.setFromMatrixPosition(d4.target.matrixWorld), t7.direction.sub(s6), t7.direction.transformDirection(u3), l6++;
        } else if (d4.isRectAreaLight) {
          const t7 = r5.rectArea[h4];
          t7.position.setFromMatrixPosition(d4.matrixWorld), t7.position.applyMatrix4(u3), o7.identity(), a4.copy(d4.matrixWorld), a4.premultiply(u3), o7.extractRotation(a4), t7.halfWidth.set(0.5 * d4.width, 0, 0), t7.halfHeight.set(0, 0.5 * d4.height, 0), t7.halfWidth.applyMatrix4(o7), t7.halfHeight.applyMatrix4(o7), h4++;
        } else if (d4.isPointLight) {
          const t7 = r5.point[i7];
          t7.position.setFromMatrixPosition(d4.matrixWorld), t7.position.applyMatrix4(u3), i7++;
        } else if (d4.isHemisphereLight) {
          const t7 = r5.hemi[c3];
          t7.direction.setFromMatrixPosition(d4.matrixWorld), t7.direction.transformDirection(u3), t7.direction.normalize(), c3++;
        }
      }
    }, state: r5 };
  }
  function xr(t5, e8) {
    const n8 = new yr(t5, e8), i6 = [], r5 = [];
    return { init: function() {
      i6.length = 0, r5.length = 0;
    }, state: { lightsArray: i6, shadowsArray: r5, lights: n8 }, setupLights: function(t6) {
      n8.setup(i6, t6);
    }, setupLightsView: function(t6) {
      n8.setupView(i6, t6);
    }, pushLight: function(t6) {
      i6.push(t6);
    }, pushShadow: function(t6) {
      r5.push(t6);
    } };
  }
  function br(t5, e8) {
    let n8 = /* @__PURE__ */ new WeakMap();
    return { get: function(i6, r5 = 0) {
      let s6;
      return n8.has(i6) === false ? (s6 = new xr(t5, e8), n8.set(i6, [s6])) : r5 >= n8.get(i6).length ? (s6 = new xr(t5, e8), n8.get(i6).push(s6)) : s6 = n8.get(i6)[r5], s6;
    }, dispose: function() {
      n8 = /* @__PURE__ */ new WeakMap();
    } };
  }
  var _r = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.depthPacking = t5.depthPacking, this.map = t5.map, this.alphaMap = t5.alphaMap, this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this;
    }
  };
  _r.prototype.isMeshDepthMaterial = true;
  var wr = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new V2(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.referencePosition.copy(t5.referencePosition), this.nearDistance = t5.nearDistance, this.farDistance = t5.farDistance, this.map = t5.map, this.alphaMap = t5.alphaMap, this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this;
    }
  };
  wr.prototype.isMeshDistanceMaterial = true;
  function Mr(t5, e8, n8) {
    let i6 = new tn();
    const r5 = new g2(), s6 = new g2(), a4 = new U(), o7 = new _r({ depthPacking: 3201 }), l6 = new wr(), h4 = {}, c3 = n8.maxTextureSize, u3 = { 0: 1, 1: 0, 2: 2 }, d3 = new Ve({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new g2() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p3 = d3.clone();
    p3.defines.HORIZONTAL_PASS = 1;
    const m3 = new ye();
    m3.setAttribute("position", new oe(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const f3 = new Fe(m3, d3), v3 = this;
    function y3(n9, i7) {
      const r6 = e8.update(f3);
      d3.defines.VSM_SAMPLES !== n9.blurSamples && (d3.defines.VSM_SAMPLES = n9.blurSamples, p3.defines.VSM_SAMPLES = n9.blurSamples, d3.needsUpdate = true, p3.needsUpdate = true), d3.uniforms.shadow_pass.value = n9.map.texture, d3.uniforms.resolution.value = n9.mapSize, d3.uniforms.radius.value = n9.radius, t5.setRenderTarget(n9.mapPass), t5.clear(), t5.renderBufferDirect(i7, null, r6, d3, f3, null), p3.uniforms.shadow_pass.value = n9.mapPass.texture, p3.uniforms.resolution.value = n9.mapSize, p3.uniforms.radius.value = n9.radius, t5.setRenderTarget(n9.map), t5.clear(), t5.renderBufferDirect(i7, null, r6, p3, f3, null);
    }
    function x3(e9, n9, i7, r6, s7, a5) {
      let c4 = null;
      const d4 = i7.isPointLight === true ? e9.customDistanceMaterial : e9.customDepthMaterial;
      if (c4 = d4 !== void 0 ? d4 : i7.isPointLight === true ? l6 : o7, t5.localClippingEnabled && n9.clipShadows === true && n9.clippingPlanes.length !== 0 || n9.displacementMap && n9.displacementScale !== 0 || n9.alphaMap && n9.alphaTest > 0) {
        const t6 = c4.uuid, e10 = n9.uuid;
        let i8 = h4[t6];
        i8 === void 0 && (i8 = {}, h4[t6] = i8);
        let r7 = i8[e10];
        r7 === void 0 && (r7 = c4.clone(), i8[e10] = r7), c4 = r7;
      }
      return c4.visible = n9.visible, c4.wireframe = n9.wireframe, c4.side = a5 === 3 ? n9.shadowSide !== null ? n9.shadowSide : n9.side : n9.shadowSide !== null ? n9.shadowSide : u3[n9.side], c4.alphaMap = n9.alphaMap, c4.alphaTest = n9.alphaTest, c4.clipShadows = n9.clipShadows, c4.clippingPlanes = n9.clippingPlanes, c4.clipIntersection = n9.clipIntersection, c4.displacementMap = n9.displacementMap, c4.displacementScale = n9.displacementScale, c4.displacementBias = n9.displacementBias, c4.wireframeLinewidth = n9.wireframeLinewidth, c4.linewidth = n9.linewidth, i7.isPointLight === true && c4.isMeshDistanceMaterial === true && (c4.referencePosition.setFromMatrixPosition(i7.matrixWorld), c4.nearDistance = r6, c4.farDistance = s7), c4;
    }
    function b3(n9, r6, s7, a5, o8) {
      if (n9.visible === false)
        return;
      if (n9.layers.test(r6.layers) && (n9.isMesh || n9.isLine || n9.isPoints) && (n9.castShadow || n9.receiveShadow && o8 === 3) && (!n9.frustumCulled || i6.intersectsObject(n9))) {
        n9.modelViewMatrix.multiplyMatrices(s7.matrixWorldInverse, n9.matrixWorld);
        const i7 = e8.update(n9), r7 = n9.material;
        if (Array.isArray(r7)) {
          const e9 = i7.groups;
          for (let l8 = 0, h5 = e9.length; l8 < h5; l8++) {
            const h6 = e9[l8], c4 = r7[h6.materialIndex];
            if (c4 && c4.visible) {
              const e10 = x3(n9, c4, a5, s7.near, s7.far, o8);
              t5.renderBufferDirect(s7, null, i7, e10, n9, h6);
            }
          }
        } else if (r7.visible) {
          const e9 = x3(n9, r7, a5, s7.near, s7.far, o8);
          t5.renderBufferDirect(s7, null, i7, e9, n9, null);
        }
      }
      const l7 = n9.children;
      for (let t6 = 0, e9 = l7.length; t6 < e9; t6++)
        b3(l7[t6], r6, s7, a5, o8);
    }
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e9, n9, o8) {
      if (v3.enabled === false)
        return;
      if (v3.autoUpdate === false && v3.needsUpdate === false)
        return;
      if (e9.length === 0)
        return;
      const l7 = t5.getRenderTarget(), h5 = t5.getActiveCubeFace(), u4 = t5.getActiveMipmapLevel(), d4 = t5.state;
      d4.setBlending(0), d4.buffers.color.setClear(1, 1, 1, 1), d4.buffers.depth.setTest(true), d4.setScissorTest(false);
      for (let l8 = 0, h6 = e9.length; l8 < h6; l8++) {
        const h7 = e9[l8], u5 = h7.shadow;
        if (u5 === void 0) {
          console.warn("THREE.WebGLShadowMap:", h7, "has no shadow.");
          continue;
        }
        if (u5.autoUpdate === false && u5.needsUpdate === false)
          continue;
        r5.copy(u5.mapSize);
        const p4 = u5.getFrameExtents();
        if (r5.multiply(p4), s6.copy(u5.mapSize), (r5.x > c3 || r5.y > c3) && (r5.x > c3 && (s6.x = Math.floor(c3 / p4.x), r5.x = s6.x * p4.x, u5.mapSize.x = s6.x), r5.y > c3 && (s6.y = Math.floor(c3 / p4.y), r5.y = s6.y * p4.y, u5.mapSize.y = s6.y)), u5.map !== null || u5.isPointLightShadow || this.type !== 3 || (u5.map = new k2(r5.x, r5.y), u5.map.texture.name = h7.name + ".shadowMap", u5.mapPass = new k2(r5.x, r5.y), u5.camera.updateProjectionMatrix()), u5.map === null) {
          const t6 = { minFilter: 1003, magFilter: 1003, format: 1023 };
          u5.map = new k2(r5.x, r5.y, t6), u5.map.texture.name = h7.name + ".shadowMap", u5.camera.updateProjectionMatrix();
        }
        t5.setRenderTarget(u5.map), t5.clear();
        const m4 = u5.getViewportCount();
        for (let t6 = 0; t6 < m4; t6++) {
          const e10 = u5.getViewport(t6);
          a4.set(s6.x * e10.x, s6.y * e10.y, s6.x * e10.z, s6.y * e10.w), d4.viewport(a4), u5.updateMatrices(h7, t6), i6 = u5.getFrustum(), b3(n9, o8, u5.camera, h7, this.type);
        }
        u5.isPointLightShadow || this.type !== 3 || y3(u5, o8), u5.needsUpdate = false;
      }
      v3.needsUpdate = false, t5.setRenderTarget(l7, h5, u4);
    };
  }
  function Sr(t5, e8, n8) {
    const i6 = n8.isWebGL2;
    const r5 = new function() {
      let e9 = false;
      const n9 = new U();
      let i7 = null;
      const r6 = new U(0, 0, 0, 0);
      return { setMask: function(n10) {
        i7 === n10 || e9 || (t5.colorMask(n10, n10, n10, n10), i7 = n10);
      }, setLocked: function(t6) {
        e9 = t6;
      }, setClear: function(e10, i8, s7, a5, o8) {
        o8 === true && (e10 *= a5, i8 *= a5, s7 *= a5), n9.set(e10, i8, s7, a5), r6.equals(n9) === false && (t5.clearColor(e10, i8, s7, a5), r6.copy(n9));
      }, reset: function() {
        e9 = false, i7 = null, r6.set(-1, 0, 0, 0);
      } };
    }(), s6 = new function() {
      let e9 = false, n9 = null, i7 = null, r6 = null;
      return { setTest: function(t6) {
        t6 ? B2(2929) : z3(2929);
      }, setMask: function(i8) {
        n9 === i8 || e9 || (t5.depthMask(i8), n9 = i8);
      }, setFunc: function(e10) {
        if (i7 !== e10) {
          if (e10)
            switch (e10) {
              case 0:
                t5.depthFunc(512);
                break;
              case 1:
                t5.depthFunc(519);
                break;
              case 2:
                t5.depthFunc(513);
                break;
              case 3:
              default:
                t5.depthFunc(515);
                break;
              case 4:
                t5.depthFunc(514);
                break;
              case 5:
                t5.depthFunc(518);
                break;
              case 6:
                t5.depthFunc(516);
                break;
              case 7:
                t5.depthFunc(517);
            }
          else
            t5.depthFunc(515);
          i7 = e10;
        }
      }, setLocked: function(t6) {
        e9 = t6;
      }, setClear: function(e10) {
        r6 !== e10 && (t5.clearDepth(e10), r6 = e10);
      }, reset: function() {
        e9 = false, n9 = null, i7 = null, r6 = null;
      } };
    }(), a4 = new function() {
      let e9 = false, n9 = null, i7 = null, r6 = null, s7 = null, a5 = null, o8 = null, l7 = null, h5 = null;
      return { setTest: function(t6) {
        e9 || (t6 ? B2(2960) : z3(2960));
      }, setMask: function(i8) {
        n9 === i8 || e9 || (t5.stencilMask(i8), n9 = i8);
      }, setFunc: function(e10, n10, a6) {
        i7 === e10 && r6 === n10 && s7 === a6 || (t5.stencilFunc(e10, n10, a6), i7 = e10, r6 = n10, s7 = a6);
      }, setOp: function(e10, n10, i8) {
        a5 === e10 && o8 === n10 && l7 === i8 || (t5.stencilOp(e10, n10, i8), a5 = e10, o8 = n10, l7 = i8);
      }, setLocked: function(t6) {
        e9 = t6;
      }, setClear: function(e10) {
        h5 !== e10 && (t5.clearStencil(e10), h5 = e10);
      }, reset: function() {
        e9 = false, n9 = null, i7 = null, r6 = null, s7 = null, a5 = null, o8 = null, l7 = null, h5 = null;
      } };
    }();
    let o7 = {}, l6 = {}, h4 = /* @__PURE__ */ new WeakMap(), c3 = [], u3 = null, d3 = false, p3 = null, m3 = null, f3 = null, g3 = null, v3 = null, y3 = null, x3 = null, b3 = false, _3 = null, w3 = null, M3 = null, S4 = null, T3 = null;
    const E3 = t5.getParameter(35661);
    let A3 = false, R2 = 0;
    const C3 = t5.getParameter(7938);
    C3.indexOf("WebGL") !== -1 ? (R2 = parseFloat(/^WebGL (\d)/.exec(C3)[1]), A3 = R2 >= 1) : C3.indexOf("OpenGL ES") !== -1 && (R2 = parseFloat(/^OpenGL ES (\d)/.exec(C3)[1]), A3 = R2 >= 2);
    let L3 = null, P3 = {};
    const D2 = t5.getParameter(3088), I3 = t5.getParameter(2978), O2 = new U().fromArray(D2), N3 = new U().fromArray(I3);
    function F2(e9, n9, i7) {
      const r6 = new Uint8Array(4), s7 = t5.createTexture();
      t5.bindTexture(e9, s7), t5.texParameteri(e9, 10241, 9728), t5.texParameteri(e9, 10240, 9728);
      for (let e10 = 0; e10 < i7; e10++)
        t5.texImage2D(n9 + e10, 0, 6408, 1, 1, 0, 6408, 5121, r6);
      return s7;
    }
    const k3 = {};
    function B2(e9) {
      o7[e9] !== true && (t5.enable(e9), o7[e9] = true);
    }
    function z3(e9) {
      o7[e9] !== false && (t5.disable(e9), o7[e9] = false);
    }
    k3[3553] = F2(3553, 3553, 1), k3[34067] = F2(34067, 34069, 6), r5.setClear(0, 0, 0, 1), s6.setClear(1), a4.setClear(0), B2(2929), s6.setFunc(3), W2(false), j2(1), B2(2884), G2(0);
    const H3 = { 100: 32774, 101: 32778, 102: 32779 };
    if (i6)
      H3[103] = 32775, H3[104] = 32776;
    else {
      const t6 = e8.get("EXT_blend_minmax");
      t6 !== null && (H3[103] = t6.MIN_EXT, H3[104] = t6.MAX_EXT);
    }
    const V3 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
    function G2(e9, n9, i7, r6, s7, a5, o8, l7) {
      if (e9 !== 0) {
        if (d3 === false && (B2(3042), d3 = true), e9 === 5)
          s7 = s7 || n9, a5 = a5 || i7, o8 = o8 || r6, n9 === m3 && s7 === v3 || (t5.blendEquationSeparate(H3[n9], H3[s7]), m3 = n9, v3 = s7), i7 === f3 && r6 === g3 && a5 === y3 && o8 === x3 || (t5.blendFuncSeparate(V3[i7], V3[r6], V3[a5], V3[o8]), f3 = i7, g3 = r6, y3 = a5, x3 = o8), p3 = e9, b3 = null;
        else if (e9 !== p3 || l7 !== b3) {
          if (m3 === 100 && v3 === 100 || (t5.blendEquation(32774), m3 = 100, v3 = 100), l7)
            switch (e9) {
              case 1:
                t5.blendFuncSeparate(1, 771, 1, 771);
                break;
              case 2:
                t5.blendFunc(1, 1);
                break;
              case 3:
                t5.blendFuncSeparate(0, 769, 0, 1);
                break;
              case 4:
                t5.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e9);
            }
          else
            switch (e9) {
              case 1:
                t5.blendFuncSeparate(770, 771, 1, 771);
                break;
              case 2:
                t5.blendFunc(770, 1);
                break;
              case 3:
                t5.blendFuncSeparate(0, 769, 0, 1);
                break;
              case 4:
                t5.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e9);
            }
          f3 = null, g3 = null, y3 = null, x3 = null, p3 = e9, b3 = l7;
        }
      } else
        d3 === true && (z3(3042), d3 = false);
    }
    function W2(e9) {
      _3 !== e9 && (e9 ? t5.frontFace(2304) : t5.frontFace(2305), _3 = e9);
    }
    function j2(e9) {
      e9 !== 0 ? (B2(2884), e9 !== w3 && (e9 === 1 ? t5.cullFace(1029) : e9 === 2 ? t5.cullFace(1028) : t5.cullFace(1032))) : z3(2884), w3 = e9;
    }
    function q2(e9, n9, i7) {
      e9 ? (B2(32823), S4 === n9 && T3 === i7 || (t5.polygonOffset(n9, i7), S4 = n9, T3 = i7)) : z3(32823);
    }
    function X2(e9) {
      e9 === void 0 && (e9 = 33984 + E3 - 1), L3 !== e9 && (t5.activeTexture(e9), L3 = e9);
    }
    return { buffers: { color: r5, depth: s6, stencil: a4 }, enable: B2, disable: z3, bindFramebuffer: function(e9, n9) {
      return l6[e9] !== n9 && (t5.bindFramebuffer(e9, n9), l6[e9] = n9, i6 && (e9 === 36009 && (l6[36160] = n9), e9 === 36160 && (l6[36009] = n9)), true);
    }, drawBuffers: function(i7, r6) {
      let s7 = c3, a5 = false;
      if (i7)
        if (s7 = h4.get(r6), s7 === void 0 && (s7 = [], h4.set(r6, s7)), i7.isWebGLMultipleRenderTargets) {
          const t6 = i7.texture;
          if (s7.length !== t6.length || s7[0] !== 36064) {
            for (let e9 = 0, n9 = t6.length; e9 < n9; e9++)
              s7[e9] = 36064 + e9;
            s7.length = t6.length, a5 = true;
          }
        } else
          s7[0] !== 36064 && (s7[0] = 36064, a5 = true);
      else
        s7[0] !== 1029 && (s7[0] = 1029, a5 = true);
      a5 && (n8.isWebGL2 ? t5.drawBuffers(s7) : e8.get("WEBGL_draw_buffers").drawBuffersWEBGL(s7));
    }, useProgram: function(e9) {
      return u3 !== e9 && (t5.useProgram(e9), u3 = e9, true);
    }, setBlending: G2, setMaterial: function(t6, e9) {
      t6.side === 2 ? z3(2884) : B2(2884);
      let n9 = t6.side === 1;
      e9 && (n9 = !n9), W2(n9), t6.blending === 1 && t6.transparent === false ? G2(0) : G2(t6.blending, t6.blendEquation, t6.blendSrc, t6.blendDst, t6.blendEquationAlpha, t6.blendSrcAlpha, t6.blendDstAlpha, t6.premultipliedAlpha), s6.setFunc(t6.depthFunc), s6.setTest(t6.depthTest), s6.setMask(t6.depthWrite), r5.setMask(t6.colorWrite);
      const i7 = t6.stencilWrite;
      a4.setTest(i7), i7 && (a4.setMask(t6.stencilWriteMask), a4.setFunc(t6.stencilFunc, t6.stencilRef, t6.stencilFuncMask), a4.setOp(t6.stencilFail, t6.stencilZFail, t6.stencilZPass)), q2(t6.polygonOffset, t6.polygonOffsetFactor, t6.polygonOffsetUnits), t6.alphaToCoverage === true ? B2(32926) : z3(32926);
    }, setFlipSided: W2, setCullFace: j2, setLineWidth: function(e9) {
      e9 !== M3 && (A3 && t5.lineWidth(e9), M3 = e9);
    }, setPolygonOffset: q2, setScissorTest: function(t6) {
      t6 ? B2(3089) : z3(3089);
    }, activeTexture: X2, bindTexture: function(e9, n9) {
      L3 === null && X2();
      let i7 = P3[L3];
      i7 === void 0 && (i7 = { type: void 0, texture: void 0 }, P3[L3] = i7), i7.type === e9 && i7.texture === n9 || (t5.bindTexture(e9, n9 || k3[e9]), i7.type = e9, i7.texture = n9);
    }, unbindTexture: function() {
      const e9 = P3[L3];
      e9 !== void 0 && e9.type !== void 0 && (t5.bindTexture(e9.type, null), e9.type = void 0, e9.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        t5.compressedTexImage2D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texImage2D: function() {
      try {
        t5.texImage2D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texImage3D: function() {
      try {
        t5.texImage3D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texStorage2D: function() {
      try {
        t5.texStorage2D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texStorage3D: function() {
      try {
        t5.texStorage3D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texSubImage2D: function() {
      try {
        t5.texSubImage2D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, texSubImage3D: function() {
      try {
        t5.texSubImage3D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, compressedTexSubImage2D: function() {
      try {
        t5.compressedTexSubImage2D.apply(t5, arguments);
      } catch (t6) {
        console.error("THREE.WebGLState:", t6);
      }
    }, scissor: function(e9) {
      O2.equals(e9) === false && (t5.scissor(e9.x, e9.y, e9.z, e9.w), O2.copy(e9));
    }, viewport: function(e9) {
      N3.equals(e9) === false && (t5.viewport(e9.x, e9.y, e9.z, e9.w), N3.copy(e9));
    }, reset: function() {
      t5.disable(3042), t5.disable(2884), t5.disable(2929), t5.disable(32823), t5.disable(3089), t5.disable(2960), t5.disable(32926), t5.blendEquation(32774), t5.blendFunc(1, 0), t5.blendFuncSeparate(1, 0, 1, 0), t5.colorMask(true, true, true, true), t5.clearColor(0, 0, 0, 0), t5.depthMask(true), t5.depthFunc(513), t5.clearDepth(1), t5.stencilMask(4294967295), t5.stencilFunc(519, 0, 4294967295), t5.stencilOp(7680, 7680, 7680), t5.clearStencil(0), t5.cullFace(1029), t5.frontFace(2305), t5.polygonOffset(0, 0), t5.activeTexture(33984), t5.bindFramebuffer(36160, null), i6 === true && (t5.bindFramebuffer(36009, null), t5.bindFramebuffer(36008, null)), t5.useProgram(null), t5.lineWidth(1), t5.scissor(0, 0, t5.canvas.width, t5.canvas.height), t5.viewport(0, 0, t5.canvas.width, t5.canvas.height), o7 = {}, L3 = null, P3 = {}, l6 = {}, h4 = /* @__PURE__ */ new WeakMap(), c3 = [], u3 = null, d3 = false, p3 = null, m3 = null, f3 = null, g3 = null, v3 = null, y3 = null, x3 = null, b3 = false, _3 = null, w3 = null, M3 = null, S4 = null, T3 = null, O2.set(0, 0, t5.canvas.width, t5.canvas.height), N3.set(0, 0, t5.canvas.width, t5.canvas.height), r5.reset(), s6.reset(), a4.reset();
    } };
  }
  function Tr(t5, e8, n8, i6, r5, s6, a4) {
    const o7 = r5.isWebGL2, l6 = r5.maxTextures, h4 = r5.maxCubemapSize, c3 = r5.maxTextureSize, u3 = r5.maxSamples, p3 = e8.has("WEBGL_multisampled_render_to_texture") ? e8.get("WEBGL_multisampled_render_to_texture") : null, f3 = /OculusBrowser/g.test(navigator.userAgent), g3 = /* @__PURE__ */ new WeakMap();
    let v3;
    const y3 = /* @__PURE__ */ new WeakMap();
    let b3 = false;
    try {
      b3 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (t6) {
    }
    function _3(t6, e9) {
      return b3 ? new OffscreenCanvas(t6, e9) : x2("canvas");
    }
    function w3(t6, e9, n9, i7) {
      let r6 = 1;
      if ((t6.width > i7 || t6.height > i7) && (r6 = i7 / Math.max(t6.width, t6.height)), r6 < 1 || e9 === true) {
        if (typeof HTMLImageElement != "undefined" && t6 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t6 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t6 instanceof ImageBitmap) {
          const i8 = e9 ? m2 : Math.floor, s7 = i8(r6 * t6.width), a5 = i8(r6 * t6.height);
          v3 === void 0 && (v3 = _3(s7, a5));
          const o8 = n9 ? _3(s7, a5) : v3;
          o8.width = s7, o8.height = a5;
          return o8.getContext("2d").drawImage(t6, 0, 0, s7, a5), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t6.width + "x" + t6.height + ") to (" + s7 + "x" + a5 + ")."), o8;
        }
        return "data" in t6 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t6.width + "x" + t6.height + ")."), t6;
      }
      return t6;
    }
    function M3(t6) {
      return d2(t6.width) && d2(t6.height);
    }
    function S4(t6, e9) {
      return t6.generateMipmaps && e9 && t6.minFilter !== 1003 && t6.minFilter !== 1006;
    }
    function T3(e9) {
      t5.generateMipmap(e9);
    }
    function E3(n9, i7, r6, s7, a5 = false) {
      if (o7 === false)
        return i7;
      if (n9 !== null) {
        if (t5[n9] !== void 0)
          return t5[n9];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n9 + "'");
      }
      let l7 = i7;
      return i7 === 6403 && (r6 === 5126 && (l7 = 33326), r6 === 5131 && (l7 = 33325), r6 === 5121 && (l7 = 33321)), i7 === 33319 && (r6 === 5126 && (l7 = 33328), r6 === 5131 && (l7 = 33327), r6 === 5121 && (l7 = 33323)), i7 === 6408 && (r6 === 5126 && (l7 = 34836), r6 === 5131 && (l7 = 34842), r6 === 5121 && (l7 = s7 === 3001 && a5 === false ? 35907 : 32856), r6 === 32819 && (l7 = 32854), r6 === 32820 && (l7 = 32855)), l7 !== 33325 && l7 !== 33326 && l7 !== 33327 && l7 !== 33328 && l7 !== 34842 && l7 !== 34836 || e8.get("EXT_color_buffer_float"), l7;
    }
    function A3(t6, e9, n9) {
      return S4(t6, n9) === true || t6.isFramebufferTexture && t6.minFilter !== 1003 && t6.minFilter !== 1006 ? Math.log2(Math.max(e9.width, e9.height)) + 1 : t6.mipmaps !== void 0 && t6.mipmaps.length > 0 ? t6.mipmaps.length : t6.isCompressedTexture && Array.isArray(t6.image) ? e9.mipmaps.length : 1;
    }
    function R2(t6) {
      return t6 === 1003 || t6 === 1004 || t6 === 1005 ? 9728 : 9729;
    }
    function C3(t6) {
      const e9 = t6.target;
      e9.removeEventListener("dispose", C3), function(t7) {
        const e10 = i6.get(t7);
        if (e10.__webglInit === void 0)
          return;
        const n9 = t7.source, r6 = y3.get(n9);
        if (r6) {
          const i7 = r6[e10.__cacheKey];
          i7.usedTimes--, i7.usedTimes === 0 && P3(t7), Object.keys(r6).length === 0 && y3.delete(n9);
        }
        i6.remove(t7);
      }(e9), e9.isVideoTexture && g3.delete(e9);
    }
    function L3(e9) {
      const n9 = e9.target;
      n9.removeEventListener("dispose", L3), function(e10) {
        const n10 = e10.texture, r6 = i6.get(e10), s7 = i6.get(n10);
        s7.__webglTexture !== void 0 && (t5.deleteTexture(s7.__webglTexture), a4.memory.textures--);
        e10.depthTexture && e10.depthTexture.dispose();
        if (e10.isWebGLCubeRenderTarget)
          for (let e11 = 0; e11 < 6; e11++)
            t5.deleteFramebuffer(r6.__webglFramebuffer[e11]), r6.__webglDepthbuffer && t5.deleteRenderbuffer(r6.__webglDepthbuffer[e11]);
        else
          t5.deleteFramebuffer(r6.__webglFramebuffer), r6.__webglDepthbuffer && t5.deleteRenderbuffer(r6.__webglDepthbuffer), r6.__webglMultisampledFramebuffer && t5.deleteFramebuffer(r6.__webglMultisampledFramebuffer), r6.__webglColorRenderbuffer && t5.deleteRenderbuffer(r6.__webglColorRenderbuffer), r6.__webglDepthRenderbuffer && t5.deleteRenderbuffer(r6.__webglDepthRenderbuffer);
        if (e10.isWebGLMultipleRenderTargets)
          for (let e11 = 0, r7 = n10.length; e11 < r7; e11++) {
            const r8 = i6.get(n10[e11]);
            r8.__webglTexture && (t5.deleteTexture(r8.__webglTexture), a4.memory.textures--), i6.remove(n10[e11]);
          }
        i6.remove(n10), i6.remove(e10);
      }(n9);
    }
    function P3(e9) {
      const n9 = i6.get(e9);
      t5.deleteTexture(n9.__webglTexture);
      const r6 = e9.source;
      delete y3.get(r6)[n9.__cacheKey], a4.memory.textures--;
    }
    let I3 = 0;
    function O2(t6, e9) {
      const r6 = i6.get(t6);
      if (t6.isVideoTexture && function(t7) {
        const e10 = a4.render.frame;
        g3.get(t7) !== e10 && (g3.set(t7, e10), t7.update());
      }(t6), t6.isRenderTargetTexture === false && t6.version > 0 && r6.__version !== t6.version) {
        const n9 = t6.image;
        if (n9 === null)
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else {
          if (n9.complete !== false)
            return void B2(r6, t6, e9);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      n8.activeTexture(33984 + e9), n8.bindTexture(3553, r6.__webglTexture);
    }
    const N3 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, F2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
    function U2(n9, s7, a5) {
      if (a5 ? (t5.texParameteri(n9, 10242, N3[s7.wrapS]), t5.texParameteri(n9, 10243, N3[s7.wrapT]), n9 !== 32879 && n9 !== 35866 || t5.texParameteri(n9, 32882, N3[s7.wrapR]), t5.texParameteri(n9, 10240, F2[s7.magFilter]), t5.texParameteri(n9, 10241, F2[s7.minFilter])) : (t5.texParameteri(n9, 10242, 33071), t5.texParameteri(n9, 10243, 33071), n9 !== 32879 && n9 !== 35866 || t5.texParameteri(n9, 32882, 33071), s7.wrapS === 1001 && s7.wrapT === 1001 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t5.texParameteri(n9, 10240, R2(s7.magFilter)), t5.texParameteri(n9, 10241, R2(s7.minFilter)), s7.minFilter !== 1003 && s7.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e8.has("EXT_texture_filter_anisotropic") === true) {
        const a6 = e8.get("EXT_texture_filter_anisotropic");
        if (s7.type === 1015 && e8.has("OES_texture_float_linear") === false)
          return;
        if (o7 === false && s7.type === 1016 && e8.has("OES_texture_half_float_linear") === false)
          return;
        (s7.anisotropy > 1 || i6.get(s7).__currentAnisotropy) && (t5.texParameterf(n9, a6.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s7.anisotropy, r5.getMaxAnisotropy())), i6.get(s7).__currentAnisotropy = s7.anisotropy);
      }
    }
    function k3(e9, n9) {
      let i7 = false;
      e9.__webglInit === void 0 && (e9.__webglInit = true, n9.addEventListener("dispose", C3));
      const r6 = n9.source;
      let s7 = y3.get(r6);
      s7 === void 0 && (s7 = {}, y3.set(r6, s7));
      const o8 = function(t6) {
        const e10 = [];
        return e10.push(t6.wrapS), e10.push(t6.wrapT), e10.push(t6.magFilter), e10.push(t6.minFilter), e10.push(t6.anisotropy), e10.push(t6.internalFormat), e10.push(t6.format), e10.push(t6.type), e10.push(t6.generateMipmaps), e10.push(t6.premultiplyAlpha), e10.push(t6.flipY), e10.push(t6.unpackAlignment), e10.push(t6.encoding), e10.join();
      }(n9);
      if (o8 !== e9.__cacheKey) {
        s7[o8] === void 0 && (s7[o8] = { texture: t5.createTexture(), usedTimes: 0 }, a4.memory.textures++, i7 = true), s7[o8].usedTimes++;
        const r7 = s7[e9.__cacheKey];
        r7 !== void 0 && (s7[e9.__cacheKey].usedTimes--, r7.usedTimes === 0 && P3(n9)), e9.__cacheKey = o8, e9.__webglTexture = s7[o8].texture;
      }
      return i7;
    }
    function B2(e9, i7, r6) {
      let a5 = 3553;
      i7.isDataArrayTexture && (a5 = 35866), i7.isData3DTexture && (a5 = 32879);
      const l7 = k3(e9, i7), h5 = i7.source;
      if (n8.activeTexture(33984 + r6), n8.bindTexture(a5, e9.__webglTexture), h5.version !== h5.__currentVersion || l7 === true) {
        t5.pixelStorei(37440, i7.flipY), t5.pixelStorei(37441, i7.premultiplyAlpha), t5.pixelStorei(3317, i7.unpackAlignment), t5.pixelStorei(37443, 0);
        const r7 = function(t6) {
          return !o7 && (t6.wrapS !== 1001 || t6.wrapT !== 1001 || t6.minFilter !== 1003 && t6.minFilter !== 1006);
        }(i7) && M3(i7.image) === false;
        let l8 = w3(i7.image, r7, false, c3);
        l8 = j2(i7, l8);
        const u4 = M3(l8) || o7, d3 = s6.convert(i7.format, i7.encoding);
        let p4, m3 = s6.convert(i7.type), f4 = E3(i7.internalFormat, d3, m3, i7.encoding, i7.isVideoTexture);
        U2(a5, i7, u4);
        const g4 = i7.mipmaps, v4 = o7 && i7.isVideoTexture !== true, y4 = e9.__version === void 0, x3 = A3(i7, l8, u4);
        if (i7.isDepthTexture)
          f4 = 6402, o7 ? f4 = i7.type === 1015 ? 36012 : i7.type === 1014 ? 33190 : i7.type === 1020 ? 35056 : 33189 : i7.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i7.format === 1026 && f4 === 6402 && i7.type !== 1012 && i7.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i7.type = 1012, m3 = s6.convert(i7.type)), i7.format === 1027 && f4 === 6402 && (f4 = 34041, i7.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i7.type = 1020, m3 = s6.convert(i7.type))), v4 && y4 ? n8.texStorage2D(3553, 1, f4, l8.width, l8.height) : n8.texImage2D(3553, 0, f4, l8.width, l8.height, 0, d3, m3, null);
        else if (i7.isDataTexture)
          if (g4.length > 0 && u4) {
            v4 && y4 && n8.texStorage2D(3553, x3, f4, g4[0].width, g4[0].height);
            for (let t6 = 0, e10 = g4.length; t6 < e10; t6++)
              p4 = g4[t6], v4 ? n8.texSubImage2D(3553, t6, 0, 0, p4.width, p4.height, d3, m3, p4.data) : n8.texImage2D(3553, t6, f4, p4.width, p4.height, 0, d3, m3, p4.data);
            i7.generateMipmaps = false;
          } else
            v4 ? (y4 && n8.texStorage2D(3553, x3, f4, l8.width, l8.height), n8.texSubImage2D(3553, 0, 0, 0, l8.width, l8.height, d3, m3, l8.data)) : n8.texImage2D(3553, 0, f4, l8.width, l8.height, 0, d3, m3, l8.data);
        else if (i7.isCompressedTexture) {
          v4 && y4 && n8.texStorage2D(3553, x3, f4, g4[0].width, g4[0].height);
          for (let t6 = 0, e10 = g4.length; t6 < e10; t6++)
            p4 = g4[t6], i7.format !== 1023 ? d3 !== null ? v4 ? n8.compressedTexSubImage2D(3553, t6, 0, 0, p4.width, p4.height, d3, p4.data) : n8.compressedTexImage2D(3553, t6, f4, p4.width, p4.height, 0, p4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v4 ? n8.texSubImage2D(3553, t6, 0, 0, p4.width, p4.height, d3, m3, p4.data) : n8.texImage2D(3553, t6, f4, p4.width, p4.height, 0, d3, m3, p4.data);
        } else if (i7.isDataArrayTexture)
          v4 ? (y4 && n8.texStorage3D(35866, x3, f4, l8.width, l8.height, l8.depth), n8.texSubImage3D(35866, 0, 0, 0, 0, l8.width, l8.height, l8.depth, d3, m3, l8.data)) : n8.texImage3D(35866, 0, f4, l8.width, l8.height, l8.depth, 0, d3, m3, l8.data);
        else if (i7.isData3DTexture)
          v4 ? (y4 && n8.texStorage3D(32879, x3, f4, l8.width, l8.height, l8.depth), n8.texSubImage3D(32879, 0, 0, 0, 0, l8.width, l8.height, l8.depth, d3, m3, l8.data)) : n8.texImage3D(32879, 0, f4, l8.width, l8.height, l8.depth, 0, d3, m3, l8.data);
        else if (i7.isFramebufferTexture)
          v4 && y4 ? n8.texStorage2D(3553, x3, f4, l8.width, l8.height) : n8.texImage2D(3553, 0, f4, l8.width, l8.height, 0, d3, m3, null);
        else if (g4.length > 0 && u4) {
          v4 && y4 && n8.texStorage2D(3553, x3, f4, g4[0].width, g4[0].height);
          for (let t6 = 0, e10 = g4.length; t6 < e10; t6++)
            p4 = g4[t6], v4 ? n8.texSubImage2D(3553, t6, 0, 0, d3, m3, p4) : n8.texImage2D(3553, t6, f4, d3, m3, p4);
          i7.generateMipmaps = false;
        } else
          v4 ? (y4 && n8.texStorage2D(3553, x3, f4, l8.width, l8.height), n8.texSubImage2D(3553, 0, 0, 0, d3, m3, l8)) : n8.texImage2D(3553, 0, f4, d3, m3, l8);
        S4(i7, u4) && T3(a5), h5.__currentVersion = h5.version, i7.onUpdate && i7.onUpdate(i7);
      }
      e9.__version = i7.version;
    }
    function z3(e9, r6, a5, o8, l7) {
      const h5 = s6.convert(a5.format, a5.encoding), c4 = s6.convert(a5.type), u4 = E3(a5.internalFormat, h5, c4, a5.encoding);
      i6.get(r6).__hasExternalTextures || (l7 === 32879 || l7 === 35866 ? n8.texImage3D(l7, 0, u4, r6.width, r6.height, r6.depth, 0, h5, c4, null) : n8.texImage2D(l7, 0, u4, r6.width, r6.height, 0, h5, c4, null)), n8.bindFramebuffer(36160, e9), W2(r6) ? p3.framebufferTexture2DMultisampleEXT(36160, o8, l7, i6.get(a5).__webglTexture, 0, G2(r6)) : t5.framebufferTexture2D(36160, o8, l7, i6.get(a5).__webglTexture, 0), n8.bindFramebuffer(36160, null);
    }
    function H3(e9, n9, i7) {
      if (t5.bindRenderbuffer(36161, e9), n9.depthBuffer && !n9.stencilBuffer) {
        let r6 = 33189;
        if (i7 || W2(n9)) {
          const e10 = n9.depthTexture;
          e10 && e10.isDepthTexture && (e10.type === 1015 ? r6 = 36012 : e10.type === 1014 && (r6 = 33190));
          const i8 = G2(n9);
          W2(n9) ? p3.renderbufferStorageMultisampleEXT(36161, i8, r6, n9.width, n9.height) : t5.renderbufferStorageMultisample(36161, i8, r6, n9.width, n9.height);
        } else
          t5.renderbufferStorage(36161, r6, n9.width, n9.height);
        t5.framebufferRenderbuffer(36160, 36096, 36161, e9);
      } else if (n9.depthBuffer && n9.stencilBuffer) {
        const r6 = G2(n9);
        i7 && W2(n9) === false ? t5.renderbufferStorageMultisample(36161, r6, 35056, n9.width, n9.height) : W2(n9) ? p3.renderbufferStorageMultisampleEXT(36161, r6, 35056, n9.width, n9.height) : t5.renderbufferStorage(36161, 34041, n9.width, n9.height), t5.framebufferRenderbuffer(36160, 33306, 36161, e9);
      } else {
        const e10 = n9.isWebGLMultipleRenderTargets === true ? n9.texture[0] : n9.texture, r6 = s6.convert(e10.format, e10.encoding), a5 = s6.convert(e10.type), o8 = E3(e10.internalFormat, r6, a5, e10.encoding), l7 = G2(n9);
        i7 && W2(n9) === false ? t5.renderbufferStorageMultisample(36161, l7, o8, n9.width, n9.height) : W2(n9) ? p3.renderbufferStorageMultisampleEXT(36161, l7, o8, n9.width, n9.height) : t5.renderbufferStorage(36161, o8, n9.width, n9.height);
      }
      t5.bindRenderbuffer(36161, null);
    }
    function V3(e9) {
      const r6 = i6.get(e9), s7 = e9.isWebGLCubeRenderTarget === true;
      if (e9.depthTexture && !r6.__autoAllocateDepthBuffer) {
        if (s7)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(e10, r7) {
          if (r7 && r7.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (n8.bindFramebuffer(36160, e10), !r7.depthTexture || !r7.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          i6.get(r7.depthTexture).__webglTexture && r7.depthTexture.image.width === r7.width && r7.depthTexture.image.height === r7.height || (r7.depthTexture.image.width = r7.width, r7.depthTexture.image.height = r7.height, r7.depthTexture.needsUpdate = true), O2(r7.depthTexture, 0);
          const s8 = i6.get(r7.depthTexture).__webglTexture, a5 = G2(r7);
          if (r7.depthTexture.format === 1026)
            W2(r7) ? p3.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s8, 0, a5) : t5.framebufferTexture2D(36160, 36096, 3553, s8, 0);
          else {
            if (r7.depthTexture.format !== 1027)
              throw new Error("Unknown depthTexture format");
            W2(r7) ? p3.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s8, 0, a5) : t5.framebufferTexture2D(36160, 33306, 3553, s8, 0);
          }
        }(r6.__webglFramebuffer, e9);
      } else if (s7) {
        r6.__webglDepthbuffer = [];
        for (let i7 = 0; i7 < 6; i7++)
          n8.bindFramebuffer(36160, r6.__webglFramebuffer[i7]), r6.__webglDepthbuffer[i7] = t5.createRenderbuffer(), H3(r6.__webglDepthbuffer[i7], e9, false);
      } else
        n8.bindFramebuffer(36160, r6.__webglFramebuffer), r6.__webglDepthbuffer = t5.createRenderbuffer(), H3(r6.__webglDepthbuffer, e9, false);
      n8.bindFramebuffer(36160, null);
    }
    function G2(t6) {
      return Math.min(u3, t6.samples);
    }
    function W2(t6) {
      const n9 = i6.get(t6);
      return o7 && t6.samples > 0 && e8.has("WEBGL_multisampled_render_to_texture") === true && n9.__useRenderToTexture !== false;
    }
    function j2(t6, n9) {
      const i7 = t6.encoding, r6 = t6.format, s7 = t6.type;
      return t6.isCompressedTexture === true || t6.isVideoTexture === true || t6.format === 1035 || i7 !== 3e3 && (i7 === 3001 ? o7 === false ? e8.has("EXT_sRGB") === true && r6 === 1023 ? (t6.format = 1035, t6.minFilter = 1006, t6.generateMipmaps = false) : n9 = D.sRGBToLinear(n9) : r6 === 1023 && s7 === 1009 || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i7)), n9;
    }
    this.allocateTextureUnit = function() {
      const t6 = I3;
      return t6 >= l6 && console.warn("THREE.WebGLTextures: Trying to use " + t6 + " texture units while this GPU supports only " + l6), I3 += 1, t6;
    }, this.resetTextureUnits = function() {
      I3 = 0;
    }, this.setTexture2D = O2, this.setTexture2DArray = function(t6, e9) {
      const r6 = i6.get(t6);
      t6.version > 0 && r6.__version !== t6.version ? B2(r6, t6, e9) : (n8.activeTexture(33984 + e9), n8.bindTexture(35866, r6.__webglTexture));
    }, this.setTexture3D = function(t6, e9) {
      const r6 = i6.get(t6);
      t6.version > 0 && r6.__version !== t6.version ? B2(r6, t6, e9) : (n8.activeTexture(33984 + e9), n8.bindTexture(32879, r6.__webglTexture));
    }, this.setTextureCube = function(e9, r6) {
      const a5 = i6.get(e9);
      e9.version > 0 && a5.__version !== e9.version ? function(e10, i7, r7) {
        if (i7.image.length !== 6)
          return;
        const a6 = k3(e10, i7), l7 = i7.source;
        if (n8.activeTexture(33984 + r7), n8.bindTexture(34067, e10.__webglTexture), l7.version !== l7.__currentVersion || a6 === true) {
          t5.pixelStorei(37440, i7.flipY), t5.pixelStorei(37441, i7.premultiplyAlpha), t5.pixelStorei(3317, i7.unpackAlignment), t5.pixelStorei(37443, 0);
          const r8 = i7.isCompressedTexture || i7.image[0].isCompressedTexture, a7 = i7.image[0] && i7.image[0].isDataTexture, c4 = [];
          for (let t6 = 0; t6 < 6; t6++)
            c4[t6] = r8 || a7 ? a7 ? i7.image[t6].image : i7.image[t6] : w3(i7.image[t6], false, true, h4), c4[t6] = j2(i7, c4[t6]);
          const u4 = c4[0], d3 = M3(u4) || o7, p4 = s6.convert(i7.format, i7.encoding), m3 = s6.convert(i7.type), f4 = E3(i7.internalFormat, p4, m3, i7.encoding), g4 = o7 && i7.isVideoTexture !== true, v4 = e10.__version === void 0;
          let y4, x3 = A3(i7, u4, d3);
          if (U2(34067, i7, d3), r8) {
            g4 && v4 && n8.texStorage2D(34067, x3, f4, u4.width, u4.height);
            for (let t6 = 0; t6 < 6; t6++) {
              y4 = c4[t6].mipmaps;
              for (let e11 = 0; e11 < y4.length; e11++) {
                const r9 = y4[e11];
                i7.format !== 1023 ? p4 !== null ? g4 ? n8.compressedTexSubImage2D(34069 + t6, e11, 0, 0, r9.width, r9.height, p4, r9.data) : n8.compressedTexImage2D(34069 + t6, e11, f4, r9.width, r9.height, 0, r9.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g4 ? n8.texSubImage2D(34069 + t6, e11, 0, 0, r9.width, r9.height, p4, m3, r9.data) : n8.texImage2D(34069 + t6, e11, f4, r9.width, r9.height, 0, p4, m3, r9.data);
              }
            }
          } else {
            y4 = i7.mipmaps, g4 && v4 && (y4.length > 0 && x3++, n8.texStorage2D(34067, x3, f4, c4[0].width, c4[0].height));
            for (let t6 = 0; t6 < 6; t6++)
              if (a7) {
                g4 ? n8.texSubImage2D(34069 + t6, 0, 0, 0, c4[t6].width, c4[t6].height, p4, m3, c4[t6].data) : n8.texImage2D(34069 + t6, 0, f4, c4[t6].width, c4[t6].height, 0, p4, m3, c4[t6].data);
                for (let e11 = 0; e11 < y4.length; e11++) {
                  const i8 = y4[e11].image[t6].image;
                  g4 ? n8.texSubImage2D(34069 + t6, e11 + 1, 0, 0, i8.width, i8.height, p4, m3, i8.data) : n8.texImage2D(34069 + t6, e11 + 1, f4, i8.width, i8.height, 0, p4, m3, i8.data);
                }
              } else {
                g4 ? n8.texSubImage2D(34069 + t6, 0, 0, 0, p4, m3, c4[t6]) : n8.texImage2D(34069 + t6, 0, f4, p4, m3, c4[t6]);
                for (let e11 = 0; e11 < y4.length; e11++) {
                  const i8 = y4[e11];
                  g4 ? n8.texSubImage2D(34069 + t6, e11 + 1, 0, 0, p4, m3, i8.image[t6]) : n8.texImage2D(34069 + t6, e11 + 1, f4, p4, m3, i8.image[t6]);
                }
              }
          }
          S4(i7, d3) && T3(34067), l7.__currentVersion = l7.version, i7.onUpdate && i7.onUpdate(i7);
        }
        e10.__version = i7.version;
      }(a5, e9, r6) : (n8.activeTexture(33984 + r6), n8.bindTexture(34067, a5.__webglTexture));
    }, this.rebindTextures = function(t6, e9, n9) {
      const r6 = i6.get(t6);
      e9 !== void 0 && z3(r6.__webglFramebuffer, t6, t6.texture, 36064, 3553), n9 !== void 0 && V3(t6);
    }, this.setupRenderTarget = function(e9) {
      const l7 = e9.texture, h5 = i6.get(e9), c4 = i6.get(l7);
      e9.addEventListener("dispose", L3), e9.isWebGLMultipleRenderTargets !== true && (c4.__webglTexture === void 0 && (c4.__webglTexture = t5.createTexture()), c4.__version = l7.version, a4.memory.textures++);
      const u4 = e9.isWebGLCubeRenderTarget === true, d3 = e9.isWebGLMultipleRenderTargets === true, p4 = M3(e9) || o7;
      if (u4) {
        h5.__webglFramebuffer = [];
        for (let e10 = 0; e10 < 6; e10++)
          h5.__webglFramebuffer[e10] = t5.createFramebuffer();
      } else if (h5.__webglFramebuffer = t5.createFramebuffer(), d3)
        if (r5.drawBuffers) {
          const n9 = e9.texture;
          for (let e10 = 0, r6 = n9.length; e10 < r6; e10++) {
            const r7 = i6.get(n9[e10]);
            r7.__webglTexture === void 0 && (r7.__webglTexture = t5.createTexture(), a4.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      else if (o7 && e9.samples > 0 && W2(e9) === false) {
        h5.__webglMultisampledFramebuffer = t5.createFramebuffer(), h5.__webglColorRenderbuffer = t5.createRenderbuffer(), t5.bindRenderbuffer(36161, h5.__webglColorRenderbuffer);
        const i7 = s6.convert(l7.format, l7.encoding), r6 = s6.convert(l7.type), a5 = E3(l7.internalFormat, i7, r6, l7.encoding), o8 = G2(e9);
        t5.renderbufferStorageMultisample(36161, o8, a5, e9.width, e9.height), n8.bindFramebuffer(36160, h5.__webglMultisampledFramebuffer), t5.framebufferRenderbuffer(36160, 36064, 36161, h5.__webglColorRenderbuffer), t5.bindRenderbuffer(36161, null), e9.depthBuffer && (h5.__webglDepthRenderbuffer = t5.createRenderbuffer(), H3(h5.__webglDepthRenderbuffer, e9, true)), n8.bindFramebuffer(36160, null);
      }
      if (u4) {
        n8.bindTexture(34067, c4.__webglTexture), U2(34067, l7, p4);
        for (let t6 = 0; t6 < 6; t6++)
          z3(h5.__webglFramebuffer[t6], e9, l7, 36064, 34069 + t6);
        S4(l7, p4) && T3(34067), n8.unbindTexture();
      } else if (d3) {
        const t6 = e9.texture;
        for (let r6 = 0, s7 = t6.length; r6 < s7; r6++) {
          const s8 = t6[r6], a5 = i6.get(s8);
          n8.bindTexture(3553, a5.__webglTexture), U2(3553, s8, p4), z3(h5.__webglFramebuffer, e9, s8, 36064 + r6, 3553), S4(s8, p4) && T3(3553);
        }
        n8.unbindTexture();
      } else {
        let t6 = 3553;
        (e9.isWebGL3DRenderTarget || e9.isWebGLArrayRenderTarget) && (o7 ? t6 = e9.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n8.bindTexture(t6, c4.__webglTexture), U2(t6, l7, p4), z3(h5.__webglFramebuffer, e9, l7, 36064, t6), S4(l7, p4) && T3(t6), n8.unbindTexture();
      }
      e9.depthBuffer && V3(e9);
    }, this.updateRenderTargetMipmap = function(t6) {
      const e9 = M3(t6) || o7, r6 = t6.isWebGLMultipleRenderTargets === true ? t6.texture : [t6.texture];
      for (let s7 = 0, a5 = r6.length; s7 < a5; s7++) {
        const a6 = r6[s7];
        if (S4(a6, e9)) {
          const e10 = t6.isWebGLCubeRenderTarget ? 34067 : 3553, r7 = i6.get(a6).__webglTexture;
          n8.bindTexture(e10, r7), T3(e10), n8.unbindTexture();
        }
      }
    }, this.updateMultisampleRenderTarget = function(e9) {
      if (o7 && e9.samples > 0 && W2(e9) === false) {
        const r6 = e9.width, s7 = e9.height;
        let a5 = 16384;
        const o8 = [36064], l7 = e9.stencilBuffer ? 33306 : 36096;
        e9.depthBuffer && o8.push(l7);
        const h5 = i6.get(e9), c4 = h5.__ignoreDepthValues !== void 0 && h5.__ignoreDepthValues;
        c4 === false && (e9.depthBuffer && (a5 |= 256), e9.stencilBuffer && (a5 |= 1024)), n8.bindFramebuffer(36008, h5.__webglMultisampledFramebuffer), n8.bindFramebuffer(36009, h5.__webglFramebuffer), c4 === true && (t5.invalidateFramebuffer(36008, [l7]), t5.invalidateFramebuffer(36009, [l7])), t5.blitFramebuffer(0, 0, r6, s7, 0, 0, r6, s7, a5, 9728), f3 && t5.invalidateFramebuffer(36008, o8), n8.bindFramebuffer(36008, null), n8.bindFramebuffer(36009, h5.__webglMultisampledFramebuffer);
      }
    }, this.setupDepthRenderbuffer = V3, this.setupFrameBufferTexture = z3, this.useMultisampledRTT = W2;
  }
  function Er(t5, e8, n8) {
    const i6 = n8.isWebGL2;
    return { convert: function(t6, n9 = null) {
      let r5;
      if (t6 === 1009)
        return 5121;
      if (t6 === 1017)
        return 32819;
      if (t6 === 1018)
        return 32820;
      if (t6 === 1010)
        return 5120;
      if (t6 === 1011)
        return 5122;
      if (t6 === 1012)
        return 5123;
      if (t6 === 1013)
        return 5124;
      if (t6 === 1014)
        return 5125;
      if (t6 === 1015)
        return 5126;
      if (t6 === 1016)
        return i6 ? 5131 : (r5 = e8.get("OES_texture_half_float"), r5 !== null ? r5.HALF_FLOAT_OES : null);
      if (t6 === 1021)
        return 6406;
      if (t6 === 1023)
        return 6408;
      if (t6 === 1024)
        return 6409;
      if (t6 === 1025)
        return 6410;
      if (t6 === 1026)
        return 6402;
      if (t6 === 1027)
        return 34041;
      if (t6 === 1028)
        return 6403;
      if (t6 === 1022)
        return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
      if (t6 === 1035)
        return r5 = e8.get("EXT_sRGB"), r5 !== null ? r5.SRGB_ALPHA_EXT : null;
      if (t6 === 1029)
        return 36244;
      if (t6 === 1030)
        return 33319;
      if (t6 === 1031)
        return 33320;
      if (t6 === 1033)
        return 36249;
      if (t6 === 33776 || t6 === 33777 || t6 === 33778 || t6 === 33779)
        if (n9 === 3001) {
          if (r5 = e8.get("WEBGL_compressed_texture_s3tc_srgb"), r5 === null)
            return null;
          if (t6 === 33776)
            return r5.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (t6 === 33777)
            return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (t6 === 33778)
            return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (t6 === 33779)
            return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          if (r5 = e8.get("WEBGL_compressed_texture_s3tc"), r5 === null)
            return null;
          if (t6 === 33776)
            return r5.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (t6 === 33777)
            return r5.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (t6 === 33778)
            return r5.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (t6 === 33779)
            return r5.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      if (t6 === 35840 || t6 === 35841 || t6 === 35842 || t6 === 35843) {
        if (r5 = e8.get("WEBGL_compressed_texture_pvrtc"), r5 === null)
          return null;
        if (t6 === 35840)
          return r5.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (t6 === 35841)
          return r5.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (t6 === 35842)
          return r5.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (t6 === 35843)
          return r5.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (t6 === 36196)
        return r5 = e8.get("WEBGL_compressed_texture_etc1"), r5 !== null ? r5.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (t6 === 37492 || t6 === 37496) {
        if (r5 = e8.get("WEBGL_compressed_texture_etc"), r5 === null)
          return null;
        if (t6 === 37492)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ETC2 : r5.COMPRESSED_RGB8_ETC2;
        if (t6 === 37496)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r5.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (t6 === 37808 || t6 === 37809 || t6 === 37810 || t6 === 37811 || t6 === 37812 || t6 === 37813 || t6 === 37814 || t6 === 37815 || t6 === 37816 || t6 === 37817 || t6 === 37818 || t6 === 37819 || t6 === 37820 || t6 === 37821) {
        if (r5 = e8.get("WEBGL_compressed_texture_astc"), r5 === null)
          return null;
        if (t6 === 37808)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r5.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (t6 === 37809)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r5.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (t6 === 37810)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r5.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (t6 === 37811)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r5.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (t6 === 37812)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r5.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (t6 === 37813)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r5.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (t6 === 37814)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r5.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (t6 === 37815)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r5.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (t6 === 37816)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r5.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (t6 === 37817)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r5.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (t6 === 37818)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r5.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (t6 === 37819)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r5.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (t6 === 37820)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r5.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (t6 === 37821)
          return n9 === 3001 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r5.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (t6 === 36492) {
        if (r5 = e8.get("EXT_texture_compression_bptc"), r5 === null)
          return null;
        if (t6 === 36492)
          return n9 === 3001 ? r5.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r5.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      }
      return t6 === 1020 ? i6 ? 34042 : (r5 = e8.get("WEBGL_depth_texture"), r5 !== null ? r5.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    } };
  }
  var Ar = class extends We {
    constructor(t5 = []) {
      super(), this.cameras = t5;
    }
  };
  Ar.prototype.isArrayCamera = true;
  var Rr = class extends Wt {
    constructor() {
      super(), this.type = "Group";
    }
  };
  Rr.prototype.isGroup = true;
  var Cr = { type: "move" };
  var Lr = class {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Rr(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Rr(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new V2(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new V2()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Rr(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new V2(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new V2()), this._grip;
    }
    dispatchEvent(t5) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t5), this._grip !== null && this._grip.dispatchEvent(t5), this._hand !== null && this._hand.dispatchEvent(t5), this;
    }
    disconnect(t5) {
      return this.dispatchEvent({ type: "disconnected", data: t5 }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(t5, e8, n8) {
      let i6 = null, r5 = null, s6 = null;
      const a4 = this._targetRay, o7 = this._grip, l6 = this._hand;
      if (t5 && e8.session.visibilityState !== "visible-blurred")
        if (a4 !== null && (i6 = e8.getPose(t5.targetRaySpace, n8), i6 !== null && (a4.matrix.fromArray(i6.transform.matrix), a4.matrix.decompose(a4.position, a4.rotation, a4.scale), i6.linearVelocity ? (a4.hasLinearVelocity = true, a4.linearVelocity.copy(i6.linearVelocity)) : a4.hasLinearVelocity = false, i6.angularVelocity ? (a4.hasAngularVelocity = true, a4.angularVelocity.copy(i6.angularVelocity)) : a4.hasAngularVelocity = false, this.dispatchEvent(Cr))), l6 && t5.hand) {
          s6 = true;
          for (const i8 of t5.hand.values()) {
            const t6 = e8.getJointPose(i8, n8);
            if (l6.joints[i8.jointName] === void 0) {
              const t7 = new Rr();
              t7.matrixAutoUpdate = false, t7.visible = false, l6.joints[i8.jointName] = t7, l6.add(t7);
            }
            const r7 = l6.joints[i8.jointName];
            t6 !== null && (r7.matrix.fromArray(t6.transform.matrix), r7.matrix.decompose(r7.position, r7.rotation, r7.scale), r7.jointRadius = t6.radius), r7.visible = t6 !== null;
          }
          const i7 = l6.joints["index-finger-tip"], r6 = l6.joints["thumb-tip"], a5 = i7.position.distanceTo(r6.position), o8 = 0.02, h4 = 5e-3;
          l6.inputState.pinching && a5 > o8 + h4 ? (l6.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t5.handedness, target: this })) : !l6.inputState.pinching && a5 <= o8 - h4 && (l6.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t5.handedness, target: this }));
        } else
          o7 !== null && t5.gripSpace && (r5 = e8.getPose(t5.gripSpace, n8), r5 !== null && (o7.matrix.fromArray(r5.transform.matrix), o7.matrix.decompose(o7.position, o7.rotation, o7.scale), r5.linearVelocity ? (o7.hasLinearVelocity = true, o7.linearVelocity.copy(r5.linearVelocity)) : o7.hasLinearVelocity = false, r5.angularVelocity ? (o7.hasAngularVelocity = true, o7.angularVelocity.copy(r5.angularVelocity)) : o7.hasAngularVelocity = false));
      return a4 !== null && (a4.visible = i6 !== null), o7 !== null && (o7.visible = r5 !== null), l6 !== null && (l6.visible = s6 !== null), this;
    }
  };
  var Pr = class extends F {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4) {
      if ((h4 = h4 !== void 0 ? h4 : 1026) !== 1026 && h4 !== 1027)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n8 === void 0 && h4 === 1026 && (n8 = 1012), n8 === void 0 && h4 === 1027 && (n8 = 1020), super(null, i6, r5, s6, a4, o7, h4, n8, l6), this.image = { width: t5, height: e8 }, this.magFilter = a4 !== void 0 ? a4 : 1003, this.minFilter = o7 !== void 0 ? o7 : 1003, this.flipY = false, this.generateMipmaps = false;
    }
  };
  Pr.prototype.isDepthTexture = true;
  var Dr = class extends i5 {
    constructor(t5, e8) {
      super();
      const n8 = this;
      let i6 = null, r5 = 1, s6 = null, a4 = "local-floor", o7 = null, l6 = null, h4 = null, c3 = null, u3 = null;
      const d3 = e8.getContextAttributes();
      let p3 = null, m3 = null;
      const f3 = [], g3 = /* @__PURE__ */ new Map(), v3 = new We();
      v3.layers.enable(1), v3.viewport = new U();
      const y3 = new We();
      y3.layers.enable(2), y3.viewport = new U();
      const x3 = [v3, y3], b3 = new Ar();
      b3.layers.enable(1), b3.layers.enable(2);
      let _3 = null, w3 = null;
      function M3(t6) {
        const e9 = g3.get(t6.inputSource);
        e9 && e9.dispatchEvent({ type: t6.type, data: t6.inputSource });
      }
      function S4() {
        g3.forEach(function(t6, e9) {
          t6.disconnect(e9);
        }), g3.clear(), _3 = null, w3 = null, t5.setRenderTarget(p3), c3 = null, h4 = null, l6 = null, i6 = null, m3 = null, L3.stop(), n8.isPresenting = false, n8.dispatchEvent({ type: "sessionend" });
      }
      function T3(t6) {
        const e9 = i6.inputSources;
        for (let t7 = 0; t7 < f3.length; t7++)
          g3.set(e9[t7], f3[t7]);
        for (let e10 = 0; e10 < t6.removed.length; e10++) {
          const n9 = t6.removed[e10], i7 = g3.get(n9);
          i7 && (i7.dispatchEvent({ type: "disconnected", data: n9 }), g3.delete(n9));
        }
        for (let e10 = 0; e10 < t6.added.length; e10++) {
          const n9 = t6.added[e10], i7 = g3.get(n9);
          i7 && i7.dispatchEvent({ type: "connected", data: n9 });
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t6) {
        let e9 = f3[t6];
        return e9 === void 0 && (e9 = new Lr(), f3[t6] = e9), e9.getTargetRaySpace();
      }, this.getControllerGrip = function(t6) {
        let e9 = f3[t6];
        return e9 === void 0 && (e9 = new Lr(), f3[t6] = e9), e9.getGripSpace();
      }, this.getHand = function(t6) {
        let e9 = f3[t6];
        return e9 === void 0 && (e9 = new Lr(), f3[t6] = e9), e9.getHandSpace();
      }, this.setFramebufferScaleFactor = function(t6) {
        r5 = t6, n8.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(t6) {
        a4 = t6, n8.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return s6;
      }, this.getBaseLayer = function() {
        return h4 !== null ? h4 : c3;
      }, this.getBinding = function() {
        return l6;
      }, this.getFrame = function() {
        return u3;
      }, this.getSession = function() {
        return i6;
      }, this.setSession = async function(o8) {
        if (i6 = o8, i6 !== null) {
          if (p3 = t5.getRenderTarget(), i6.addEventListener("select", M3), i6.addEventListener("selectstart", M3), i6.addEventListener("selectend", M3), i6.addEventListener("squeeze", M3), i6.addEventListener("squeezestart", M3), i6.addEventListener("squeezeend", M3), i6.addEventListener("end", S4), i6.addEventListener("inputsourceschange", T3), d3.xrCompatible !== true && await e8.makeXRCompatible(), i6.renderState.layers === void 0 || t5.capabilities.isWebGL2 === false) {
            const n9 = { antialias: i6.renderState.layers !== void 0 || d3.antialias, alpha: d3.alpha, depth: d3.depth, stencil: d3.stencil, framebufferScaleFactor: r5 };
            c3 = new XRWebGLLayer(i6, e8, n9), i6.updateRenderState({ baseLayer: c3 }), m3 = new k2(c3.framebufferWidth, c3.framebufferHeight, { format: 1023, type: 1009, encoding: t5.outputEncoding });
          } else {
            let n9 = null, s7 = null, a5 = null;
            d3.depth && (a5 = d3.stencil ? 35056 : 33190, n9 = d3.stencil ? 1027 : 1026, s7 = d3.stencil ? 1020 : 1012);
            const o9 = { colorFormat: t5.outputEncoding === 3001 ? 35907 : 32856, depthFormat: a5, scaleFactor: r5 };
            l6 = new XRWebGLBinding(i6, e8), h4 = l6.createProjectionLayer(o9), i6.updateRenderState({ layers: [h4] }), m3 = new k2(h4.textureWidth, h4.textureHeight, { format: 1023, type: 1009, depthTexture: new Pr(h4.textureWidth, h4.textureHeight, s7, void 0, void 0, void 0, void 0, void 0, void 0, n9), stencilBuffer: d3.stencil, encoding: t5.outputEncoding, samples: d3.antialias ? 4 : 0 });
            t5.properties.get(m3).__ignoreDepthValues = h4.ignoreDepthValues;
          }
          m3.isXRRenderTarget = true, this.setFoveation(1), s6 = await i6.requestReferenceSpace(a4), L3.setContext(i6), L3.start(), n8.isPresenting = true, n8.dispatchEvent({ type: "sessionstart" });
        }
      };
      const E3 = new V2(), A3 = new V2();
      function R2(t6, e9) {
        e9 === null ? t6.matrixWorld.copy(t6.matrix) : t6.matrixWorld.multiplyMatrices(e9.matrixWorld, t6.matrix), t6.matrixWorldInverse.copy(t6.matrixWorld).invert();
      }
      this.updateCamera = function(t6) {
        if (i6 === null)
          return;
        b3.near = y3.near = v3.near = t6.near, b3.far = y3.far = v3.far = t6.far, _3 === b3.near && w3 === b3.far || (i6.updateRenderState({ depthNear: b3.near, depthFar: b3.far }), _3 = b3.near, w3 = b3.far);
        const e9 = t6.parent, n9 = b3.cameras;
        R2(b3, e9);
        for (let t7 = 0; t7 < n9.length; t7++)
          R2(n9[t7], e9);
        b3.matrixWorld.decompose(b3.position, b3.quaternion, b3.scale), t6.position.copy(b3.position), t6.quaternion.copy(b3.quaternion), t6.scale.copy(b3.scale), t6.matrix.copy(b3.matrix), t6.matrixWorld.copy(b3.matrixWorld);
        const r6 = t6.children;
        for (let t7 = 0, e10 = r6.length; t7 < e10; t7++)
          r6[t7].updateMatrixWorld(true);
        n9.length === 2 ? function(t7, e10, n10) {
          E3.setFromMatrixPosition(e10.matrixWorld), A3.setFromMatrixPosition(n10.matrixWorld);
          const i7 = E3.distanceTo(A3), r7 = e10.projectionMatrix.elements, s7 = n10.projectionMatrix.elements, a5 = r7[14] / (r7[10] - 1), o8 = r7[14] / (r7[10] + 1), l7 = (r7[9] + 1) / r7[5], h5 = (r7[9] - 1) / r7[5], c4 = (r7[8] - 1) / r7[0], u4 = (s7[8] + 1) / s7[0], d4 = a5 * c4, p4 = a5 * u4, m4 = i7 / (-c4 + u4), f4 = m4 * -c4;
          e10.matrixWorld.decompose(t7.position, t7.quaternion, t7.scale), t7.translateX(f4), t7.translateZ(m4), t7.matrixWorld.compose(t7.position, t7.quaternion, t7.scale), t7.matrixWorldInverse.copy(t7.matrixWorld).invert();
          const g4 = a5 + m4, v4 = o8 + m4, y4 = d4 - f4, x4 = p4 + (i7 - f4), b4 = l7 * o8 / v4 * g4, _4 = h5 * o8 / v4 * g4;
          t7.projectionMatrix.makePerspective(y4, x4, b4, _4, g4, v4);
        }(b3, v3, y3) : b3.projectionMatrix.copy(v3.projectionMatrix);
      }, this.getCamera = function() {
        return b3;
      }, this.getFoveation = function() {
        return h4 !== null ? h4.fixedFoveation : c3 !== null ? c3.fixedFoveation : void 0;
      }, this.setFoveation = function(t6) {
        h4 !== null && (h4.fixedFoveation = t6), c3 !== null && c3.fixedFoveation !== void 0 && (c3.fixedFoveation = t6);
      };
      let C3 = null;
      const L3 = new en();
      L3.setAnimationLoop(function(e9, n9) {
        if (o7 = n9.getViewerPose(s6), u3 = n9, o7 !== null) {
          const e10 = o7.views;
          c3 !== null && (t5.setRenderTargetFramebuffer(m3, c3.framebuffer), t5.setRenderTarget(m3));
          let n10 = false;
          e10.length !== b3.cameras.length && (b3.cameras.length = 0, n10 = true);
          for (let i7 = 0; i7 < e10.length; i7++) {
            const r7 = e10[i7];
            let s7 = null;
            if (c3 !== null)
              s7 = c3.getViewport(r7);
            else {
              const e11 = l6.getViewSubImage(h4, r7);
              s7 = e11.viewport, i7 === 0 && (t5.setRenderTargetTextures(m3, e11.colorTexture, h4.ignoreDepthValues ? void 0 : e11.depthStencilTexture), t5.setRenderTarget(m3));
            }
            const a5 = x3[i7];
            a5.matrix.fromArray(r7.transform.matrix), a5.projectionMatrix.fromArray(r7.projectionMatrix), a5.viewport.set(s7.x, s7.y, s7.width, s7.height), i7 === 0 && b3.matrix.copy(a5.matrix), n10 === true && b3.cameras.push(a5);
          }
        }
        const r6 = i6.inputSources;
        for (let t6 = 0; t6 < f3.length; t6++) {
          const e10 = f3[t6], i7 = r6[t6];
          e10.update(i7, n9, s6);
        }
        C3 && C3(e9, n9), u3 = null;
      }), this.setAnimationLoop = function(t6) {
        C3 = t6;
      }, this.dispose = function() {
      };
    }
  };
  function Ir(t5, e8) {
    function n8(n9, i6) {
      n9.opacity.value = i6.opacity, i6.color && n9.diffuse.value.copy(i6.color), i6.emissive && n9.emissive.value.copy(i6.emissive).multiplyScalar(i6.emissiveIntensity), i6.map && (n9.map.value = i6.map), i6.alphaMap && (n9.alphaMap.value = i6.alphaMap), i6.bumpMap && (n9.bumpMap.value = i6.bumpMap, n9.bumpScale.value = i6.bumpScale, i6.side === 1 && (n9.bumpScale.value *= -1)), i6.displacementMap && (n9.displacementMap.value = i6.displacementMap, n9.displacementScale.value = i6.displacementScale, n9.displacementBias.value = i6.displacementBias), i6.emissiveMap && (n9.emissiveMap.value = i6.emissiveMap), i6.normalMap && (n9.normalMap.value = i6.normalMap, n9.normalScale.value.copy(i6.normalScale), i6.side === 1 && n9.normalScale.value.negate()), i6.specularMap && (n9.specularMap.value = i6.specularMap), i6.alphaTest > 0 && (n9.alphaTest.value = i6.alphaTest);
      const r5 = e8.get(i6).envMap;
      if (r5 && (n9.envMap.value = r5, n9.flipEnvMap.value = r5.isCubeTexture && r5.isRenderTargetTexture === false ? -1 : 1, n9.reflectivity.value = i6.reflectivity, n9.ior.value = i6.ior, n9.refractionRatio.value = i6.refractionRatio), i6.lightMap) {
        n9.lightMap.value = i6.lightMap;
        const e9 = t5.physicallyCorrectLights !== true ? Math.PI : 1;
        n9.lightMapIntensity.value = i6.lightMapIntensity * e9;
      }
      let s6, a4;
      i6.aoMap && (n9.aoMap.value = i6.aoMap, n9.aoMapIntensity.value = i6.aoMapIntensity), i6.map ? s6 = i6.map : i6.specularMap ? s6 = i6.specularMap : i6.displacementMap ? s6 = i6.displacementMap : i6.normalMap ? s6 = i6.normalMap : i6.bumpMap ? s6 = i6.bumpMap : i6.roughnessMap ? s6 = i6.roughnessMap : i6.metalnessMap ? s6 = i6.metalnessMap : i6.alphaMap ? s6 = i6.alphaMap : i6.emissiveMap ? s6 = i6.emissiveMap : i6.clearcoatMap ? s6 = i6.clearcoatMap : i6.clearcoatNormalMap ? s6 = i6.clearcoatNormalMap : i6.clearcoatRoughnessMap ? s6 = i6.clearcoatRoughnessMap : i6.specularIntensityMap ? s6 = i6.specularIntensityMap : i6.specularColorMap ? s6 = i6.specularColorMap : i6.transmissionMap ? s6 = i6.transmissionMap : i6.thicknessMap ? s6 = i6.thicknessMap : i6.sheenColorMap ? s6 = i6.sheenColorMap : i6.sheenRoughnessMap && (s6 = i6.sheenRoughnessMap), s6 !== void 0 && (s6.isWebGLRenderTarget && (s6 = s6.texture), s6.matrixAutoUpdate === true && s6.updateMatrix(), n9.uvTransform.value.copy(s6.matrix)), i6.aoMap ? a4 = i6.aoMap : i6.lightMap && (a4 = i6.lightMap), a4 !== void 0 && (a4.isWebGLRenderTarget && (a4 = a4.texture), a4.matrixAutoUpdate === true && a4.updateMatrix(), n9.uv2Transform.value.copy(a4.matrix));
    }
    return { refreshFogUniforms: function(t6, e9) {
      t6.fogColor.value.copy(e9.color), e9.isFog ? (t6.fogNear.value = e9.near, t6.fogFar.value = e9.far) : e9.isFogExp2 && (t6.fogDensity.value = e9.density);
    }, refreshMaterialUniforms: function(t6, i6, r5, s6, a4) {
      i6.isMeshBasicMaterial || i6.isMeshLambertMaterial ? n8(t6, i6) : i6.isMeshToonMaterial ? (n8(t6, i6), function(t7, e9) {
        e9.gradientMap && (t7.gradientMap.value = e9.gradientMap);
      }(t6, i6)) : i6.isMeshPhongMaterial ? (n8(t6, i6), function(t7, e9) {
        t7.specular.value.copy(e9.specular), t7.shininess.value = Math.max(e9.shininess, 1e-4);
      }(t6, i6)) : i6.isMeshStandardMaterial ? (n8(t6, i6), function(t7, n9) {
        t7.roughness.value = n9.roughness, t7.metalness.value = n9.metalness, n9.roughnessMap && (t7.roughnessMap.value = n9.roughnessMap);
        n9.metalnessMap && (t7.metalnessMap.value = n9.metalnessMap);
        e8.get(n9).envMap && (t7.envMapIntensity.value = n9.envMapIntensity);
      }(t6, i6), i6.isMeshPhysicalMaterial && function(t7, e9, n9) {
        t7.ior.value = e9.ior, e9.sheen > 0 && (t7.sheenColor.value.copy(e9.sheenColor).multiplyScalar(e9.sheen), t7.sheenRoughness.value = e9.sheenRoughness, e9.sheenColorMap && (t7.sheenColorMap.value = e9.sheenColorMap), e9.sheenRoughnessMap && (t7.sheenRoughnessMap.value = e9.sheenRoughnessMap));
        e9.clearcoat > 0 && (t7.clearcoat.value = e9.clearcoat, t7.clearcoatRoughness.value = e9.clearcoatRoughness, e9.clearcoatMap && (t7.clearcoatMap.value = e9.clearcoatMap), e9.clearcoatRoughnessMap && (t7.clearcoatRoughnessMap.value = e9.clearcoatRoughnessMap), e9.clearcoatNormalMap && (t7.clearcoatNormalScale.value.copy(e9.clearcoatNormalScale), t7.clearcoatNormalMap.value = e9.clearcoatNormalMap, e9.side === 1 && t7.clearcoatNormalScale.value.negate()));
        e9.transmission > 0 && (t7.transmission.value = e9.transmission, t7.transmissionSamplerMap.value = n9.texture, t7.transmissionSamplerSize.value.set(n9.width, n9.height), e9.transmissionMap && (t7.transmissionMap.value = e9.transmissionMap), t7.thickness.value = e9.thickness, e9.thicknessMap && (t7.thicknessMap.value = e9.thicknessMap), t7.attenuationDistance.value = e9.attenuationDistance, t7.attenuationColor.value.copy(e9.attenuationColor));
        t7.specularIntensity.value = e9.specularIntensity, t7.specularColor.value.copy(e9.specularColor), e9.specularIntensityMap && (t7.specularIntensityMap.value = e9.specularIntensityMap);
        e9.specularColorMap && (t7.specularColorMap.value = e9.specularColorMap);
      }(t6, i6, a4)) : i6.isMeshMatcapMaterial ? (n8(t6, i6), function(t7, e9) {
        e9.matcap && (t7.matcap.value = e9.matcap);
      }(t6, i6)) : i6.isMeshDepthMaterial ? n8(t6, i6) : i6.isMeshDistanceMaterial ? (n8(t6, i6), function(t7, e9) {
        t7.referencePosition.value.copy(e9.referencePosition), t7.nearDistance.value = e9.nearDistance, t7.farDistance.value = e9.farDistance;
      }(t6, i6)) : i6.isMeshNormalMaterial ? n8(t6, i6) : i6.isLineBasicMaterial ? (function(t7, e9) {
        t7.diffuse.value.copy(e9.color), t7.opacity.value = e9.opacity;
      }(t6, i6), i6.isLineDashedMaterial && function(t7, e9) {
        t7.dashSize.value = e9.dashSize, t7.totalSize.value = e9.dashSize + e9.gapSize, t7.scale.value = e9.scale;
      }(t6, i6)) : i6.isPointsMaterial ? function(t7, e9, n9, i7) {
        t7.diffuse.value.copy(e9.color), t7.opacity.value = e9.opacity, t7.size.value = e9.size * n9, t7.scale.value = 0.5 * i7, e9.map && (t7.map.value = e9.map);
        e9.alphaMap && (t7.alphaMap.value = e9.alphaMap);
        e9.alphaTest > 0 && (t7.alphaTest.value = e9.alphaTest);
        let r6;
        e9.map ? r6 = e9.map : e9.alphaMap && (r6 = e9.alphaMap);
        r6 !== void 0 && (r6.matrixAutoUpdate === true && r6.updateMatrix(), t7.uvTransform.value.copy(r6.matrix));
      }(t6, i6, r5, s6) : i6.isSpriteMaterial ? function(t7, e9) {
        t7.diffuse.value.copy(e9.color), t7.opacity.value = e9.opacity, t7.rotation.value = e9.rotation, e9.map && (t7.map.value = e9.map);
        e9.alphaMap && (t7.alphaMap.value = e9.alphaMap);
        e9.alphaTest > 0 && (t7.alphaTest.value = e9.alphaTest);
        let n9;
        e9.map ? n9 = e9.map : e9.alphaMap && (n9 = e9.alphaMap);
        n9 !== void 0 && (n9.matrixAutoUpdate === true && n9.updateMatrix(), t7.uvTransform.value.copy(n9.matrix));
      }(t6, i6) : i6.isShadowMaterial ? (t6.color.value.copy(i6.color), t6.opacity.value = i6.opacity) : i6.isShaderMaterial && (i6.uniformsNeedUpdate = false);
    } };
  }
  function Or(t5 = {}) {
    const e8 = t5.canvas !== void 0 ? t5.canvas : function() {
      const t6 = x2("canvas");
      return t6.style.display = "block", t6;
    }(), n8 = t5.context !== void 0 ? t5.context : null, i6 = t5.depth === void 0 || t5.depth, r5 = t5.stencil === void 0 || t5.stencil, s6 = t5.antialias !== void 0 && t5.antialias, a4 = t5.premultipliedAlpha === void 0 || t5.premultipliedAlpha, o7 = t5.preserveDrawingBuffer !== void 0 && t5.preserveDrawingBuffer, l6 = t5.powerPreference !== void 0 ? t5.powerPreference : "default", h4 = t5.failIfMajorPerformanceCaveat !== void 0 && t5.failIfMajorPerformanceCaveat;
    let c3;
    c3 = t5.context !== void 0 ? n8.getContextAttributes().alpha : t5.alpha !== void 0 && t5.alpha;
    let u3 = null, d3 = null;
    const p3 = [], f3 = [];
    this.domElement = e8, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
    const v3 = this;
    let y3 = false, b3 = 0, _3 = 0, w3 = null, M3 = -1, S4 = null;
    const T3 = new U(), E3 = new U();
    let A3 = null, R2 = e8.width, C3 = e8.height, L3 = 1, P3 = null, D2 = null;
    const I3 = new U(0, 0, R2, C3), O2 = new U(0, 0, R2, C3);
    let N3 = false;
    const F2 = new tn();
    let B2 = false, z3 = false, H3 = null;
    const G2 = new xt(), W2 = new g2(), j2 = new V2(), q2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function X2() {
      return w3 === null ? L3 : 1;
    }
    let $3, Y2, J2, K2, Z2, Q2, tt2, et2, nt2, it2, rt2, st2, at2, ot2, lt2, ht2, ct2, ut2, dt2, pt2, mt2, ft2, gt2, vt2 = n8;
    function yt2(t6, n9) {
      for (let i7 = 0; i7 < t6.length; i7++) {
        const r6 = t6[i7], s7 = e8.getContext(r6, n9);
        if (s7 !== null)
          return s7;
      }
      return null;
    }
    try {
      const t6 = { alpha: true, depth: i6, stencil: r5, antialias: s6, premultipliedAlpha: a4, preserveDrawingBuffer: o7, powerPreference: l6, failIfMajorPerformanceCaveat: h4 };
      if ("setAttribute" in e8 && e8.setAttribute("data-engine", "three.js r139"), e8.addEventListener("webglcontextlost", wt2, false), e8.addEventListener("webglcontextrestored", Mt2, false), vt2 === null) {
        const e9 = ["webgl2", "webgl", "experimental-webgl"];
        if (v3.isWebGL1Renderer === true && e9.shift(), vt2 = yt2(e9, t6), vt2 === null)
          throw yt2(e9) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      vt2.getShaderPrecisionFormat === void 0 && (vt2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (t6) {
      throw console.error("THREE.WebGLRenderer: " + t6.message), t6;
    }
    function bt2() {
      $3 = new Cn(vt2), Y2 = new un(vt2, $3, t5), $3.init(Y2), ft2 = new Er(vt2, $3, Y2), J2 = new Sr(vt2, $3, Y2), K2 = new Dn(vt2), Z2 = new cr(), Q2 = new Tr(vt2, $3, J2, Z2, Y2, ft2, K2), tt2 = new pn(v3), et2 = new Rn(v3), nt2 = new nn(vt2, Y2), gt2 = new hn(vt2, $3, nt2, Y2), it2 = new Ln(vt2, nt2, K2, gt2), rt2 = new Un(vt2, it2, nt2, K2), dt2 = new Fn(vt2, Y2, Q2), ht2 = new dn(Z2), st2 = new hr(v3, tt2, et2, $3, Y2, gt2, ht2), at2 = new Ir(v3, Z2), ot2 = new mr(), lt2 = new br($3, Y2), ut2 = new ln(v3, tt2, J2, rt2, c3, a4), ct2 = new Mr(v3, rt2, Y2), pt2 = new cn(vt2, $3, K2, Y2), mt2 = new Pn(vt2, $3, K2, Y2), K2.programs = st2.programs, v3.capabilities = Y2, v3.extensions = $3, v3.properties = Z2, v3.renderLists = ot2, v3.shadowMap = ct2, v3.state = J2, v3.info = K2;
    }
    bt2();
    const _t2 = new Dr(v3, vt2);
    function wt2(t6) {
      t6.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y3 = true;
    }
    function Mt2() {
      console.log("THREE.WebGLRenderer: Context Restored."), y3 = false;
      const t6 = K2.autoReset, e9 = ct2.enabled, n9 = ct2.autoUpdate, i7 = ct2.needsUpdate, r6 = ct2.type;
      bt2(), K2.autoReset = t6, ct2.enabled = e9, ct2.autoUpdate = n9, ct2.needsUpdate = i7, ct2.type = r6;
    }
    function St2(t6) {
      const e9 = t6.target;
      e9.removeEventListener("dispose", St2), function(t7) {
        (function(t8) {
          const e10 = Z2.get(t8).programs;
          e10 !== void 0 && (e10.forEach(function(t9) {
            st2.releaseProgram(t9);
          }), t8.isShaderMaterial && st2.releaseShaderCache(t8));
        })(t7), Z2.remove(t7);
      }(e9);
    }
    this.xr = _t2, this.getContext = function() {
      return vt2;
    }, this.getContextAttributes = function() {
      return vt2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const t6 = $3.get("WEBGL_lose_context");
      t6 && t6.loseContext();
    }, this.forceContextRestore = function() {
      const t6 = $3.get("WEBGL_lose_context");
      t6 && t6.restoreContext();
    }, this.getPixelRatio = function() {
      return L3;
    }, this.setPixelRatio = function(t6) {
      t6 !== void 0 && (L3 = t6, this.setSize(R2, C3, false));
    }, this.getSize = function(t6) {
      return t6.set(R2, C3);
    }, this.setSize = function(t6, n9, i7) {
      _t2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R2 = t6, C3 = n9, e8.width = Math.floor(t6 * L3), e8.height = Math.floor(n9 * L3), i7 !== false && (e8.style.width = t6 + "px", e8.style.height = n9 + "px"), this.setViewport(0, 0, t6, n9));
    }, this.getDrawingBufferSize = function(t6) {
      return t6.set(R2 * L3, C3 * L3).floor();
    }, this.setDrawingBufferSize = function(t6, n9, i7) {
      R2 = t6, C3 = n9, L3 = i7, e8.width = Math.floor(t6 * i7), e8.height = Math.floor(n9 * i7), this.setViewport(0, 0, t6, n9);
    }, this.getCurrentViewport = function(t6) {
      return t6.copy(T3);
    }, this.getViewport = function(t6) {
      return t6.copy(I3);
    }, this.setViewport = function(t6, e9, n9, i7) {
      t6.isVector4 ? I3.set(t6.x, t6.y, t6.z, t6.w) : I3.set(t6, e9, n9, i7), J2.viewport(T3.copy(I3).multiplyScalar(L3).floor());
    }, this.getScissor = function(t6) {
      return t6.copy(O2);
    }, this.setScissor = function(t6, e9, n9, i7) {
      t6.isVector4 ? O2.set(t6.x, t6.y, t6.z, t6.w) : O2.set(t6, e9, n9, i7), J2.scissor(E3.copy(O2).multiplyScalar(L3).floor());
    }, this.getScissorTest = function() {
      return N3;
    }, this.setScissorTest = function(t6) {
      J2.setScissorTest(N3 = t6);
    }, this.setOpaqueSort = function(t6) {
      P3 = t6;
    }, this.setTransparentSort = function(t6) {
      D2 = t6;
    }, this.getClearColor = function(t6) {
      return t6.copy(ut2.getClearColor());
    }, this.setClearColor = function() {
      ut2.setClearColor.apply(ut2, arguments);
    }, this.getClearAlpha = function() {
      return ut2.getClearAlpha();
    }, this.setClearAlpha = function() {
      ut2.setClearAlpha.apply(ut2, arguments);
    }, this.clear = function(t6 = true, e9 = true, n9 = true) {
      let i7 = 0;
      t6 && (i7 |= 16384), e9 && (i7 |= 256), n9 && (i7 |= 1024), vt2.clear(i7);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      e8.removeEventListener("webglcontextlost", wt2, false), e8.removeEventListener("webglcontextrestored", Mt2, false), ot2.dispose(), lt2.dispose(), Z2.dispose(), tt2.dispose(), et2.dispose(), rt2.dispose(), gt2.dispose(), st2.dispose(), _t2.dispose(), _t2.removeEventListener("sessionstart", Et2), _t2.removeEventListener("sessionend", At2), H3 && (H3.dispose(), H3 = null), Rt2.stop();
    }, this.renderBufferDirect = function(t6, e9, n9, i7, r6, s7) {
      e9 === null && (e9 = q2);
      const a5 = r6.isMesh && r6.matrixWorld.determinant() < 0, o8 = function(t7, e10, n10, i8, r7) {
        e10.isScene !== true && (e10 = q2);
        Q2.resetTextureUnits();
        const s8 = e10.fog, a6 = i8.isMeshStandardMaterial ? e10.environment : null, o9 = w3 === null ? v3.outputEncoding : w3.isXRRenderTarget === true ? w3.texture.encoding : 3e3, l8 = (i8.isMeshStandardMaterial ? et2 : tt2).get(i8.envMap || a6), h6 = i8.vertexColors === true && !!n10.attributes.color && n10.attributes.color.itemSize === 4, c5 = !!i8.normalMap && !!n10.attributes.tangent, u5 = !!n10.morphAttributes.position, p5 = !!n10.morphAttributes.normal, m4 = !!n10.morphAttributes.color, f5 = i8.toneMapped ? v3.toneMapping : 0, g4 = n10.morphAttributes.position || n10.morphAttributes.normal || n10.morphAttributes.color, y5 = g4 !== void 0 ? g4.length : 0, x4 = Z2.get(i8), b5 = d3.state.lights;
        if (B2 === true && (z3 === true || t7 !== S4)) {
          const e11 = t7 === S4 && i8.id === M3;
          ht2.setState(i8, t7, e11);
        }
        let _5 = false;
        i8.version === x4.__version ? x4.needsLights && x4.lightsStateVersion !== b5.state.version || x4.outputEncoding !== o9 || r7.isInstancedMesh && x4.instancing === false ? _5 = true : r7.isInstancedMesh || x4.instancing !== true ? r7.isSkinnedMesh && x4.skinning === false ? _5 = true : r7.isSkinnedMesh || x4.skinning !== true ? x4.envMap !== l8 || i8.fog && x4.fog !== s8 ? _5 = true : x4.numClippingPlanes === void 0 || x4.numClippingPlanes === ht2.numPlanes && x4.numIntersection === ht2.numIntersection ? (x4.vertexAlphas !== h6 || x4.vertexTangents !== c5 || x4.morphTargets !== u5 || x4.morphNormals !== p5 || x4.morphColors !== m4 || x4.toneMapping !== f5 || Y2.isWebGL2 === true && x4.morphTargetsCount !== y5) && (_5 = true) : _5 = true : _5 = true : _5 = true : (_5 = true, x4.__version = i8.version);
        let T5 = x4.currentProgram;
        _5 === true && (T5 = It2(i8, e10, r7));
        let E4 = false, A4 = false, R3 = false;
        const P4 = T5.getUniforms(), D3 = x4.uniforms;
        J2.useProgram(T5.program) && (E4 = true, A4 = true, R3 = true);
        i8.id !== M3 && (M3 = i8.id, A4 = true);
        if (E4 || S4 !== t7) {
          if (P4.setValue(vt2, "projectionMatrix", t7.projectionMatrix), Y2.logarithmicDepthBuffer && P4.setValue(vt2, "logDepthBufFC", 2 / (Math.log(t7.far + 1) / Math.LN2)), S4 !== t7 && (S4 = t7, A4 = true, R3 = true), i8.isShaderMaterial || i8.isMeshPhongMaterial || i8.isMeshToonMaterial || i8.isMeshStandardMaterial || i8.envMap) {
            const e11 = P4.map.cameraPosition;
            e11 !== void 0 && e11.setValue(vt2, j2.setFromMatrixPosition(t7.matrixWorld));
          }
          (i8.isMeshPhongMaterial || i8.isMeshToonMaterial || i8.isMeshLambertMaterial || i8.isMeshBasicMaterial || i8.isMeshStandardMaterial || i8.isShaderMaterial) && P4.setValue(vt2, "isOrthographic", t7.isOrthographicCamera === true), (i8.isMeshPhongMaterial || i8.isMeshToonMaterial || i8.isMeshLambertMaterial || i8.isMeshBasicMaterial || i8.isMeshStandardMaterial || i8.isShaderMaterial || i8.isShadowMaterial || r7.isSkinnedMesh) && P4.setValue(vt2, "viewMatrix", t7.matrixWorldInverse);
        }
        if (r7.isSkinnedMesh) {
          P4.setOptional(vt2, r7, "bindMatrix"), P4.setOptional(vt2, r7, "bindMatrixInverse");
          const t8 = r7.skeleton;
          t8 && (Y2.floatVertexTextures ? (t8.boneTexture === null && t8.computeBoneTexture(), P4.setValue(vt2, "boneTexture", t8.boneTexture, Q2), P4.setValue(vt2, "boneTextureSize", t8.boneTextureSize)) : P4.setOptional(vt2, t8, "boneMatrices"));
        }
        const I4 = n10.morphAttributes;
        (I4.position !== void 0 || I4.normal !== void 0 || I4.color !== void 0 && Y2.isWebGL2 === true) && dt2.update(r7, n10, i8, T5);
        (A4 || x4.receiveShadow !== r7.receiveShadow) && (x4.receiveShadow = r7.receiveShadow, P4.setValue(vt2, "receiveShadow", r7.receiveShadow));
        A4 && (P4.setValue(vt2, "toneMappingExposure", v3.toneMappingExposure), x4.needsLights && (N4 = R3, (O3 = D3).ambientLightColor.needsUpdate = N4, O3.lightProbe.needsUpdate = N4, O3.directionalLights.needsUpdate = N4, O3.directionalLightShadows.needsUpdate = N4, O3.pointLights.needsUpdate = N4, O3.pointLightShadows.needsUpdate = N4, O3.spotLights.needsUpdate = N4, O3.spotLightShadows.needsUpdate = N4, O3.rectAreaLights.needsUpdate = N4, O3.hemisphereLights.needsUpdate = N4), s8 && i8.fog && at2.refreshFogUniforms(D3, s8), at2.refreshMaterialUniforms(D3, i8, L3, C3, H3), Hi.upload(vt2, x4.uniformsList, D3, Q2));
        var O3, N4;
        i8.isShaderMaterial && i8.uniformsNeedUpdate === true && (Hi.upload(vt2, x4.uniformsList, D3, Q2), i8.uniformsNeedUpdate = false);
        i8.isSpriteMaterial && P4.setValue(vt2, "center", r7.center);
        return P4.setValue(vt2, "modelViewMatrix", r7.modelViewMatrix), P4.setValue(vt2, "normalMatrix", r7.normalMatrix), P4.setValue(vt2, "modelMatrix", r7.matrixWorld), T5;
      }(t6, e9, n9, i7, r6);
      J2.setMaterial(i7, a5);
      let l7 = n9.index;
      const h5 = n9.attributes.position;
      if (l7 === null) {
        if (h5 === void 0 || h5.count === 0)
          return;
      } else if (l7.count === 0)
        return;
      let c4, u4 = 1;
      i7.wireframe === true && (l7 = it2.getWireframeAttribute(n9), u4 = 2), gt2.setup(r6, i7, o8, n9, l7);
      let p4 = pt2;
      l7 !== null && (c4 = nt2.get(l7), p4 = mt2, p4.setIndex(c4));
      const m3 = l7 !== null ? l7.count : h5.count, f4 = n9.drawRange.start * u4, g3 = n9.drawRange.count * u4, y4 = s7 !== null ? s7.start * u4 : 0, x3 = s7 !== null ? s7.count * u4 : 1 / 0, b4 = Math.max(f4, y4), _4 = Math.min(m3, f4 + g3, y4 + x3) - 1, T4 = Math.max(0, _4 - b4 + 1);
      if (T4 !== 0) {
        if (r6.isMesh)
          i7.wireframe === true ? (J2.setLineWidth(i7.wireframeLinewidth * X2()), p4.setMode(1)) : p4.setMode(4);
        else if (r6.isLine) {
          let t7 = i7.linewidth;
          t7 === void 0 && (t7 = 1), J2.setLineWidth(t7 * X2()), r6.isLineSegments ? p4.setMode(1) : r6.isLineLoop ? p4.setMode(2) : p4.setMode(3);
        } else
          r6.isPoints ? p4.setMode(0) : r6.isSprite && p4.setMode(4);
        if (r6.isInstancedMesh)
          p4.renderInstances(b4, T4, r6.count);
        else if (n9.isInstancedBufferGeometry) {
          const t7 = Math.min(n9.instanceCount, n9._maxInstanceCount);
          p4.renderInstances(b4, T4, t7);
        } else
          p4.render(b4, T4);
      }
    }, this.compile = function(t6, e9) {
      d3 = lt2.get(t6), d3.init(), f3.push(d3), t6.traverseVisible(function(t7) {
        t7.isLight && t7.layers.test(e9.layers) && (d3.pushLight(t7), t7.castShadow && d3.pushShadow(t7));
      }), d3.setupLights(v3.physicallyCorrectLights), t6.traverse(function(e10) {
        const n9 = e10.material;
        if (n9)
          if (Array.isArray(n9))
            for (let i7 = 0; i7 < n9.length; i7++) {
              It2(n9[i7], t6, e10);
            }
          else
            It2(n9, t6, e10);
      }), f3.pop(), d3 = null;
    };
    let Tt2 = null;
    function Et2() {
      Rt2.stop();
    }
    function At2() {
      Rt2.start();
    }
    const Rt2 = new en();
    function Ct2(t6, e9, n9, i7) {
      if (t6.visible === false)
        return;
      if (t6.layers.test(e9.layers)) {
        if (t6.isGroup)
          n9 = t6.renderOrder;
        else if (t6.isLOD)
          t6.autoUpdate === true && t6.update(e9);
        else if (t6.isLight)
          d3.pushLight(t6), t6.castShadow && d3.pushShadow(t6);
        else if (t6.isSprite) {
          if (!t6.frustumCulled || F2.intersectsSprite(t6)) {
            i7 && j2.setFromMatrixPosition(t6.matrixWorld).applyMatrix4(G2);
            const e10 = rt2.update(t6), r7 = t6.material;
            r7.visible && u3.push(t6, e10, r7, n9, j2.z, null);
          }
        } else if ((t6.isMesh || t6.isLine || t6.isPoints) && (t6.isSkinnedMesh && t6.skeleton.frame !== K2.render.frame && (t6.skeleton.update(), t6.skeleton.frame = K2.render.frame), !t6.frustumCulled || F2.intersectsObject(t6))) {
          i7 && j2.setFromMatrixPosition(t6.matrixWorld).applyMatrix4(G2);
          const e10 = rt2.update(t6), r7 = t6.material;
          if (Array.isArray(r7)) {
            const i8 = e10.groups;
            for (let s7 = 0, a5 = i8.length; s7 < a5; s7++) {
              const a6 = i8[s7], o8 = r7[a6.materialIndex];
              o8 && o8.visible && u3.push(t6, e10, o8, n9, j2.z, a6);
            }
          } else
            r7.visible && u3.push(t6, e10, r7, n9, j2.z, null);
        }
      }
      const r6 = t6.children;
      for (let t7 = 0, s7 = r6.length; t7 < s7; t7++)
        Ct2(r6[t7], e9, n9, i7);
    }
    function Lt2(t6, e9, n9, i7) {
      const r6 = t6.opaque, a5 = t6.transmissive, o8 = t6.transparent;
      d3.setupLightsView(n9), a5.length > 0 && function(t7, e10, n10) {
        const i8 = Y2.isWebGL2;
        H3 === null && (H3 = new k2(1, 1, { generateMipmaps: true, type: ft2.convert(1016) !== null ? 1016 : 1009, minFilter: 1008, samples: i8 && s6 === true ? 4 : 0 }));
        v3.getDrawingBufferSize(W2), i8 ? H3.setSize(W2.x, W2.y) : H3.setSize(m2(W2.x), m2(W2.y));
        const r7 = v3.getRenderTarget();
        v3.setRenderTarget(H3), v3.clear();
        const a6 = v3.toneMapping;
        v3.toneMapping = 0, Pt2(t7, e10, n10), v3.toneMapping = a6, Q2.updateMultisampleRenderTarget(H3), Q2.updateRenderTargetMipmap(H3), v3.setRenderTarget(r7);
      }(r6, e9, n9), i7 && J2.viewport(T3.copy(i7)), r6.length > 0 && Pt2(r6, e9, n9), a5.length > 0 && Pt2(a5, e9, n9), o8.length > 0 && Pt2(o8, e9, n9), J2.buffers.depth.setTest(true), J2.buffers.depth.setMask(true), J2.buffers.color.setMask(true), J2.setPolygonOffset(false);
    }
    function Pt2(t6, e9, n9) {
      const i7 = e9.isScene === true ? e9.overrideMaterial : null;
      for (let r6 = 0, s7 = t6.length; r6 < s7; r6++) {
        const s8 = t6[r6], a5 = s8.object, o8 = s8.geometry, l7 = i7 === null ? s8.material : i7, h5 = s8.group;
        a5.layers.test(n9.layers) && Dt2(a5, e9, n9, o8, l7, h5);
      }
    }
    function Dt2(t6, e9, n9, i7, r6, s7) {
      t6.onBeforeRender(v3, e9, n9, i7, r6, s7), t6.modelViewMatrix.multiplyMatrices(n9.matrixWorldInverse, t6.matrixWorld), t6.normalMatrix.getNormalMatrix(t6.modelViewMatrix), r6.onBeforeRender(v3, e9, n9, i7, t6, s7), r6.transparent === true && r6.side === 2 ? (r6.side = 1, r6.needsUpdate = true, v3.renderBufferDirect(n9, e9, i7, r6, t6, s7), r6.side = 0, r6.needsUpdate = true, v3.renderBufferDirect(n9, e9, i7, r6, t6, s7), r6.side = 2) : v3.renderBufferDirect(n9, e9, i7, r6, t6, s7), t6.onAfterRender(v3, e9, n9, i7, r6, s7);
    }
    function It2(t6, e9, n9) {
      e9.isScene !== true && (e9 = q2);
      const i7 = Z2.get(t6), r6 = d3.state.lights, s7 = d3.state.shadowsArray, a5 = r6.state.version, o8 = st2.getParameters(t6, r6.state, s7, e9, n9), l7 = st2.getProgramCacheKey(o8);
      let h5 = i7.programs;
      i7.environment = t6.isMeshStandardMaterial ? e9.environment : null, i7.fog = e9.fog, i7.envMap = (t6.isMeshStandardMaterial ? et2 : tt2).get(t6.envMap || i7.environment), h5 === void 0 && (t6.addEventListener("dispose", St2), h5 = /* @__PURE__ */ new Map(), i7.programs = h5);
      let c4 = h5.get(l7);
      if (c4 !== void 0) {
        if (i7.currentProgram === c4 && i7.lightsStateVersion === a5)
          return Ot2(t6, o8), c4;
      } else
        o8.uniforms = st2.getUniforms(t6), t6.onBuild(n9, o8, v3), t6.onBeforeCompile(o8, v3), c4 = st2.acquireProgram(o8, l7), h5.set(l7, c4), i7.uniforms = o8.uniforms;
      const u4 = i7.uniforms;
      (t6.isShaderMaterial || t6.isRawShaderMaterial) && t6.clipping !== true || (u4.clippingPlanes = ht2.uniform), Ot2(t6, o8), i7.needsLights = function(t7) {
        return t7.isMeshLambertMaterial || t7.isMeshToonMaterial || t7.isMeshPhongMaterial || t7.isMeshStandardMaterial || t7.isShadowMaterial || t7.isShaderMaterial && t7.lights === true;
      }(t6), i7.lightsStateVersion = a5, i7.needsLights && (u4.ambientLightColor.value = r6.state.ambient, u4.lightProbe.value = r6.state.probe, u4.directionalLights.value = r6.state.directional, u4.directionalLightShadows.value = r6.state.directionalShadow, u4.spotLights.value = r6.state.spot, u4.spotLightShadows.value = r6.state.spotShadow, u4.rectAreaLights.value = r6.state.rectArea, u4.ltc_1.value = r6.state.rectAreaLTC1, u4.ltc_2.value = r6.state.rectAreaLTC2, u4.pointLights.value = r6.state.point, u4.pointLightShadows.value = r6.state.pointShadow, u4.hemisphereLights.value = r6.state.hemi, u4.directionalShadowMap.value = r6.state.directionalShadowMap, u4.directionalShadowMatrix.value = r6.state.directionalShadowMatrix, u4.spotShadowMap.value = r6.state.spotShadowMap, u4.spotShadowMatrix.value = r6.state.spotShadowMatrix, u4.pointShadowMap.value = r6.state.pointShadowMap, u4.pointShadowMatrix.value = r6.state.pointShadowMatrix);
      const p4 = c4.getUniforms(), m3 = Hi.seqWithValue(p4.seq, u4);
      return i7.currentProgram = c4, i7.uniformsList = m3, c4;
    }
    function Ot2(t6, e9) {
      const n9 = Z2.get(t6);
      n9.outputEncoding = e9.outputEncoding, n9.instancing = e9.instancing, n9.skinning = e9.skinning, n9.morphTargets = e9.morphTargets, n9.morphNormals = e9.morphNormals, n9.morphColors = e9.morphColors, n9.morphTargetsCount = e9.morphTargetsCount, n9.numClippingPlanes = e9.numClippingPlanes, n9.numIntersection = e9.numClipIntersection, n9.vertexAlphas = e9.vertexAlphas, n9.vertexTangents = e9.vertexTangents, n9.toneMapping = e9.toneMapping;
    }
    Rt2.setAnimationLoop(function(t6) {
      Tt2 && Tt2(t6);
    }), typeof self != "undefined" && Rt2.setContext(self), this.setAnimationLoop = function(t6) {
      Tt2 = t6, _t2.setAnimationLoop(t6), t6 === null ? Rt2.stop() : Rt2.start();
    }, _t2.addEventListener("sessionstart", Et2), _t2.addEventListener("sessionend", At2), this.render = function(t6, e9) {
      if (e9 !== void 0 && e9.isCamera !== true)
        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (y3 === true)
        return;
      t6.autoUpdate === true && t6.updateMatrixWorld(), e9.parent === null && e9.updateMatrixWorld(), _t2.enabled === true && _t2.isPresenting === true && (_t2.cameraAutoUpdate === true && _t2.updateCamera(e9), e9 = _t2.getCamera()), t6.isScene === true && t6.onBeforeRender(v3, t6, e9, w3), d3 = lt2.get(t6, f3.length), d3.init(), f3.push(d3), G2.multiplyMatrices(e9.projectionMatrix, e9.matrixWorldInverse), F2.setFromProjectionMatrix(G2), z3 = this.localClippingEnabled, B2 = ht2.init(this.clippingPlanes, z3, e9), u3 = ot2.get(t6, p3.length), u3.init(), p3.push(u3), Ct2(t6, e9, 0, v3.sortObjects), u3.finish(), v3.sortObjects === true && u3.sort(P3, D2), B2 === true && ht2.beginShadows();
      const n9 = d3.state.shadowsArray;
      if (ct2.render(n9, t6, e9), B2 === true && ht2.endShadows(), this.info.autoReset === true && this.info.reset(), ut2.render(u3, t6), d3.setupLights(v3.physicallyCorrectLights), e9.isArrayCamera) {
        const n10 = e9.cameras;
        for (let e10 = 0, i7 = n10.length; e10 < i7; e10++) {
          const i8 = n10[e10];
          Lt2(u3, t6, i8, i8.viewport);
        }
      } else
        Lt2(u3, t6, e9);
      w3 !== null && (Q2.updateMultisampleRenderTarget(w3), Q2.updateRenderTargetMipmap(w3)), t6.isScene === true && t6.onAfterRender(v3, t6, e9), gt2.resetDefaultState(), M3 = -1, S4 = null, f3.pop(), d3 = f3.length > 0 ? f3[f3.length - 1] : null, p3.pop(), u3 = p3.length > 0 ? p3[p3.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return b3;
    }, this.getActiveMipmapLevel = function() {
      return _3;
    }, this.getRenderTarget = function() {
      return w3;
    }, this.setRenderTargetTextures = function(t6, e9, n9) {
      Z2.get(t6.texture).__webglTexture = e9, Z2.get(t6.depthTexture).__webglTexture = n9;
      const i7 = Z2.get(t6);
      i7.__hasExternalTextures = true, i7.__hasExternalTextures && (i7.__autoAllocateDepthBuffer = n9 === void 0, i7.__autoAllocateDepthBuffer || $3.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i7.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(t6, e9) {
      const n9 = Z2.get(t6);
      n9.__webglFramebuffer = e9, n9.__useDefaultFramebuffer = e9 === void 0;
    }, this.setRenderTarget = function(t6, e9 = 0, n9 = 0) {
      w3 = t6, b3 = e9, _3 = n9;
      let i7 = true;
      if (t6) {
        const e10 = Z2.get(t6);
        e10.__useDefaultFramebuffer !== void 0 ? (J2.bindFramebuffer(36160, null), i7 = false) : e10.__webglFramebuffer === void 0 ? Q2.setupRenderTarget(t6) : e10.__hasExternalTextures && Q2.rebindTextures(t6, Z2.get(t6.texture).__webglTexture, Z2.get(t6.depthTexture).__webglTexture);
      }
      let r6 = null, s7 = false, a5 = false;
      if (t6) {
        const n10 = t6.texture;
        (n10.isData3DTexture || n10.isDataArrayTexture) && (a5 = true);
        const i8 = Z2.get(t6).__webglFramebuffer;
        t6.isWebGLCubeRenderTarget ? (r6 = i8[e9], s7 = true) : r6 = Y2.isWebGL2 && t6.samples > 0 && Q2.useMultisampledRTT(t6) === false ? Z2.get(t6).__webglMultisampledFramebuffer : i8, T3.copy(t6.viewport), E3.copy(t6.scissor), A3 = t6.scissorTest;
      } else
        T3.copy(I3).multiplyScalar(L3).floor(), E3.copy(O2).multiplyScalar(L3).floor(), A3 = N3;
      if (J2.bindFramebuffer(36160, r6) && Y2.drawBuffers && i7 && J2.drawBuffers(t6, r6), J2.viewport(T3), J2.scissor(E3), J2.setScissorTest(A3), s7) {
        const i8 = Z2.get(t6.texture);
        vt2.framebufferTexture2D(36160, 36064, 34069 + e9, i8.__webglTexture, n9);
      } else if (a5) {
        const i8 = Z2.get(t6.texture), r7 = e9 || 0;
        vt2.framebufferTextureLayer(36160, 36064, i8.__webglTexture, n9 || 0, r7);
      }
      M3 = -1;
    }, this.readRenderTargetPixels = function(t6, e9, n9, i7, r6, s7, a5) {
      if (!t6 || !t6.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let o8 = Z2.get(t6).__webglFramebuffer;
      if (t6.isWebGLCubeRenderTarget && a5 !== void 0 && (o8 = o8[a5]), o8) {
        J2.bindFramebuffer(36160, o8);
        try {
          const a6 = t6.texture, o9 = a6.format, l7 = a6.type;
          if (o9 !== 1023 && ft2.convert(o9) !== vt2.getParameter(35739))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const h5 = l7 === 1016 && ($3.has("EXT_color_buffer_half_float") || Y2.isWebGL2 && $3.has("EXT_color_buffer_float"));
          if (!(l7 === 1009 || ft2.convert(l7) === vt2.getParameter(35738) || l7 === 1015 && (Y2.isWebGL2 || $3.has("OES_texture_float") || $3.has("WEBGL_color_buffer_float")) || h5))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          e9 >= 0 && e9 <= t6.width - i7 && n9 >= 0 && n9 <= t6.height - r6 && vt2.readPixels(e9, n9, i7, r6, ft2.convert(o9), ft2.convert(l7), s7);
        } finally {
          const t7 = w3 !== null ? Z2.get(w3).__webglFramebuffer : null;
          J2.bindFramebuffer(36160, t7);
        }
      }
    }, this.copyFramebufferToTexture = function(t6, e9, n9 = 0) {
      if (e9.isFramebufferTexture !== true)
        return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
      const i7 = Math.pow(2, -n9), r6 = Math.floor(e9.image.width * i7), s7 = Math.floor(e9.image.height * i7);
      Q2.setTexture2D(e9, 0), vt2.copyTexSubImage2D(3553, n9, 0, 0, t6.x, t6.y, r6, s7), J2.unbindTexture();
    }, this.copyTextureToTexture = function(t6, e9, n9, i7 = 0) {
      const r6 = e9.image.width, s7 = e9.image.height, a5 = ft2.convert(n9.format), o8 = ft2.convert(n9.type);
      Q2.setTexture2D(n9, 0), vt2.pixelStorei(37440, n9.flipY), vt2.pixelStorei(37441, n9.premultiplyAlpha), vt2.pixelStorei(3317, n9.unpackAlignment), e9.isDataTexture ? vt2.texSubImage2D(3553, i7, t6.x, t6.y, r6, s7, a5, o8, e9.image.data) : e9.isCompressedTexture ? vt2.compressedTexSubImage2D(3553, i7, t6.x, t6.y, e9.mipmaps[0].width, e9.mipmaps[0].height, a5, e9.mipmaps[0].data) : vt2.texSubImage2D(3553, i7, t6.x, t6.y, a5, o8, e9.image), i7 === 0 && n9.generateMipmaps && vt2.generateMipmap(3553), J2.unbindTexture();
    }, this.copyTextureToTexture3D = function(t6, e9, n9, i7, r6 = 0) {
      if (v3.isWebGL1Renderer)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const s7 = t6.max.x - t6.min.x + 1, a5 = t6.max.y - t6.min.y + 1, o8 = t6.max.z - t6.min.z + 1, l7 = ft2.convert(i7.format), h5 = ft2.convert(i7.type);
      let c4;
      if (i7.isData3DTexture)
        Q2.setTexture3D(i7, 0), c4 = 32879;
      else {
        if (!i7.isDataArrayTexture)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        Q2.setTexture2DArray(i7, 0), c4 = 35866;
      }
      vt2.pixelStorei(37440, i7.flipY), vt2.pixelStorei(37441, i7.premultiplyAlpha), vt2.pixelStorei(3317, i7.unpackAlignment);
      const u4 = vt2.getParameter(3314), d4 = vt2.getParameter(32878), p4 = vt2.getParameter(3316), m3 = vt2.getParameter(3315), f4 = vt2.getParameter(32877), g3 = n9.isCompressedTexture ? n9.mipmaps[0] : n9.image;
      vt2.pixelStorei(3314, g3.width), vt2.pixelStorei(32878, g3.height), vt2.pixelStorei(3316, t6.min.x), vt2.pixelStorei(3315, t6.min.y), vt2.pixelStorei(32877, t6.min.z), n9.isDataTexture || n9.isData3DTexture ? vt2.texSubImage3D(c4, r6, e9.x, e9.y, e9.z, s7, a5, o8, l7, h5, g3.data) : n9.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), vt2.compressedTexSubImage3D(c4, r6, e9.x, e9.y, e9.z, s7, a5, o8, l7, g3.data)) : vt2.texSubImage3D(c4, r6, e9.x, e9.y, e9.z, s7, a5, o8, l7, h5, g3), vt2.pixelStorei(3314, u4), vt2.pixelStorei(32878, d4), vt2.pixelStorei(3316, p4), vt2.pixelStorei(3315, m3), vt2.pixelStorei(32877, f4), r6 === 0 && i7.generateMipmaps && vt2.generateMipmap(c4), J2.unbindTexture();
    }, this.initTexture = function(t6) {
      Q2.setTexture2D(t6, 0), J2.unbindTexture();
    }, this.resetState = function() {
      b3 = 0, _3 = 0, w3 = null, J2.reset(), gt2.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  Or.prototype.isWebGLRenderer = true;
  (class extends Or {
  }).prototype.isWebGL1Renderer = true;
  var Nr = class extends Wt {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(t5, e8) {
      return super.copy(t5, e8), t5.background !== null && (this.background = t5.background.clone()), t5.environment !== null && (this.environment = t5.environment.clone()), t5.fog !== null && (this.fog = t5.fog.clone()), t5.overrideMaterial !== null && (this.overrideMaterial = t5.overrideMaterial.clone()), this.autoUpdate = t5.autoUpdate, this.matrixAutoUpdate = t5.matrixAutoUpdate, this;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return this.fog !== null && (e8.object.fog = this.fog.toJSON()), e8;
    }
  };
  Nr.prototype.isScene = true;
  var Fr = class {
    constructor(t5, e8) {
      this.array = t5, this.stride = e8, this.count = t5 !== void 0 ? t5.length / e8 : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = l5();
    }
    onUploadCallback() {
    }
    set needsUpdate(t5) {
      t5 === true && this.version++;
    }
    setUsage(t5) {
      return this.usage = t5, this;
    }
    copy(t5) {
      return this.array = new t5.array.constructor(t5.array), this.count = t5.count, this.stride = t5.stride, this.usage = t5.usage, this;
    }
    copyAt(t5, e8, n8) {
      t5 *= this.stride, n8 *= e8.stride;
      for (let i6 = 0, r5 = this.stride; i6 < r5; i6++)
        this.array[t5 + i6] = e8.array[n8 + i6];
      return this;
    }
    set(t5, e8 = 0) {
      return this.array.set(t5, e8), this;
    }
    clone(t5) {
      t5.arrayBuffers === void 0 && (t5.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = l5()), t5.arrayBuffers[this.array.buffer._uuid] === void 0 && (t5.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e8 = new this.array.constructor(t5.arrayBuffers[this.array.buffer._uuid]), n8 = new this.constructor(e8, this.stride);
      return n8.setUsage(this.usage), n8;
    }
    onUpload(t5) {
      return this.onUploadCallback = t5, this;
    }
    toJSON(t5) {
      return t5.arrayBuffers === void 0 && (t5.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = l5()), t5.arrayBuffers[this.array.buffer._uuid] === void 0 && (t5.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  };
  Fr.prototype.isInterleavedBuffer = true;
  var Ur = new V2();
  var kr = class {
    constructor(t5, e8, n8, i6 = false) {
      this.name = "", this.data = t5, this.itemSize = e8, this.offset = n8, this.normalized = i6 === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t5) {
      this.data.needsUpdate = t5;
    }
    applyMatrix4(t5) {
      for (let e8 = 0, n8 = this.data.count; e8 < n8; e8++)
        Ur.fromBufferAttribute(this, e8), Ur.applyMatrix4(t5), this.setXYZ(e8, Ur.x, Ur.y, Ur.z);
      return this;
    }
    applyNormalMatrix(t5) {
      for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
        Ur.fromBufferAttribute(this, e8), Ur.applyNormalMatrix(t5), this.setXYZ(e8, Ur.x, Ur.y, Ur.z);
      return this;
    }
    transformDirection(t5) {
      for (let e8 = 0, n8 = this.count; e8 < n8; e8++)
        Ur.fromBufferAttribute(this, e8), Ur.transformDirection(t5), this.setXYZ(e8, Ur.x, Ur.y, Ur.z);
      return this;
    }
    setX(t5, e8) {
      return this.data.array[t5 * this.data.stride + this.offset] = e8, this;
    }
    setY(t5, e8) {
      return this.data.array[t5 * this.data.stride + this.offset + 1] = e8, this;
    }
    setZ(t5, e8) {
      return this.data.array[t5 * this.data.stride + this.offset + 2] = e8, this;
    }
    setW(t5, e8) {
      return this.data.array[t5 * this.data.stride + this.offset + 3] = e8, this;
    }
    getX(t5) {
      return this.data.array[t5 * this.data.stride + this.offset];
    }
    getY(t5) {
      return this.data.array[t5 * this.data.stride + this.offset + 1];
    }
    getZ(t5) {
      return this.data.array[t5 * this.data.stride + this.offset + 2];
    }
    getW(t5) {
      return this.data.array[t5 * this.data.stride + this.offset + 3];
    }
    setXY(t5, e8, n8) {
      return t5 = t5 * this.data.stride + this.offset, this.data.array[t5 + 0] = e8, this.data.array[t5 + 1] = n8, this;
    }
    setXYZ(t5, e8, n8, i6) {
      return t5 = t5 * this.data.stride + this.offset, this.data.array[t5 + 0] = e8, this.data.array[t5 + 1] = n8, this.data.array[t5 + 2] = i6, this;
    }
    setXYZW(t5, e8, n8, i6, r5) {
      return t5 = t5 * this.data.stride + this.offset, this.data.array[t5 + 0] = e8, this.data.array[t5 + 1] = n8, this.data.array[t5 + 2] = i6, this.data.array[t5 + 3] = r5, this;
    }
    clone(t5) {
      if (t5 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const t6 = [];
        for (let e8 = 0; e8 < this.count; e8++) {
          const n8 = e8 * this.data.stride + this.offset;
          for (let e9 = 0; e9 < this.itemSize; e9++)
            t6.push(this.data.array[n8 + e9]);
        }
        return new oe(new this.array.constructor(t6), this.itemSize, this.normalized);
      }
      return t5.interleavedBuffers === void 0 && (t5.interleavedBuffers = {}), t5.interleavedBuffers[this.data.uuid] === void 0 && (t5.interleavedBuffers[this.data.uuid] = this.data.clone(t5)), new kr(t5.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t5) {
      if (t5 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const t6 = [];
        for (let e8 = 0; e8 < this.count; e8++) {
          const n8 = e8 * this.data.stride + this.offset;
          for (let e9 = 0; e9 < this.itemSize; e9++)
            t6.push(this.data.array[n8 + e9]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: t6, normalized: this.normalized };
      }
      return t5.interleavedBuffers === void 0 && (t5.interleavedBuffers = {}), t5.interleavedBuffers[this.data.uuid] === void 0 && (t5.interleavedBuffers[this.data.uuid] = this.data.toJSON(t5)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  };
  kr.prototype.isInterleavedBufferAttribute = true;
  var Br = class extends ie {
    constructor(t5) {
      super(), this.type = "SpriteMaterial", this.color = new L2(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.map = t5.map, this.alphaMap = t5.alphaMap, this.rotation = t5.rotation, this.sizeAttenuation = t5.sizeAttenuation, this;
    }
  };
  var zr;
  Br.prototype.isSpriteMaterial = true;
  var Hr = new V2();
  var Vr = new V2();
  var Gr = new V2();
  var Wr = new g2();
  var jr = new g2();
  var qr = new xt();
  var Xr = new V2();
  var $r = new V2();
  var Yr = new V2();
  var Jr = new g2();
  var Kr = new g2();
  var Zr = new g2();
  function Qr(t5, e8, n8, i6, r5, s6) {
    Wr.subVectors(t5, n8).addScalar(0.5).multiply(i6), r5 !== void 0 ? (jr.x = s6 * Wr.x - r5 * Wr.y, jr.y = r5 * Wr.x + s6 * Wr.y) : jr.copy(Wr), t5.copy(e8), t5.x += jr.x, t5.y += jr.y, t5.applyMatrix4(qr);
  }
  (class extends Wt {
    constructor(t5) {
      if (super(), this.type = "Sprite", zr === void 0) {
        zr = new ye();
        const t6 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e8 = new Fr(t6, 5);
        zr.setIndex([0, 1, 2, 0, 2, 3]), zr.setAttribute("position", new kr(e8, 3, 0, false)), zr.setAttribute("uv", new kr(e8, 2, 3, false));
      }
      this.geometry = zr, this.material = t5 !== void 0 ? t5 : new Br(), this.center = new g2(0.5, 0.5);
    }
    raycast(t5, e8) {
      t5.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Vr.setFromMatrixScale(this.matrixWorld), qr.copy(t5.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t5.camera.matrixWorldInverse, this.matrixWorld), Gr.setFromMatrixPosition(this.modelViewMatrix), t5.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && Vr.multiplyScalar(-Gr.z);
      const n8 = this.material.rotation;
      let i6, r5;
      n8 !== 0 && (r5 = Math.cos(n8), i6 = Math.sin(n8));
      const s6 = this.center;
      Qr(Xr.set(-0.5, -0.5, 0), Gr, s6, Vr, i6, r5), Qr($r.set(0.5, -0.5, 0), Gr, s6, Vr, i6, r5), Qr(Yr.set(0.5, 0.5, 0), Gr, s6, Vr, i6, r5), Jr.set(0, 0), Kr.set(1, 0), Zr.set(1, 1);
      let a4 = t5.ray.intersectTriangle(Xr, $r, Yr, false, Hr);
      if (a4 === null && (Qr($r.set(-0.5, 0.5, 0), Gr, s6, Vr, i6, r5), Kr.set(0, 1), a4 = t5.ray.intersectTriangle(Xr, Yr, $r, false, Hr), a4 === null))
        return;
      const o7 = t5.ray.origin.distanceTo(Hr);
      o7 < t5.near || o7 > t5.far || e8.push({ distance: o7, point: Hr.clone(), uv: ee.getUV(Hr, Xr, $r, Yr, Jr, Kr, Zr, new g2()), face: null, object: this });
    }
    copy(t5) {
      return super.copy(t5), t5.center !== void 0 && this.center.copy(t5.center), this.material = t5.material, this;
    }
  }).prototype.isSprite = true;
  var ts = new V2();
  var es = new U();
  var ns = new U();
  var is = new V2();
  var rs = new xt();
  var ss = class extends Fe {
    constructor(t5, e8) {
      super(t5, e8), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new xt(), this.bindMatrixInverse = new xt();
    }
    copy(t5) {
      return super.copy(t5), this.bindMode = t5.bindMode, this.bindMatrix.copy(t5.bindMatrix), this.bindMatrixInverse.copy(t5.bindMatrixInverse), this.skeleton = t5.skeleton, this;
    }
    bind(t5, e8) {
      this.skeleton = t5, e8 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e8 = this.matrixWorld), this.bindMatrix.copy(e8), this.bindMatrixInverse.copy(e8).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t5 = new U(), e8 = this.geometry.attributes.skinWeight;
      for (let n8 = 0, i6 = e8.count; n8 < i6; n8++) {
        t5.fromBufferAttribute(e8, n8);
        const i7 = 1 / t5.manhattanLength();
        i7 !== 1 / 0 ? t5.multiplyScalar(i7) : t5.set(1, 0, 0, 0), e8.setXYZW(n8, t5.x, t5.y, t5.z, t5.w);
      }
    }
    updateMatrixWorld(t5) {
      super.updateMatrixWorld(t5), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(t5, e8) {
      const n8 = this.skeleton, i6 = this.geometry;
      es.fromBufferAttribute(i6.attributes.skinIndex, t5), ns.fromBufferAttribute(i6.attributes.skinWeight, t5), ts.copy(e8).applyMatrix4(this.bindMatrix), e8.set(0, 0, 0);
      for (let t6 = 0; t6 < 4; t6++) {
        const i7 = ns.getComponent(t6);
        if (i7 !== 0) {
          const r5 = es.getComponent(t6);
          rs.multiplyMatrices(n8.bones[r5].matrixWorld, n8.boneInverses[r5]), e8.addScaledVector(is.copy(ts).applyMatrix4(rs), i7);
        }
      }
      return e8.applyMatrix4(this.bindMatrixInverse);
    }
  };
  ss.prototype.isSkinnedMesh = true;
  var as = class extends Wt {
    constructor() {
      super(), this.type = "Bone";
    }
  };
  as.prototype.isBone = true;
  var os = class extends F {
    constructor(t5 = null, e8 = 1, n8 = 1, i6, r5, s6, a4, o7, l6 = 1003, h4 = 1003, c3, u3) {
      super(null, s6, a4, o7, l6, h4, i6, r5, c3, u3), this.image = { data: t5, width: e8, height: n8 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  };
  os.prototype.isDataTexture = true;
  var ls = new xt();
  var hs = new xt();
  var cs = class {
    constructor(t5 = [], e8 = []) {
      this.uuid = l5(), this.bones = t5.slice(0), this.boneInverses = e8, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      const t5 = this.bones, e8 = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * t5.length), e8.length === 0)
        this.calculateInverses();
      else if (t5.length !== e8.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let t6 = 0, e9 = this.bones.length; t6 < e9; t6++)
          this.boneInverses.push(new xt());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t5 = 0, e8 = this.bones.length; t5 < e8; t5++) {
        const e9 = new xt();
        this.bones[t5] && e9.copy(this.bones[t5].matrixWorld).invert(), this.boneInverses.push(e9);
      }
    }
    pose() {
      for (let t5 = 0, e8 = this.bones.length; t5 < e8; t5++) {
        const e9 = this.bones[t5];
        e9 && e9.matrixWorld.copy(this.boneInverses[t5]).invert();
      }
      for (let t5 = 0, e8 = this.bones.length; t5 < e8; t5++) {
        const e9 = this.bones[t5];
        e9 && (e9.parent && e9.parent.isBone ? (e9.matrix.copy(e9.parent.matrixWorld).invert(), e9.matrix.multiply(e9.matrixWorld)) : e9.matrix.copy(e9.matrixWorld), e9.matrix.decompose(e9.position, e9.quaternion, e9.scale));
      }
    }
    update() {
      const t5 = this.bones, e8 = this.boneInverses, n8 = this.boneMatrices, i6 = this.boneTexture;
      for (let i7 = 0, r5 = t5.length; i7 < r5; i7++) {
        const r6 = t5[i7] ? t5[i7].matrixWorld : hs;
        ls.multiplyMatrices(r6, e8[i7]), ls.toArray(n8, 16 * i7);
      }
      i6 !== null && (i6.needsUpdate = true);
    }
    clone() {
      return new cs(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t5 = Math.sqrt(4 * this.bones.length);
      t5 = p2(t5), t5 = Math.max(t5, 4);
      const e8 = new Float32Array(t5 * t5 * 4);
      e8.set(this.boneMatrices);
      const n8 = new os(e8, t5, t5, 1023, 1015);
      return n8.needsUpdate = true, this.boneMatrices = e8, this.boneTexture = n8, this.boneTextureSize = t5, this;
    }
    getBoneByName(t5) {
      for (let e8 = 0, n8 = this.bones.length; e8 < n8; e8++) {
        const n9 = this.bones[e8];
        if (n9.name === t5)
          return n9;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(t5, e8) {
      this.uuid = t5.uuid;
      for (let n8 = 0, i6 = t5.bones.length; n8 < i6; n8++) {
        const i7 = t5.bones[n8];
        let r5 = e8[i7];
        r5 === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", i7), r5 = new as()), this.bones.push(r5), this.boneInverses.push(new xt().fromArray(t5.boneInverses[n8]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t5 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
      t5.uuid = this.uuid;
      const e8 = this.bones, n8 = this.boneInverses;
      for (let i6 = 0, r5 = e8.length; i6 < r5; i6++) {
        const r6 = e8[i6];
        t5.bones.push(r6.uuid);
        const s6 = n8[i6];
        t5.boneInverses.push(s6.toArray());
      }
      return t5;
    }
  };
  var us = class extends oe {
    constructor(t5, e8, n8, i6 = 1) {
      typeof n8 == "number" && (i6 = n8, n8 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t5, e8, n8), this.meshPerAttribute = i6;
    }
    copy(t5) {
      return super.copy(t5), this.meshPerAttribute = t5.meshPerAttribute, this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.meshPerAttribute = this.meshPerAttribute, t5.isInstancedBufferAttribute = true, t5;
    }
  };
  us.prototype.isInstancedBufferAttribute = true;
  var ds = new xt();
  var ps = new xt();
  var ms = [];
  var fs = new Fe();
  (class extends Fe {
    constructor(t5, e8, n8) {
      super(t5, e8), this.instanceMatrix = new us(new Float32Array(16 * n8), 16), this.instanceColor = null, this.count = n8, this.frustumCulled = false;
    }
    copy(t5) {
      return super.copy(t5), this.instanceMatrix.copy(t5.instanceMatrix), t5.instanceColor !== null && (this.instanceColor = t5.instanceColor.clone()), this.count = t5.count, this;
    }
    getColorAt(t5, e8) {
      e8.fromArray(this.instanceColor.array, 3 * t5);
    }
    getMatrixAt(t5, e8) {
      e8.fromArray(this.instanceMatrix.array, 16 * t5);
    }
    raycast(t5, e8) {
      const n8 = this.matrixWorld, i6 = this.count;
      if (fs.geometry = this.geometry, fs.material = this.material, fs.material !== void 0)
        for (let r5 = 0; r5 < i6; r5++) {
          this.getMatrixAt(r5, ds), ps.multiplyMatrices(n8, ds), fs.matrixWorld = ps, fs.raycast(t5, ms);
          for (let t6 = 0, n9 = ms.length; t6 < n9; t6++) {
            const n10 = ms[t6];
            n10.instanceId = r5, n10.object = this, e8.push(n10);
          }
          ms.length = 0;
        }
    }
    setColorAt(t5, e8) {
      this.instanceColor === null && (this.instanceColor = new us(new Float32Array(3 * this.instanceMatrix.count), 3)), e8.toArray(this.instanceColor.array, 3 * t5);
    }
    setMatrixAt(t5, e8) {
      e8.toArray(this.instanceMatrix.array, 16 * t5);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }).prototype.isInstancedMesh = true;
  var gs = class extends ie {
    constructor(t5) {
      super(), this.type = "LineBasicMaterial", this.color = new L2(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.linewidth = t5.linewidth, this.linecap = t5.linecap, this.linejoin = t5.linejoin, this;
    }
  };
  gs.prototype.isLineBasicMaterial = true;
  var vs = new V2();
  var ys = new V2();
  var xs = new xt();
  var bs = new yt();
  var _s = new ct();
  var ws = class extends Wt {
    constructor(t5 = new ye(), e8 = new gs()) {
      super(), this.type = "Line", this.geometry = t5, this.material = e8, this.updateMorphTargets();
    }
    copy(t5) {
      return super.copy(t5), this.material = t5.material, this.geometry = t5.geometry, this;
    }
    computeLineDistances() {
      const t5 = this.geometry;
      if (t5.isBufferGeometry)
        if (t5.index === null) {
          const e8 = t5.attributes.position, n8 = [0];
          for (let t6 = 1, i6 = e8.count; t6 < i6; t6++)
            vs.fromBufferAttribute(e8, t6 - 1), ys.fromBufferAttribute(e8, t6), n8[t6] = n8[t6 - 1], n8[t6] += vs.distanceTo(ys);
          t5.setAttribute("lineDistance", new ce(n8, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t5.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
    raycast(t5, e8) {
      const n8 = this.geometry, i6 = this.matrixWorld, r5 = t5.params.Line.threshold, s6 = n8.drawRange;
      if (n8.boundingSphere === null && n8.computeBoundingSphere(), _s.copy(n8.boundingSphere), _s.applyMatrix4(i6), _s.radius += r5, t5.ray.intersectsSphere(_s) === false)
        return;
      xs.copy(i6).invert(), bs.copy(t5.ray).applyMatrix4(xs);
      const a4 = r5 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o7 = a4 * a4, l6 = new V2(), h4 = new V2(), c3 = new V2(), u3 = new V2(), d3 = this.isLineSegments ? 2 : 1;
      if (n8.isBufferGeometry) {
        const i7 = n8.index, r6 = n8.attributes.position;
        if (i7 !== null) {
          for (let n9 = Math.max(0, s6.start), a5 = Math.min(i7.count, s6.start + s6.count) - 1; n9 < a5; n9 += d3) {
            const s7 = i7.getX(n9), a6 = i7.getX(n9 + 1);
            l6.fromBufferAttribute(r6, s7), h4.fromBufferAttribute(r6, a6);
            if (bs.distanceSqToSegment(l6, h4, u3, c3) > o7)
              continue;
            u3.applyMatrix4(this.matrixWorld);
            const d4 = t5.ray.origin.distanceTo(u3);
            d4 < t5.near || d4 > t5.far || e8.push({ distance: d4, point: c3.clone().applyMatrix4(this.matrixWorld), index: n9, face: null, faceIndex: null, object: this });
          }
        } else {
          for (let n9 = Math.max(0, s6.start), i8 = Math.min(r6.count, s6.start + s6.count) - 1; n9 < i8; n9 += d3) {
            l6.fromBufferAttribute(r6, n9), h4.fromBufferAttribute(r6, n9 + 1);
            if (bs.distanceSqToSegment(l6, h4, u3, c3) > o7)
              continue;
            u3.applyMatrix4(this.matrixWorld);
            const i9 = t5.ray.origin.distanceTo(u3);
            i9 < t5.near || i9 > t5.far || e8.push({ distance: i9, point: c3.clone().applyMatrix4(this.matrixWorld), index: n9, face: null, faceIndex: null, object: this });
          }
        }
      } else
        n8.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t5 = this.geometry;
      if (t5.isBufferGeometry) {
        const e8 = t5.morphAttributes, n8 = Object.keys(e8);
        if (n8.length > 0) {
          const t6 = e8[n8[0]];
          if (t6 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e9 = 0, n9 = t6.length; e9 < n9; e9++) {
              const n10 = t6[e9].name || String(e9);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n10] = e9;
            }
          }
        }
      } else {
        const e8 = t5.morphTargets;
        e8 !== void 0 && e8.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  ws.prototype.isLine = true;
  var Ms = new V2();
  var Ss = new V2();
  var Ts = class extends ws {
    constructor(t5, e8) {
      super(t5, e8), this.type = "LineSegments";
    }
    computeLineDistances() {
      const t5 = this.geometry;
      if (t5.isBufferGeometry)
        if (t5.index === null) {
          const e8 = t5.attributes.position, n8 = [];
          for (let t6 = 0, i6 = e8.count; t6 < i6; t6 += 2)
            Ms.fromBufferAttribute(e8, t6), Ss.fromBufferAttribute(e8, t6 + 1), n8[t6] = t6 === 0 ? 0 : n8[t6 - 1], n8[t6 + 1] = n8[t6] + Ms.distanceTo(Ss);
          t5.setAttribute("lineDistance", new ce(n8, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t5.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  };
  Ts.prototype.isLineSegments = true;
  var Es = class extends ws {
    constructor(t5, e8) {
      super(t5, e8), this.type = "LineLoop";
    }
  };
  Es.prototype.isLineLoop = true;
  var As = class extends ie {
    constructor(t5) {
      super(), this.type = "PointsMaterial", this.color = new L2(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.map = t5.map, this.alphaMap = t5.alphaMap, this.size = t5.size, this.sizeAttenuation = t5.sizeAttenuation, this;
    }
  };
  As.prototype.isPointsMaterial = true;
  var Rs = new xt();
  var Cs = new yt();
  var Ls = new ct();
  var Ps = new V2();
  var Ds = class extends Wt {
    constructor(t5 = new ye(), e8 = new As()) {
      super(), this.type = "Points", this.geometry = t5, this.material = e8, this.updateMorphTargets();
    }
    copy(t5) {
      return super.copy(t5), this.material = t5.material, this.geometry = t5.geometry, this;
    }
    raycast(t5, e8) {
      const n8 = this.geometry, i6 = this.matrixWorld, r5 = t5.params.Points.threshold, s6 = n8.drawRange;
      if (n8.boundingSphere === null && n8.computeBoundingSphere(), Ls.copy(n8.boundingSphere), Ls.applyMatrix4(i6), Ls.radius += r5, t5.ray.intersectsSphere(Ls) === false)
        return;
      Rs.copy(i6).invert(), Cs.copy(t5.ray).applyMatrix4(Rs);
      const a4 = r5 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o7 = a4 * a4;
      if (n8.isBufferGeometry) {
        const r6 = n8.index, a5 = n8.attributes.position;
        if (r6 !== null) {
          for (let n9 = Math.max(0, s6.start), l6 = Math.min(r6.count, s6.start + s6.count); n9 < l6; n9++) {
            const s7 = r6.getX(n9);
            Ps.fromBufferAttribute(a5, s7), Is(Ps, s7, o7, i6, t5, e8, this);
          }
        } else {
          for (let n9 = Math.max(0, s6.start), r7 = Math.min(a5.count, s6.start + s6.count); n9 < r7; n9++)
            Ps.fromBufferAttribute(a5, n9), Is(Ps, n9, o7, i6, t5, e8, this);
        }
      } else
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t5 = this.geometry;
      if (t5.isBufferGeometry) {
        const e8 = t5.morphAttributes, n8 = Object.keys(e8);
        if (n8.length > 0) {
          const t6 = e8[n8[0]];
          if (t6 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e9 = 0, n9 = t6.length; e9 < n9; e9++) {
              const n10 = t6[e9].name || String(e9);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n10] = e9;
            }
          }
        }
      } else {
        const e8 = t5.morphTargets;
        e8 !== void 0 && e8.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  function Is(t5, e8, n8, i6, r5, s6, a4) {
    const o7 = Cs.distanceSqToPoint(t5);
    if (o7 < n8) {
      const n9 = new V2();
      Cs.closestPointToPoint(t5, n9), n9.applyMatrix4(i6);
      const l6 = r5.ray.origin.distanceTo(n9);
      if (l6 < r5.near || l6 > r5.far)
        return;
      s6.push({ distance: l6, distanceToRay: Math.sqrt(o7), point: n9, index: e8, face: null, object: a4 });
    }
  }
  Ds.prototype.isPoints = true;
  (class extends F {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7, l6) {
      super(t5, e8, n8, i6, r5, s6, a4, o7, l6), this.minFilter = s6 !== void 0 ? s6 : 1006, this.magFilter = r5 !== void 0 ? r5 : 1006, this.generateMipmaps = false;
      const h4 = this;
      "requestVideoFrameCallback" in t5 && t5.requestVideoFrameCallback(function e9() {
        h4.needsUpdate = true, t5.requestVideoFrameCallback(e9);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const t5 = this.image;
      "requestVideoFrameCallback" in t5 === false && t5.readyState >= t5.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }).prototype.isVideoTexture = true;
  (class extends F {
    constructor(t5, e8, n8) {
      super({ width: t5, height: e8 }), this.format = n8, this.magFilter = 1003, this.minFilter = 1003, this.generateMipmaps = false, this.needsUpdate = true;
    }
  }).prototype.isFramebufferTexture = true;
  var Os = class extends F {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4, c3, u3) {
      super(null, s6, a4, o7, l6, h4, i6, r5, c3, u3), this.image = { width: e8, height: n8 }, this.mipmaps = t5, this.flipY = false, this.generateMipmaps = false;
    }
  };
  Os.prototype.isCompressedTexture = true;
  (class extends F {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7, l6) {
      super(t5, e8, n8, i6, r5, s6, a4, o7, l6), this.needsUpdate = true;
    }
  }).prototype.isCanvasTexture = true;
  var Ns = class {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t5, e8) {
      const n8 = this.getUtoTmapping(t5);
      return this.getPoint(n8, e8);
    }
    getPoints(t5 = 5) {
      const e8 = [];
      for (let n8 = 0; n8 <= t5; n8++)
        e8.push(this.getPoint(n8 / t5));
      return e8;
    }
    getSpacedPoints(t5 = 5) {
      const e8 = [];
      for (let n8 = 0; n8 <= t5; n8++)
        e8.push(this.getPointAt(n8 / t5));
      return e8;
    }
    getLength() {
      const t5 = this.getLengths();
      return t5[t5.length - 1];
    }
    getLengths(t5 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t5 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const e8 = [];
      let n8, i6 = this.getPoint(0), r5 = 0;
      e8.push(0);
      for (let s6 = 1; s6 <= t5; s6++)
        n8 = this.getPoint(s6 / t5), r5 += n8.distanceTo(i6), e8.push(r5), i6 = n8;
      return this.cacheArcLengths = e8, e8;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(t5, e8) {
      const n8 = this.getLengths();
      let i6 = 0;
      const r5 = n8.length;
      let s6;
      s6 = e8 || t5 * n8[r5 - 1];
      let a4, o7 = 0, l6 = r5 - 1;
      for (; o7 <= l6; )
        if (i6 = Math.floor(o7 + (l6 - o7) / 2), a4 = n8[i6] - s6, a4 < 0)
          o7 = i6 + 1;
        else {
          if (!(a4 > 0)) {
            l6 = i6;
            break;
          }
          l6 = i6 - 1;
        }
      if (i6 = l6, n8[i6] === s6)
        return i6 / (r5 - 1);
      const h4 = n8[i6];
      return (i6 + (s6 - h4) / (n8[i6 + 1] - h4)) / (r5 - 1);
    }
    getTangent(t5, e8) {
      const n8 = 1e-4;
      let i6 = t5 - n8, r5 = t5 + n8;
      i6 < 0 && (i6 = 0), r5 > 1 && (r5 = 1);
      const s6 = this.getPoint(i6), a4 = this.getPoint(r5), o7 = e8 || (s6.isVector2 ? new g2() : new V2());
      return o7.copy(a4).sub(s6).normalize(), o7;
    }
    getTangentAt(t5, e8) {
      const n8 = this.getUtoTmapping(t5);
      return this.getTangent(n8, e8);
    }
    computeFrenetFrames(t5, e8) {
      const n8 = new V2(), i6 = [], r5 = [], s6 = [], a4 = new V2(), o7 = new xt();
      for (let e9 = 0; e9 <= t5; e9++) {
        const n9 = e9 / t5;
        i6[e9] = this.getTangentAt(n9, new V2());
      }
      r5[0] = new V2(), s6[0] = new V2();
      let l6 = Number.MAX_VALUE;
      const c3 = Math.abs(i6[0].x), u3 = Math.abs(i6[0].y), d3 = Math.abs(i6[0].z);
      c3 <= l6 && (l6 = c3, n8.set(1, 0, 0)), u3 <= l6 && (l6 = u3, n8.set(0, 1, 0)), d3 <= l6 && n8.set(0, 0, 1), a4.crossVectors(i6[0], n8).normalize(), r5[0].crossVectors(i6[0], a4), s6[0].crossVectors(i6[0], r5[0]);
      for (let e9 = 1; e9 <= t5; e9++) {
        if (r5[e9] = r5[e9 - 1].clone(), s6[e9] = s6[e9 - 1].clone(), a4.crossVectors(i6[e9 - 1], i6[e9]), a4.length() > Number.EPSILON) {
          a4.normalize();
          const t6 = Math.acos(h3(i6[e9 - 1].dot(i6[e9]), -1, 1));
          r5[e9].applyMatrix4(o7.makeRotationAxis(a4, t6));
        }
        s6[e9].crossVectors(i6[e9], r5[e9]);
      }
      if (e8 === true) {
        let e9 = Math.acos(h3(r5[0].dot(r5[t5]), -1, 1));
        e9 /= t5, i6[0].dot(a4.crossVectors(r5[0], r5[t5])) > 0 && (e9 = -e9);
        for (let n9 = 1; n9 <= t5; n9++)
          r5[n9].applyMatrix4(o7.makeRotationAxis(i6[n9], e9 * n9)), s6[n9].crossVectors(i6[n9], r5[n9]);
      }
      return { tangents: i6, normals: r5, binormals: s6 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t5) {
      return this.arcLengthDivisions = t5.arcLengthDivisions, this;
    }
    toJSON() {
      const t5 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return t5.arcLengthDivisions = this.arcLengthDivisions, t5.type = this.type, t5;
    }
    fromJSON(t5) {
      return this.arcLengthDivisions = t5.arcLengthDivisions, this;
    }
  };
  var Fs = class extends Ns {
    constructor(t5 = 0, e8 = 0, n8 = 1, i6 = 1, r5 = 0, s6 = 2 * Math.PI, a4 = false, o7 = 0) {
      super(), this.type = "EllipseCurve", this.aX = t5, this.aY = e8, this.xRadius = n8, this.yRadius = i6, this.aStartAngle = r5, this.aEndAngle = s6, this.aClockwise = a4, this.aRotation = o7;
    }
    getPoint(t5, e8) {
      const n8 = e8 || new g2(), i6 = 2 * Math.PI;
      let r5 = this.aEndAngle - this.aStartAngle;
      const s6 = Math.abs(r5) < Number.EPSILON;
      for (; r5 < 0; )
        r5 += i6;
      for (; r5 > i6; )
        r5 -= i6;
      r5 < Number.EPSILON && (r5 = s6 ? 0 : i6), this.aClockwise !== true || s6 || (r5 === i6 ? r5 = -i6 : r5 -= i6);
      const a4 = this.aStartAngle + t5 * r5;
      let o7 = this.aX + this.xRadius * Math.cos(a4), l6 = this.aY + this.yRadius * Math.sin(a4);
      if (this.aRotation !== 0) {
        const t6 = Math.cos(this.aRotation), e9 = Math.sin(this.aRotation), n9 = o7 - this.aX, i7 = l6 - this.aY;
        o7 = n9 * t6 - i7 * e9 + this.aX, l6 = n9 * e9 + i7 * t6 + this.aY;
      }
      return n8.set(o7, l6);
    }
    copy(t5) {
      return super.copy(t5), this.aX = t5.aX, this.aY = t5.aY, this.xRadius = t5.xRadius, this.yRadius = t5.yRadius, this.aStartAngle = t5.aStartAngle, this.aEndAngle = t5.aEndAngle, this.aClockwise = t5.aClockwise, this.aRotation = t5.aRotation, this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.aX = this.aX, t5.aY = this.aY, t5.xRadius = this.xRadius, t5.yRadius = this.yRadius, t5.aStartAngle = this.aStartAngle, t5.aEndAngle = this.aEndAngle, t5.aClockwise = this.aClockwise, t5.aRotation = this.aRotation, t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.aX = t5.aX, this.aY = t5.aY, this.xRadius = t5.xRadius, this.yRadius = t5.yRadius, this.aStartAngle = t5.aStartAngle, this.aEndAngle = t5.aEndAngle, this.aClockwise = t5.aClockwise, this.aRotation = t5.aRotation, this;
    }
  };
  Fs.prototype.isEllipseCurve = true;
  var Us = class extends Fs {
    constructor(t5, e8, n8, i6, r5, s6) {
      super(t5, e8, n8, n8, i6, r5, s6), this.type = "ArcCurve";
    }
  };
  function ks() {
    let t5 = 0, e8 = 0, n8 = 0, i6 = 0;
    function r5(r6, s6, a4, o7) {
      t5 = r6, e8 = a4, n8 = -3 * r6 + 3 * s6 - 2 * a4 - o7, i6 = 2 * r6 - 2 * s6 + a4 + o7;
    }
    return { initCatmullRom: function(t6, e9, n9, i7, s6) {
      r5(e9, n9, s6 * (n9 - t6), s6 * (i7 - e9));
    }, initNonuniformCatmullRom: function(t6, e9, n9, i7, s6, a4, o7) {
      let l6 = (e9 - t6) / s6 - (n9 - t6) / (s6 + a4) + (n9 - e9) / a4, h4 = (n9 - e9) / a4 - (i7 - e9) / (a4 + o7) + (i7 - n9) / o7;
      l6 *= a4, h4 *= a4, r5(e9, n9, l6, h4);
    }, calc: function(r6) {
      const s6 = r6 * r6;
      return t5 + e8 * r6 + n8 * s6 + i6 * (s6 * r6);
    } };
  }
  Us.prototype.isArcCurve = true;
  var Bs = new V2();
  var zs = new ks();
  var Hs = new ks();
  var Vs = new ks();
  var Gs = class extends Ns {
    constructor(t5 = [], e8 = false, n8 = "centripetal", i6 = 0.5) {
      super(), this.type = "CatmullRomCurve3", this.points = t5, this.closed = e8, this.curveType = n8, this.tension = i6;
    }
    getPoint(t5, e8 = new V2()) {
      const n8 = e8, i6 = this.points, r5 = i6.length, s6 = (r5 - (this.closed ? 0 : 1)) * t5;
      let a4, o7, l6 = Math.floor(s6), h4 = s6 - l6;
      this.closed ? l6 += l6 > 0 ? 0 : (Math.floor(Math.abs(l6) / r5) + 1) * r5 : h4 === 0 && l6 === r5 - 1 && (l6 = r5 - 2, h4 = 1), this.closed || l6 > 0 ? a4 = i6[(l6 - 1) % r5] : (Bs.subVectors(i6[0], i6[1]).add(i6[0]), a4 = Bs);
      const c3 = i6[l6 % r5], u3 = i6[(l6 + 1) % r5];
      if (this.closed || l6 + 2 < r5 ? o7 = i6[(l6 + 2) % r5] : (Bs.subVectors(i6[r5 - 1], i6[r5 - 2]).add(i6[r5 - 1]), o7 = Bs), this.curveType === "centripetal" || this.curveType === "chordal") {
        const t6 = this.curveType === "chordal" ? 0.5 : 0.25;
        let e9 = Math.pow(a4.distanceToSquared(c3), t6), n9 = Math.pow(c3.distanceToSquared(u3), t6), i7 = Math.pow(u3.distanceToSquared(o7), t6);
        n9 < 1e-4 && (n9 = 1), e9 < 1e-4 && (e9 = n9), i7 < 1e-4 && (i7 = n9), zs.initNonuniformCatmullRom(a4.x, c3.x, u3.x, o7.x, e9, n9, i7), Hs.initNonuniformCatmullRom(a4.y, c3.y, u3.y, o7.y, e9, n9, i7), Vs.initNonuniformCatmullRom(a4.z, c3.z, u3.z, o7.z, e9, n9, i7);
      } else
        this.curveType === "catmullrom" && (zs.initCatmullRom(a4.x, c3.x, u3.x, o7.x, this.tension), Hs.initCatmullRom(a4.y, c3.y, u3.y, o7.y, this.tension), Vs.initCatmullRom(a4.z, c3.z, u3.z, o7.z, this.tension));
      return n8.set(zs.calc(h4), Hs.calc(h4), Vs.calc(h4)), n8;
    }
    copy(t5) {
      super.copy(t5), this.points = [];
      for (let e8 = 0, n8 = t5.points.length; e8 < n8; e8++) {
        const n9 = t5.points[e8];
        this.points.push(n9.clone());
      }
      return this.closed = t5.closed, this.curveType = t5.curveType, this.tension = t5.tension, this;
    }
    toJSON() {
      const t5 = super.toJSON();
      t5.points = [];
      for (let e8 = 0, n8 = this.points.length; e8 < n8; e8++) {
        const n9 = this.points[e8];
        t5.points.push(n9.toArray());
      }
      return t5.closed = this.closed, t5.curveType = this.curveType, t5.tension = this.tension, t5;
    }
    fromJSON(t5) {
      super.fromJSON(t5), this.points = [];
      for (let e8 = 0, n8 = t5.points.length; e8 < n8; e8++) {
        const n9 = t5.points[e8];
        this.points.push(new V2().fromArray(n9));
      }
      return this.closed = t5.closed, this.curveType = t5.curveType, this.tension = t5.tension, this;
    }
  };
  function Ws(t5, e8, n8, i6, r5) {
    const s6 = 0.5 * (i6 - e8), a4 = 0.5 * (r5 - n8), o7 = t5 * t5;
    return (2 * n8 - 2 * i6 + s6 + a4) * (t5 * o7) + (-3 * n8 + 3 * i6 - 2 * s6 - a4) * o7 + s6 * t5 + n8;
  }
  function js(t5, e8, n8, i6) {
    return function(t6, e9) {
      const n9 = 1 - t6;
      return n9 * n9 * e9;
    }(t5, e8) + function(t6, e9) {
      return 2 * (1 - t6) * t6 * e9;
    }(t5, n8) + function(t6, e9) {
      return t6 * t6 * e9;
    }(t5, i6);
  }
  function qs(t5, e8, n8, i6, r5) {
    return function(t6, e9) {
      const n9 = 1 - t6;
      return n9 * n9 * n9 * e9;
    }(t5, e8) + function(t6, e9) {
      const n9 = 1 - t6;
      return 3 * n9 * n9 * t6 * e9;
    }(t5, n8) + function(t6, e9) {
      return 3 * (1 - t6) * t6 * t6 * e9;
    }(t5, i6) + function(t6, e9) {
      return t6 * t6 * t6 * e9;
    }(t5, r5);
  }
  Gs.prototype.isCatmullRomCurve3 = true;
  var Xs = class extends Ns {
    constructor(t5 = new g2(), e8 = new g2(), n8 = new g2(), i6 = new g2()) {
      super(), this.type = "CubicBezierCurve", this.v0 = t5, this.v1 = e8, this.v2 = n8, this.v3 = i6;
    }
    getPoint(t5, e8 = new g2()) {
      const n8 = e8, i6 = this.v0, r5 = this.v1, s6 = this.v2, a4 = this.v3;
      return n8.set(qs(t5, i6.x, r5.x, s6.x, a4.x), qs(t5, i6.y, r5.y, s6.y, a4.y)), n8;
    }
    copy(t5) {
      return super.copy(t5), this.v0.copy(t5.v0), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this.v3.copy(t5.v3), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v0 = this.v0.toArray(), t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5.v3 = this.v3.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v0.fromArray(t5.v0), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this.v3.fromArray(t5.v3), this;
    }
  };
  Xs.prototype.isCubicBezierCurve = true;
  var $s = class extends Ns {
    constructor(t5 = new V2(), e8 = new V2(), n8 = new V2(), i6 = new V2()) {
      super(), this.type = "CubicBezierCurve3", this.v0 = t5, this.v1 = e8, this.v2 = n8, this.v3 = i6;
    }
    getPoint(t5, e8 = new V2()) {
      const n8 = e8, i6 = this.v0, r5 = this.v1, s6 = this.v2, a4 = this.v3;
      return n8.set(qs(t5, i6.x, r5.x, s6.x, a4.x), qs(t5, i6.y, r5.y, s6.y, a4.y), qs(t5, i6.z, r5.z, s6.z, a4.z)), n8;
    }
    copy(t5) {
      return super.copy(t5), this.v0.copy(t5.v0), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this.v3.copy(t5.v3), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v0 = this.v0.toArray(), t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5.v3 = this.v3.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v0.fromArray(t5.v0), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this.v3.fromArray(t5.v3), this;
    }
  };
  $s.prototype.isCubicBezierCurve3 = true;
  var Ys = class extends Ns {
    constructor(t5 = new g2(), e8 = new g2()) {
      super(), this.type = "LineCurve", this.v1 = t5, this.v2 = e8;
    }
    getPoint(t5, e8 = new g2()) {
      const n8 = e8;
      return t5 === 1 ? n8.copy(this.v2) : (n8.copy(this.v2).sub(this.v1), n8.multiplyScalar(t5).add(this.v1)), n8;
    }
    getPointAt(t5, e8) {
      return this.getPoint(t5, e8);
    }
    getTangent(t5, e8) {
      const n8 = e8 || new g2();
      return n8.copy(this.v2).sub(this.v1).normalize(), n8;
    }
    copy(t5) {
      return super.copy(t5), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this;
    }
  };
  Ys.prototype.isLineCurve = true;
  var Js = class extends Ns {
    constructor(t5 = new g2(), e8 = new g2(), n8 = new g2()) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = t5, this.v1 = e8, this.v2 = n8;
    }
    getPoint(t5, e8 = new g2()) {
      const n8 = e8, i6 = this.v0, r5 = this.v1, s6 = this.v2;
      return n8.set(js(t5, i6.x, r5.x, s6.x), js(t5, i6.y, r5.y, s6.y)), n8;
    }
    copy(t5) {
      return super.copy(t5), this.v0.copy(t5.v0), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v0 = this.v0.toArray(), t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v0.fromArray(t5.v0), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this;
    }
  };
  Js.prototype.isQuadraticBezierCurve = true;
  var Ks = class extends Ns {
    constructor(t5 = new V2(), e8 = new V2(), n8 = new V2()) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = t5, this.v1 = e8, this.v2 = n8;
    }
    getPoint(t5, e8 = new V2()) {
      const n8 = e8, i6 = this.v0, r5 = this.v1, s6 = this.v2;
      return n8.set(js(t5, i6.x, r5.x, s6.x), js(t5, i6.y, r5.y, s6.y), js(t5, i6.z, r5.z, s6.z)), n8;
    }
    copy(t5) {
      return super.copy(t5), this.v0.copy(t5.v0), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v0 = this.v0.toArray(), t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v0.fromArray(t5.v0), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this;
    }
  };
  Ks.prototype.isQuadraticBezierCurve3 = true;
  var Zs = class extends Ns {
    constructor(t5 = []) {
      super(), this.type = "SplineCurve", this.points = t5;
    }
    getPoint(t5, e8 = new g2()) {
      const n8 = e8, i6 = this.points, r5 = (i6.length - 1) * t5, s6 = Math.floor(r5), a4 = r5 - s6, o7 = i6[s6 === 0 ? s6 : s6 - 1], l6 = i6[s6], h4 = i6[s6 > i6.length - 2 ? i6.length - 1 : s6 + 1], c3 = i6[s6 > i6.length - 3 ? i6.length - 1 : s6 + 2];
      return n8.set(Ws(a4, o7.x, l6.x, h4.x, c3.x), Ws(a4, o7.y, l6.y, h4.y, c3.y)), n8;
    }
    copy(t5) {
      super.copy(t5), this.points = [];
      for (let e8 = 0, n8 = t5.points.length; e8 < n8; e8++) {
        const n9 = t5.points[e8];
        this.points.push(n9.clone());
      }
      return this;
    }
    toJSON() {
      const t5 = super.toJSON();
      t5.points = [];
      for (let e8 = 0, n8 = this.points.length; e8 < n8; e8++) {
        const n9 = this.points[e8];
        t5.points.push(n9.toArray());
      }
      return t5;
    }
    fromJSON(t5) {
      super.fromJSON(t5), this.points = [];
      for (let e8 = 0, n8 = t5.points.length; e8 < n8; e8++) {
        const n9 = t5.points[e8];
        this.points.push(new g2().fromArray(n9));
      }
      return this;
    }
  };
  Zs.prototype.isSplineCurve = true;
  var Qs = Object.freeze({ __proto__: null, ArcCurve: Us, CatmullRomCurve3: Gs, CubicBezierCurve: Xs, CubicBezierCurve3: $s, EllipseCurve: Fs, LineCurve: Ys, LineCurve3: class extends Ns {
    constructor(t5 = new V2(), e8 = new V2()) {
      super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t5, this.v2 = e8;
    }
    getPoint(t5, e8 = new V2()) {
      const n8 = e8;
      return t5 === 1 ? n8.copy(this.v2) : (n8.copy(this.v2).sub(this.v1), n8.multiplyScalar(t5).add(this.v1)), n8;
    }
    getPointAt(t5, e8) {
      return this.getPoint(t5, e8);
    }
    copy(t5) {
      return super.copy(t5), this.v1.copy(t5.v1), this.v2.copy(t5.v2), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.v1 = this.v1.toArray(), t5.v2 = this.v2.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.v1.fromArray(t5.v1), this.v2.fromArray(t5.v2), this;
    }
  }, QuadraticBezierCurve: Js, QuadraticBezierCurve3: Ks, SplineCurve: Zs });
  var ta = class extends Ns {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(t5) {
      this.curves.push(t5);
    }
    closePath() {
      const t5 = this.curves[0].getPoint(0), e8 = this.curves[this.curves.length - 1].getPoint(1);
      t5.equals(e8) || this.curves.push(new Ys(e8, t5));
    }
    getPoint(t5, e8) {
      const n8 = t5 * this.getLength(), i6 = this.getCurveLengths();
      let r5 = 0;
      for (; r5 < i6.length; ) {
        if (i6[r5] >= n8) {
          const t6 = i6[r5] - n8, s6 = this.curves[r5], a4 = s6.getLength(), o7 = a4 === 0 ? 0 : 1 - t6 / a4;
          return s6.getPointAt(o7, e8);
        }
        r5++;
      }
      return null;
    }
    getLength() {
      const t5 = this.getCurveLengths();
      return t5[t5.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const t5 = [];
      let e8 = 0;
      for (let n8 = 0, i6 = this.curves.length; n8 < i6; n8++)
        e8 += this.curves[n8].getLength(), t5.push(e8);
      return this.cacheLengths = t5, t5;
    }
    getSpacedPoints(t5 = 40) {
      const e8 = [];
      for (let n8 = 0; n8 <= t5; n8++)
        e8.push(this.getPoint(n8 / t5));
      return this.autoClose && e8.push(e8[0]), e8;
    }
    getPoints(t5 = 12) {
      const e8 = [];
      let n8;
      for (let i6 = 0, r5 = this.curves; i6 < r5.length; i6++) {
        const s6 = r5[i6], a4 = s6.isEllipseCurve ? 2 * t5 : s6.isLineCurve || s6.isLineCurve3 ? 1 : s6.isSplineCurve ? t5 * s6.points.length : t5, o7 = s6.getPoints(a4);
        for (let t6 = 0; t6 < o7.length; t6++) {
          const i7 = o7[t6];
          n8 && n8.equals(i7) || (e8.push(i7), n8 = i7);
        }
      }
      return this.autoClose && e8.length > 1 && !e8[e8.length - 1].equals(e8[0]) && e8.push(e8[0]), e8;
    }
    copy(t5) {
      super.copy(t5), this.curves = [];
      for (let e8 = 0, n8 = t5.curves.length; e8 < n8; e8++) {
        const n9 = t5.curves[e8];
        this.curves.push(n9.clone());
      }
      return this.autoClose = t5.autoClose, this;
    }
    toJSON() {
      const t5 = super.toJSON();
      t5.autoClose = this.autoClose, t5.curves = [];
      for (let e8 = 0, n8 = this.curves.length; e8 < n8; e8++) {
        const n9 = this.curves[e8];
        t5.curves.push(n9.toJSON());
      }
      return t5;
    }
    fromJSON(t5) {
      super.fromJSON(t5), this.autoClose = t5.autoClose, this.curves = [];
      for (let e8 = 0, n8 = t5.curves.length; e8 < n8; e8++) {
        const n9 = t5.curves[e8];
        this.curves.push(new Qs[n9.type]().fromJSON(n9));
      }
      return this;
    }
  };
  var ea = class extends ta {
    constructor(t5) {
      super(), this.type = "Path", this.currentPoint = new g2(), t5 && this.setFromPoints(t5);
    }
    setFromPoints(t5) {
      this.moveTo(t5[0].x, t5[0].y);
      for (let e8 = 1, n8 = t5.length; e8 < n8; e8++)
        this.lineTo(t5[e8].x, t5[e8].y);
      return this;
    }
    moveTo(t5, e8) {
      return this.currentPoint.set(t5, e8), this;
    }
    lineTo(t5, e8) {
      const n8 = new Ys(this.currentPoint.clone(), new g2(t5, e8));
      return this.curves.push(n8), this.currentPoint.set(t5, e8), this;
    }
    quadraticCurveTo(t5, e8, n8, i6) {
      const r5 = new Js(this.currentPoint.clone(), new g2(t5, e8), new g2(n8, i6));
      return this.curves.push(r5), this.currentPoint.set(n8, i6), this;
    }
    bezierCurveTo(t5, e8, n8, i6, r5, s6) {
      const a4 = new Xs(this.currentPoint.clone(), new g2(t5, e8), new g2(n8, i6), new g2(r5, s6));
      return this.curves.push(a4), this.currentPoint.set(r5, s6), this;
    }
    splineThru(t5) {
      const e8 = [this.currentPoint.clone()].concat(t5), n8 = new Zs(e8);
      return this.curves.push(n8), this.currentPoint.copy(t5[t5.length - 1]), this;
    }
    arc(t5, e8, n8, i6, r5, s6) {
      const a4 = this.currentPoint.x, o7 = this.currentPoint.y;
      return this.absarc(t5 + a4, e8 + o7, n8, i6, r5, s6), this;
    }
    absarc(t5, e8, n8, i6, r5, s6) {
      return this.absellipse(t5, e8, n8, n8, i6, r5, s6), this;
    }
    ellipse(t5, e8, n8, i6, r5, s6, a4, o7) {
      const l6 = this.currentPoint.x, h4 = this.currentPoint.y;
      return this.absellipse(t5 + l6, e8 + h4, n8, i6, r5, s6, a4, o7), this;
    }
    absellipse(t5, e8, n8, i6, r5, s6, a4, o7) {
      const l6 = new Fs(t5, e8, n8, i6, r5, s6, a4, o7);
      if (this.curves.length > 0) {
        const t6 = l6.getPoint(0);
        t6.equals(this.currentPoint) || this.lineTo(t6.x, t6.y);
      }
      this.curves.push(l6);
      const h4 = l6.getPoint(1);
      return this.currentPoint.copy(h4), this;
    }
    copy(t5) {
      return super.copy(t5), this.currentPoint.copy(t5.currentPoint), this;
    }
    toJSON() {
      const t5 = super.toJSON();
      return t5.currentPoint = this.currentPoint.toArray(), t5;
    }
    fromJSON(t5) {
      return super.fromJSON(t5), this.currentPoint.fromArray(t5.currentPoint), this;
    }
  };
  new V2(), new V2(), new V2(), new ee();
  var na = class extends ea {
    constructor(t5) {
      super(t5), this.uuid = l5(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(t5) {
      const e8 = [];
      for (let n8 = 0, i6 = this.holes.length; n8 < i6; n8++)
        e8[n8] = this.holes[n8].getPoints(t5);
      return e8;
    }
    extractPoints(t5) {
      return { shape: this.getPoints(t5), holes: this.getPointsHoles(t5) };
    }
    copy(t5) {
      super.copy(t5), this.holes = [];
      for (let e8 = 0, n8 = t5.holes.length; e8 < n8; e8++) {
        const n9 = t5.holes[e8];
        this.holes.push(n9.clone());
      }
      return this;
    }
    toJSON() {
      const t5 = super.toJSON();
      t5.uuid = this.uuid, t5.holes = [];
      for (let e8 = 0, n8 = this.holes.length; e8 < n8; e8++) {
        const n9 = this.holes[e8];
        t5.holes.push(n9.toJSON());
      }
      return t5;
    }
    fromJSON(t5) {
      super.fromJSON(t5), this.uuid = t5.uuid, this.holes = [];
      for (let e8 = 0, n8 = t5.holes.length; e8 < n8; e8++) {
        const n9 = t5.holes[e8];
        this.holes.push(new ea().fromJSON(n9));
      }
      return this;
    }
  };
  var ia = function(t5, e8, n8 = 2) {
    const i6 = e8 && e8.length, r5 = i6 ? e8[0] * n8 : t5.length;
    let s6 = ra(t5, 0, r5, n8, true);
    const a4 = [];
    if (!s6 || s6.next === s6.prev)
      return a4;
    let o7, l6, h4, c3, u3, d3, p3;
    if (i6 && (s6 = function(t6, e9, n9, i7) {
      const r6 = [];
      let s7, a5, o8, l7, h5;
      for (s7 = 0, a5 = e9.length; s7 < a5; s7++)
        o8 = e9[s7] * i7, l7 = s7 < a5 - 1 ? e9[s7 + 1] * i7 : t6.length, h5 = ra(t6, o8, l7, i7, false), h5 === h5.next && (h5.steiner = true), r6.push(fa(h5));
      for (r6.sort(ua), s7 = 0; s7 < r6.length; s7++)
        da(r6[s7], n9), n9 = sa(n9, n9.next);
      return n9;
    }(t5, e8, s6, n8)), t5.length > 80 * n8) {
      o7 = h4 = t5[0], l6 = c3 = t5[1];
      for (let e9 = n8; e9 < r5; e9 += n8)
        u3 = t5[e9], d3 = t5[e9 + 1], u3 < o7 && (o7 = u3), d3 < l6 && (l6 = d3), u3 > h4 && (h4 = u3), d3 > c3 && (c3 = d3);
      p3 = Math.max(h4 - o7, c3 - l6), p3 = p3 !== 0 ? 1 / p3 : 0;
    }
    return aa(s6, a4, n8, o7, l6, p3), a4;
  };
  function ra(t5, e8, n8, i6, r5) {
    let s6, a4;
    if (r5 === function(t6, e9, n9, i7) {
      let r6 = 0;
      for (let s7 = e9, a5 = n9 - i7; s7 < n9; s7 += i7)
        r6 += (t6[a5] - t6[s7]) * (t6[s7 + 1] + t6[a5 + 1]), a5 = s7;
      return r6;
    }(t5, e8, n8, i6) > 0)
      for (s6 = e8; s6 < n8; s6 += i6)
        a4 = Ta(s6, t5[s6], t5[s6 + 1], a4);
    else
      for (s6 = n8 - i6; s6 >= e8; s6 -= i6)
        a4 = Ta(s6, t5[s6], t5[s6 + 1], a4);
    return a4 && xa(a4, a4.next) && (Ea(a4), a4 = a4.next), a4;
  }
  function sa(t5, e8) {
    if (!t5)
      return t5;
    e8 || (e8 = t5);
    let n8, i6 = t5;
    do {
      if (n8 = false, i6.steiner || !xa(i6, i6.next) && ya(i6.prev, i6, i6.next) !== 0)
        i6 = i6.next;
      else {
        if (Ea(i6), i6 = e8 = i6.prev, i6 === i6.next)
          break;
        n8 = true;
      }
    } while (n8 || i6 !== e8);
    return e8;
  }
  function aa(t5, e8, n8, i6, r5, s6, a4) {
    if (!t5)
      return;
    !a4 && s6 && function(t6, e9, n9, i7) {
      let r6 = t6;
      do {
        r6.z === null && (r6.z = ma(r6.x, r6.y, e9, n9, i7)), r6.prevZ = r6.prev, r6.nextZ = r6.next, r6 = r6.next;
      } while (r6 !== t6);
      r6.prevZ.nextZ = null, r6.prevZ = null, function(t7) {
        let e10, n10, i8, r7, s7, a5, o8, l7, h5 = 1;
        do {
          for (n10 = t7, t7 = null, s7 = null, a5 = 0; n10; ) {
            for (a5++, i8 = n10, o8 = 0, e10 = 0; e10 < h5 && (o8++, i8 = i8.nextZ, i8); e10++)
              ;
            for (l7 = h5; o8 > 0 || l7 > 0 && i8; )
              o8 !== 0 && (l7 === 0 || !i8 || n10.z <= i8.z) ? (r7 = n10, n10 = n10.nextZ, o8--) : (r7 = i8, i8 = i8.nextZ, l7--), s7 ? s7.nextZ = r7 : t7 = r7, r7.prevZ = s7, s7 = r7;
            n10 = i8;
          }
          s7.nextZ = null, h5 *= 2;
        } while (a5 > 1);
      }(r6);
    }(t5, i6, r5, s6);
    let o7, l6, h4 = t5;
    for (; t5.prev !== t5.next; )
      if (o7 = t5.prev, l6 = t5.next, s6 ? la(t5, i6, r5, s6) : oa(t5))
        e8.push(o7.i / n8), e8.push(t5.i / n8), e8.push(l6.i / n8), Ea(t5), t5 = l6.next, h4 = l6.next;
      else if ((t5 = l6) === h4) {
        a4 ? a4 === 1 ? aa(t5 = ha(sa(t5), e8, n8), e8, n8, i6, r5, s6, 2) : a4 === 2 && ca(t5, e8, n8, i6, r5, s6) : aa(sa(t5), e8, n8, i6, r5, s6, 1);
        break;
      }
  }
  function oa(t5) {
    const e8 = t5.prev, n8 = t5, i6 = t5.next;
    if (ya(e8, n8, i6) >= 0)
      return false;
    let r5 = t5.next.next;
    for (; r5 !== t5.prev; ) {
      if (ga(e8.x, e8.y, n8.x, n8.y, i6.x, i6.y, r5.x, r5.y) && ya(r5.prev, r5, r5.next) >= 0)
        return false;
      r5 = r5.next;
    }
    return true;
  }
  function la(t5, e8, n8, i6) {
    const r5 = t5.prev, s6 = t5, a4 = t5.next;
    if (ya(r5, s6, a4) >= 0)
      return false;
    const o7 = r5.x < s6.x ? r5.x < a4.x ? r5.x : a4.x : s6.x < a4.x ? s6.x : a4.x, l6 = r5.y < s6.y ? r5.y < a4.y ? r5.y : a4.y : s6.y < a4.y ? s6.y : a4.y, h4 = r5.x > s6.x ? r5.x > a4.x ? r5.x : a4.x : s6.x > a4.x ? s6.x : a4.x, c3 = r5.y > s6.y ? r5.y > a4.y ? r5.y : a4.y : s6.y > a4.y ? s6.y : a4.y, u3 = ma(o7, l6, e8, n8, i6), d3 = ma(h4, c3, e8, n8, i6);
    let p3 = t5.prevZ, m3 = t5.nextZ;
    for (; p3 && p3.z >= u3 && m3 && m3.z <= d3; ) {
      if (p3 !== t5.prev && p3 !== t5.next && ga(r5.x, r5.y, s6.x, s6.y, a4.x, a4.y, p3.x, p3.y) && ya(p3.prev, p3, p3.next) >= 0)
        return false;
      if (p3 = p3.prevZ, m3 !== t5.prev && m3 !== t5.next && ga(r5.x, r5.y, s6.x, s6.y, a4.x, a4.y, m3.x, m3.y) && ya(m3.prev, m3, m3.next) >= 0)
        return false;
      m3 = m3.nextZ;
    }
    for (; p3 && p3.z >= u3; ) {
      if (p3 !== t5.prev && p3 !== t5.next && ga(r5.x, r5.y, s6.x, s6.y, a4.x, a4.y, p3.x, p3.y) && ya(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.prevZ;
    }
    for (; m3 && m3.z <= d3; ) {
      if (m3 !== t5.prev && m3 !== t5.next && ga(r5.x, r5.y, s6.x, s6.y, a4.x, a4.y, m3.x, m3.y) && ya(m3.prev, m3, m3.next) >= 0)
        return false;
      m3 = m3.nextZ;
    }
    return true;
  }
  function ha(t5, e8, n8) {
    let i6 = t5;
    do {
      const r5 = i6.prev, s6 = i6.next.next;
      !xa(r5, s6) && ba(r5, i6, i6.next, s6) && Ma(r5, s6) && Ma(s6, r5) && (e8.push(r5.i / n8), e8.push(i6.i / n8), e8.push(s6.i / n8), Ea(i6), Ea(i6.next), i6 = t5 = s6), i6 = i6.next;
    } while (i6 !== t5);
    return sa(i6);
  }
  function ca(t5, e8, n8, i6, r5, s6) {
    let a4 = t5;
    do {
      let t6 = a4.next.next;
      for (; t6 !== a4.prev; ) {
        if (a4.i !== t6.i && va(a4, t6)) {
          let o7 = Sa(a4, t6);
          return a4 = sa(a4, a4.next), o7 = sa(o7, o7.next), aa(a4, e8, n8, i6, r5, s6), void aa(o7, e8, n8, i6, r5, s6);
        }
        t6 = t6.next;
      }
      a4 = a4.next;
    } while (a4 !== t5);
  }
  function ua(t5, e8) {
    return t5.x - e8.x;
  }
  function da(t5, e8) {
    if (e8 = function(t6, e9) {
      let n8 = e9;
      const i6 = t6.x, r5 = t6.y;
      let s6, a4 = -1 / 0;
      do {
        if (r5 <= n8.y && r5 >= n8.next.y && n8.next.y !== n8.y) {
          const t7 = n8.x + (r5 - n8.y) * (n8.next.x - n8.x) / (n8.next.y - n8.y);
          if (t7 <= i6 && t7 > a4) {
            if (a4 = t7, t7 === i6) {
              if (r5 === n8.y)
                return n8;
              if (r5 === n8.next.y)
                return n8.next;
            }
            s6 = n8.x < n8.next.x ? n8 : n8.next;
          }
        }
        n8 = n8.next;
      } while (n8 !== e9);
      if (!s6)
        return null;
      if (i6 === a4)
        return s6;
      const o7 = s6, l6 = s6.x, h4 = s6.y;
      let c3, u3 = 1 / 0;
      n8 = s6;
      do {
        i6 >= n8.x && n8.x >= l6 && i6 !== n8.x && ga(r5 < h4 ? i6 : a4, r5, l6, h4, r5 < h4 ? a4 : i6, r5, n8.x, n8.y) && (c3 = Math.abs(r5 - n8.y) / (i6 - n8.x), Ma(n8, t6) && (c3 < u3 || c3 === u3 && (n8.x > s6.x || n8.x === s6.x && pa(s6, n8))) && (s6 = n8, u3 = c3)), n8 = n8.next;
      } while (n8 !== o7);
      return s6;
    }(t5, e8), e8) {
      const n8 = Sa(e8, t5);
      sa(e8, e8.next), sa(n8, n8.next);
    }
  }
  function pa(t5, e8) {
    return ya(t5.prev, t5, e8.prev) < 0 && ya(e8.next, t5, t5.next) < 0;
  }
  function ma(t5, e8, n8, i6, r5) {
    return (t5 = 1431655765 & ((t5 = 858993459 & ((t5 = 252645135 & ((t5 = 16711935 & ((t5 = 32767 * (t5 - n8) * r5) | t5 << 8)) | t5 << 4)) | t5 << 2)) | t5 << 1)) | (e8 = 1431655765 & ((e8 = 858993459 & ((e8 = 252645135 & ((e8 = 16711935 & ((e8 = 32767 * (e8 - i6) * r5) | e8 << 8)) | e8 << 4)) | e8 << 2)) | e8 << 1)) << 1;
  }
  function fa(t5) {
    let e8 = t5, n8 = t5;
    do {
      (e8.x < n8.x || e8.x === n8.x && e8.y < n8.y) && (n8 = e8), e8 = e8.next;
    } while (e8 !== t5);
    return n8;
  }
  function ga(t5, e8, n8, i6, r5, s6, a4, o7) {
    return (r5 - a4) * (e8 - o7) - (t5 - a4) * (s6 - o7) >= 0 && (t5 - a4) * (i6 - o7) - (n8 - a4) * (e8 - o7) >= 0 && (n8 - a4) * (s6 - o7) - (r5 - a4) * (i6 - o7) >= 0;
  }
  function va(t5, e8) {
    return t5.next.i !== e8.i && t5.prev.i !== e8.i && !function(t6, e9) {
      let n8 = t6;
      do {
        if (n8.i !== t6.i && n8.next.i !== t6.i && n8.i !== e9.i && n8.next.i !== e9.i && ba(n8, n8.next, t6, e9))
          return true;
        n8 = n8.next;
      } while (n8 !== t6);
      return false;
    }(t5, e8) && (Ma(t5, e8) && Ma(e8, t5) && function(t6, e9) {
      let n8 = t6, i6 = false;
      const r5 = (t6.x + e9.x) / 2, s6 = (t6.y + e9.y) / 2;
      do {
        n8.y > s6 != n8.next.y > s6 && n8.next.y !== n8.y && r5 < (n8.next.x - n8.x) * (s6 - n8.y) / (n8.next.y - n8.y) + n8.x && (i6 = !i6), n8 = n8.next;
      } while (n8 !== t6);
      return i6;
    }(t5, e8) && (ya(t5.prev, t5, e8.prev) || ya(t5, e8.prev, e8)) || xa(t5, e8) && ya(t5.prev, t5, t5.next) > 0 && ya(e8.prev, e8, e8.next) > 0);
  }
  function ya(t5, e8, n8) {
    return (e8.y - t5.y) * (n8.x - e8.x) - (e8.x - t5.x) * (n8.y - e8.y);
  }
  function xa(t5, e8) {
    return t5.x === e8.x && t5.y === e8.y;
  }
  function ba(t5, e8, n8, i6) {
    const r5 = wa(ya(t5, e8, n8)), s6 = wa(ya(t5, e8, i6)), a4 = wa(ya(n8, i6, t5)), o7 = wa(ya(n8, i6, e8));
    return r5 !== s6 && a4 !== o7 || (!(r5 !== 0 || !_a(t5, n8, e8)) || (!(s6 !== 0 || !_a(t5, i6, e8)) || (!(a4 !== 0 || !_a(n8, t5, i6)) || !(o7 !== 0 || !_a(n8, e8, i6)))));
  }
  function _a(t5, e8, n8) {
    return e8.x <= Math.max(t5.x, n8.x) && e8.x >= Math.min(t5.x, n8.x) && e8.y <= Math.max(t5.y, n8.y) && e8.y >= Math.min(t5.y, n8.y);
  }
  function wa(t5) {
    return t5 > 0 ? 1 : t5 < 0 ? -1 : 0;
  }
  function Ma(t5, e8) {
    return ya(t5.prev, t5, t5.next) < 0 ? ya(t5, e8, t5.next) >= 0 && ya(t5, t5.prev, e8) >= 0 : ya(t5, e8, t5.prev) < 0 || ya(t5, t5.next, e8) < 0;
  }
  function Sa(t5, e8) {
    const n8 = new Aa(t5.i, t5.x, t5.y), i6 = new Aa(e8.i, e8.x, e8.y), r5 = t5.next, s6 = e8.prev;
    return t5.next = e8, e8.prev = t5, n8.next = r5, r5.prev = n8, i6.next = n8, n8.prev = i6, s6.next = i6, i6.prev = s6, i6;
  }
  function Ta(t5, e8, n8, i6) {
    const r5 = new Aa(t5, e8, n8);
    return i6 ? (r5.next = i6.next, r5.prev = i6, i6.next.prev = r5, i6.next = r5) : (r5.prev = r5, r5.next = r5), r5;
  }
  function Ea(t5) {
    t5.next.prev = t5.prev, t5.prev.next = t5.next, t5.prevZ && (t5.prevZ.nextZ = t5.nextZ), t5.nextZ && (t5.nextZ.prevZ = t5.prevZ);
  }
  function Aa(t5, e8, n8) {
    this.i = t5, this.x = e8, this.y = n8, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  var Ra = class {
    static area(t5) {
      const e8 = t5.length;
      let n8 = 0;
      for (let i6 = e8 - 1, r5 = 0; r5 < e8; i6 = r5++)
        n8 += t5[i6].x * t5[r5].y - t5[r5].x * t5[i6].y;
      return 0.5 * n8;
    }
    static isClockWise(t5) {
      return Ra.area(t5) < 0;
    }
    static triangulateShape(t5, e8) {
      const n8 = [], i6 = [], r5 = [];
      Ca(t5), La(n8, t5);
      let s6 = t5.length;
      e8.forEach(Ca);
      for (let t6 = 0; t6 < e8.length; t6++)
        i6.push(s6), s6 += e8[t6].length, La(n8, e8[t6]);
      const a4 = ia(n8, i6);
      for (let t6 = 0; t6 < a4.length; t6 += 3)
        r5.push(a4.slice(t6, t6 + 3));
      return r5;
    }
  };
  function Ca(t5) {
    const e8 = t5.length;
    e8 > 2 && t5[e8 - 1].equals(t5[0]) && t5.pop();
  }
  function La(t5, e8) {
    for (let n8 = 0; n8 < e8.length; n8++)
      t5.push(e8[n8].x), t5.push(e8[n8].y);
  }
  var Pa = class extends ye {
    constructor(t5 = new na([new g2(0.5, 0.5), new g2(-0.5, 0.5), new g2(-0.5, -0.5), new g2(0.5, -0.5)]), e8 = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t5, options: e8 }, t5 = Array.isArray(t5) ? t5 : [t5];
      const n8 = this, i6 = [], r5 = [];
      for (let e9 = 0, n9 = t5.length; e9 < n9; e9++) {
        s6(t5[e9]);
      }
      function s6(t6) {
        const s7 = [], a4 = e8.curveSegments !== void 0 ? e8.curveSegments : 12, o7 = e8.steps !== void 0 ? e8.steps : 1;
        let l6 = e8.depth !== void 0 ? e8.depth : 1, h4 = e8.bevelEnabled === void 0 || e8.bevelEnabled, c3 = e8.bevelThickness !== void 0 ? e8.bevelThickness : 0.2, u3 = e8.bevelSize !== void 0 ? e8.bevelSize : c3 - 0.1, d3 = e8.bevelOffset !== void 0 ? e8.bevelOffset : 0, p3 = e8.bevelSegments !== void 0 ? e8.bevelSegments : 3;
        const m3 = e8.extrudePath, f3 = e8.UVGenerator !== void 0 ? e8.UVGenerator : Da;
        e8.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l6 = e8.amount);
        let v3, y3, x3, b3, _3, w3 = false;
        m3 && (v3 = m3.getSpacedPoints(o7), w3 = true, h4 = false, y3 = m3.computeFrenetFrames(o7, false), x3 = new V2(), b3 = new V2(), _3 = new V2()), h4 || (p3 = 0, c3 = 0, u3 = 0, d3 = 0);
        const M3 = t6.extractPoints(a4);
        let S4 = M3.shape;
        const T3 = M3.holes;
        if (!Ra.isClockWise(S4)) {
          S4 = S4.reverse();
          for (let t7 = 0, e9 = T3.length; t7 < e9; t7++) {
            const e10 = T3[t7];
            Ra.isClockWise(e10) && (T3[t7] = e10.reverse());
          }
        }
        const E3 = Ra.triangulateShape(S4, T3), A3 = S4;
        for (let t7 = 0, e9 = T3.length; t7 < e9; t7++) {
          const e10 = T3[t7];
          S4 = S4.concat(e10);
        }
        function R2(t7, e9, n9) {
          return e9 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e9.clone().multiplyScalar(n9).add(t7);
        }
        const C3 = S4.length, L3 = E3.length;
        function P3(t7, e9, n9) {
          let i7, r6, s8;
          const a5 = t7.x - e9.x, o8 = t7.y - e9.y, l7 = n9.x - t7.x, h5 = n9.y - t7.y, c4 = a5 * a5 + o8 * o8, u4 = a5 * h5 - o8 * l7;
          if (Math.abs(u4) > Number.EPSILON) {
            const u5 = Math.sqrt(c4), d4 = Math.sqrt(l7 * l7 + h5 * h5), p4 = e9.x - o8 / u5, m4 = e9.y + a5 / u5, f4 = ((n9.x - h5 / d4 - p4) * h5 - (n9.y + l7 / d4 - m4) * l7) / (a5 * h5 - o8 * l7);
            i7 = p4 + a5 * f4 - t7.x, r6 = m4 + o8 * f4 - t7.y;
            const v4 = i7 * i7 + r6 * r6;
            if (v4 <= 2)
              return new g2(i7, r6);
            s8 = Math.sqrt(v4 / 2);
          } else {
            let t8 = false;
            a5 > Number.EPSILON ? l7 > Number.EPSILON && (t8 = true) : a5 < -Number.EPSILON ? l7 < -Number.EPSILON && (t8 = true) : Math.sign(o8) === Math.sign(h5) && (t8 = true), t8 ? (i7 = -o8, r6 = a5, s8 = Math.sqrt(c4)) : (i7 = a5, r6 = o8, s8 = Math.sqrt(c4 / 2));
          }
          return new g2(i7 / s8, r6 / s8);
        }
        const D2 = [];
        for (let t7 = 0, e9 = A3.length, n9 = e9 - 1, i7 = t7 + 1; t7 < e9; t7++, n9++, i7++)
          n9 === e9 && (n9 = 0), i7 === e9 && (i7 = 0), D2[t7] = P3(A3[t7], A3[n9], A3[i7]);
        const I3 = [];
        let O2, N3 = D2.concat();
        for (let t7 = 0, e9 = T3.length; t7 < e9; t7++) {
          const e10 = T3[t7];
          O2 = [];
          for (let t8 = 0, n9 = e10.length, i7 = n9 - 1, r6 = t8 + 1; t8 < n9; t8++, i7++, r6++)
            i7 === n9 && (i7 = 0), r6 === n9 && (r6 = 0), O2[t8] = P3(e10[t8], e10[i7], e10[r6]);
          I3.push(O2), N3 = N3.concat(O2);
        }
        for (let t7 = 0; t7 < p3; t7++) {
          const e9 = t7 / p3, n9 = c3 * Math.cos(e9 * Math.PI / 2), i7 = u3 * Math.sin(e9 * Math.PI / 2) + d3;
          for (let t8 = 0, e10 = A3.length; t8 < e10; t8++) {
            const e11 = R2(A3[t8], D2[t8], i7);
            k3(e11.x, e11.y, -n9);
          }
          for (let t8 = 0, e10 = T3.length; t8 < e10; t8++) {
            const e11 = T3[t8];
            O2 = I3[t8];
            for (let t9 = 0, r6 = e11.length; t9 < r6; t9++) {
              const r7 = R2(e11[t9], O2[t9], i7);
              k3(r7.x, r7.y, -n9);
            }
          }
        }
        const F2 = u3 + d3;
        for (let t7 = 0; t7 < C3; t7++) {
          const e9 = h4 ? R2(S4[t7], N3[t7], F2) : S4[t7];
          w3 ? (b3.copy(y3.normals[0]).multiplyScalar(e9.x), x3.copy(y3.binormals[0]).multiplyScalar(e9.y), _3.copy(v3[0]).add(b3).add(x3), k3(_3.x, _3.y, _3.z)) : k3(e9.x, e9.y, 0);
        }
        for (let t7 = 1; t7 <= o7; t7++)
          for (let e9 = 0; e9 < C3; e9++) {
            const n9 = h4 ? R2(S4[e9], N3[e9], F2) : S4[e9];
            w3 ? (b3.copy(y3.normals[t7]).multiplyScalar(n9.x), x3.copy(y3.binormals[t7]).multiplyScalar(n9.y), _3.copy(v3[t7]).add(b3).add(x3), k3(_3.x, _3.y, _3.z)) : k3(n9.x, n9.y, l6 / o7 * t7);
          }
        for (let t7 = p3 - 1; t7 >= 0; t7--) {
          const e9 = t7 / p3, n9 = c3 * Math.cos(e9 * Math.PI / 2), i7 = u3 * Math.sin(e9 * Math.PI / 2) + d3;
          for (let t8 = 0, e10 = A3.length; t8 < e10; t8++) {
            const e11 = R2(A3[t8], D2[t8], i7);
            k3(e11.x, e11.y, l6 + n9);
          }
          for (let t8 = 0, e10 = T3.length; t8 < e10; t8++) {
            const e11 = T3[t8];
            O2 = I3[t8];
            for (let t9 = 0, r6 = e11.length; t9 < r6; t9++) {
              const r7 = R2(e11[t9], O2[t9], i7);
              w3 ? k3(r7.x, r7.y + v3[o7 - 1].y, v3[o7 - 1].x + n9) : k3(r7.x, r7.y, l6 + n9);
            }
          }
        }
        function U2(t7, e9) {
          let n9 = t7.length;
          for (; --n9 >= 0; ) {
            const i7 = n9;
            let r6 = n9 - 1;
            r6 < 0 && (r6 = t7.length - 1);
            for (let t8 = 0, n10 = o7 + 2 * p3; t8 < n10; t8++) {
              const n11 = C3 * t8, s8 = C3 * (t8 + 1);
              z3(e9 + i7 + n11, e9 + r6 + n11, e9 + r6 + s8, e9 + i7 + s8);
            }
          }
        }
        function k3(t7, e9, n9) {
          s7.push(t7), s7.push(e9), s7.push(n9);
        }
        function B2(t7, e9, r6) {
          H3(t7), H3(e9), H3(r6);
          const s8 = i6.length / 3, a5 = f3.generateTopUV(n8, i6, s8 - 3, s8 - 2, s8 - 1);
          G2(a5[0]), G2(a5[1]), G2(a5[2]);
        }
        function z3(t7, e9, r6, s8) {
          H3(t7), H3(e9), H3(s8), H3(e9), H3(r6), H3(s8);
          const a5 = i6.length / 3, o8 = f3.generateSideWallUV(n8, i6, a5 - 6, a5 - 3, a5 - 2, a5 - 1);
          G2(o8[0]), G2(o8[1]), G2(o8[3]), G2(o8[1]), G2(o8[2]), G2(o8[3]);
        }
        function H3(t7) {
          i6.push(s7[3 * t7 + 0]), i6.push(s7[3 * t7 + 1]), i6.push(s7[3 * t7 + 2]);
        }
        function G2(t7) {
          r5.push(t7.x), r5.push(t7.y);
        }
        !function() {
          const t7 = i6.length / 3;
          if (h4) {
            let t8 = 0, e9 = C3 * t8;
            for (let t9 = 0; t9 < L3; t9++) {
              const n9 = E3[t9];
              B2(n9[2] + e9, n9[1] + e9, n9[0] + e9);
            }
            t8 = o7 + 2 * p3, e9 = C3 * t8;
            for (let t9 = 0; t9 < L3; t9++) {
              const n9 = E3[t9];
              B2(n9[0] + e9, n9[1] + e9, n9[2] + e9);
            }
          } else {
            for (let t8 = 0; t8 < L3; t8++) {
              const e9 = E3[t8];
              B2(e9[2], e9[1], e9[0]);
            }
            for (let t8 = 0; t8 < L3; t8++) {
              const e9 = E3[t8];
              B2(e9[0] + C3 * o7, e9[1] + C3 * o7, e9[2] + C3 * o7);
            }
          }
          n8.addGroup(t7, i6.length / 3 - t7, 0);
        }(), function() {
          const t7 = i6.length / 3;
          let e9 = 0;
          U2(A3, e9), e9 += A3.length;
          for (let t8 = 0, n9 = T3.length; t8 < n9; t8++) {
            const n10 = T3[t8];
            U2(n10, e9), e9 += n10.length;
          }
          n8.addGroup(t7, i6.length / 3 - t7, 1);
        }();
      }
      this.setAttribute("position", new ce(i6, 3)), this.setAttribute("uv", new ce(r5, 2)), this.computeVertexNormals();
    }
    toJSON() {
      const t5 = super.toJSON();
      return function(t6, e8, n8) {
        if (n8.shapes = [], Array.isArray(t6))
          for (let e9 = 0, i6 = t6.length; e9 < i6; e9++) {
            const i7 = t6[e9];
            n8.shapes.push(i7.uuid);
          }
        else
          n8.shapes.push(t6.uuid);
        e8.extrudePath !== void 0 && (n8.options.extrudePath = e8.extrudePath.toJSON());
        return n8;
      }(this.parameters.shapes, this.parameters.options, t5);
    }
    static fromJSON(t5, e8) {
      const n8 = [];
      for (let i7 = 0, r5 = t5.shapes.length; i7 < r5; i7++) {
        const r6 = e8[t5.shapes[i7]];
        n8.push(r6);
      }
      const i6 = t5.options.extrudePath;
      return i6 !== void 0 && (t5.options.extrudePath = new Qs[i6.type]().fromJSON(i6)), new Pa(n8, t5.options);
    }
  };
  var Da = { generateTopUV: function(t5, e8, n8, i6, r5) {
    const s6 = e8[3 * n8], a4 = e8[3 * n8 + 1], o7 = e8[3 * i6], l6 = e8[3 * i6 + 1], h4 = e8[3 * r5], c3 = e8[3 * r5 + 1];
    return [new g2(s6, a4), new g2(o7, l6), new g2(h4, c3)];
  }, generateSideWallUV: function(t5, e8, n8, i6, r5, s6) {
    const a4 = e8[3 * n8], o7 = e8[3 * n8 + 1], l6 = e8[3 * n8 + 2], h4 = e8[3 * i6], c3 = e8[3 * i6 + 1], u3 = e8[3 * i6 + 2], d3 = e8[3 * r5], p3 = e8[3 * r5 + 1], m3 = e8[3 * r5 + 2], f3 = e8[3 * s6], v3 = e8[3 * s6 + 1], y3 = e8[3 * s6 + 2];
    return Math.abs(o7 - c3) < Math.abs(a4 - h4) ? [new g2(a4, 1 - l6), new g2(h4, 1 - u3), new g2(d3, 1 - m3), new g2(f3, 1 - y3)] : [new g2(o7, 1 - l6), new g2(c3, 1 - u3), new g2(p3, 1 - m3), new g2(v3, 1 - y3)];
  } };
  var Ia = class extends ye {
    constructor(t5 = new na([new g2(0, 0.5), new g2(-0.5, -0.5), new g2(0.5, -0.5)]), e8 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: t5, curveSegments: e8 };
      const n8 = [], i6 = [], r5 = [], s6 = [];
      let a4 = 0, o7 = 0;
      if (Array.isArray(t5) === false)
        l6(t5);
      else
        for (let e9 = 0; e9 < t5.length; e9++)
          l6(t5[e9]), this.addGroup(a4, o7, e9), a4 += o7, o7 = 0;
      function l6(t6) {
        const a5 = i6.length / 3, l7 = t6.extractPoints(e8);
        let h4 = l7.shape;
        const c3 = l7.holes;
        Ra.isClockWise(h4) === false && (h4 = h4.reverse());
        for (let t7 = 0, e9 = c3.length; t7 < e9; t7++) {
          const e10 = c3[t7];
          Ra.isClockWise(e10) === true && (c3[t7] = e10.reverse());
        }
        const u3 = Ra.triangulateShape(h4, c3);
        for (let t7 = 0, e9 = c3.length; t7 < e9; t7++) {
          const e10 = c3[t7];
          h4 = h4.concat(e10);
        }
        for (let t7 = 0, e9 = h4.length; t7 < e9; t7++) {
          const e10 = h4[t7];
          i6.push(e10.x, e10.y, 0), r5.push(0, 0, 1), s6.push(e10.x, e10.y);
        }
        for (let t7 = 0, e9 = u3.length; t7 < e9; t7++) {
          const e10 = u3[t7], i7 = e10[0] + a5, r6 = e10[1] + a5, s7 = e10[2] + a5;
          n8.push(i7, r6, s7), o7 += 3;
        }
      }
      this.setIndex(n8), this.setAttribute("position", new ce(i6, 3)), this.setAttribute("normal", new ce(r5, 3)), this.setAttribute("uv", new ce(s6, 2));
    }
    toJSON() {
      const t5 = super.toJSON();
      return function(t6, e8) {
        if (e8.shapes = [], Array.isArray(t6))
          for (let n8 = 0, i6 = t6.length; n8 < i6; n8++) {
            const i7 = t6[n8];
            e8.shapes.push(i7.uuid);
          }
        else
          e8.shapes.push(t6.uuid);
        return e8;
      }(this.parameters.shapes, t5);
    }
    static fromJSON(t5, e8) {
      const n8 = [];
      for (let i6 = 0, r5 = t5.shapes.length; i6 < r5; i6++) {
        const r6 = e8[t5.shapes[i6]];
        n8.push(r6);
      }
      return new Ia(n8, t5.curveSegments);
    }
  };
  var Oa = class extends ie {
    constructor(t5) {
      super(), this.type = "ShadowMaterial", this.color = new L2(0), this.transparent = true, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this;
    }
  };
  Oa.prototype.isShadowMaterial = true;
  var Na = class extends Ve {
    constructor(t5) {
      super(t5), this.type = "RawShaderMaterial";
    }
  };
  Na.prototype.isRawShaderMaterial = true;
  var Fa = class extends ie {
    constructor(t5) {
      super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new L2(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L2(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.defines = { STANDARD: "" }, this.color.copy(t5.color), this.roughness = t5.roughness, this.metalness = t5.metalness, this.map = t5.map, this.lightMap = t5.lightMap, this.lightMapIntensity = t5.lightMapIntensity, this.aoMap = t5.aoMap, this.aoMapIntensity = t5.aoMapIntensity, this.emissive.copy(t5.emissive), this.emissiveMap = t5.emissiveMap, this.emissiveIntensity = t5.emissiveIntensity, this.bumpMap = t5.bumpMap, this.bumpScale = t5.bumpScale, this.normalMap = t5.normalMap, this.normalMapType = t5.normalMapType, this.normalScale.copy(t5.normalScale), this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.roughnessMap = t5.roughnessMap, this.metalnessMap = t5.metalnessMap, this.alphaMap = t5.alphaMap, this.envMap = t5.envMap, this.envMapIntensity = t5.envMapIntensity, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.wireframeLinecap = t5.wireframeLinecap, this.wireframeLinejoin = t5.wireframeLinejoin, this.flatShading = t5.flatShading, this;
    }
  };
  Fa.prototype.isMeshStandardMaterial = true;
  var Ua = class extends Fa {
    constructor(t5) {
      super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new g2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
        return h3(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      }, set: function(t6) {
        this.ior = (1 + 0.4 * t6) / (1 - 0.4 * t6);
      } }), this.sheenColor = new L2(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new L2(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new L2(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t5);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t5) {
      this._sheen > 0 != t5 > 0 && this.version++, this._sheen = t5;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t5) {
      this._clearcoat > 0 != t5 > 0 && this.version++, this._clearcoat = t5;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t5) {
      this._transmission > 0 != t5 > 0 && this.version++, this._transmission = t5;
    }
    copy(t5) {
      return super.copy(t5), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t5.clearcoat, this.clearcoatMap = t5.clearcoatMap, this.clearcoatRoughness = t5.clearcoatRoughness, this.clearcoatRoughnessMap = t5.clearcoatRoughnessMap, this.clearcoatNormalMap = t5.clearcoatNormalMap, this.clearcoatNormalScale.copy(t5.clearcoatNormalScale), this.ior = t5.ior, this.sheen = t5.sheen, this.sheenColor.copy(t5.sheenColor), this.sheenColorMap = t5.sheenColorMap, this.sheenRoughness = t5.sheenRoughness, this.sheenRoughnessMap = t5.sheenRoughnessMap, this.transmission = t5.transmission, this.transmissionMap = t5.transmissionMap, this.thickness = t5.thickness, this.thicknessMap = t5.thicknessMap, this.attenuationDistance = t5.attenuationDistance, this.attenuationColor.copy(t5.attenuationColor), this.specularIntensity = t5.specularIntensity, this.specularIntensityMap = t5.specularIntensityMap, this.specularColor.copy(t5.specularColor), this.specularColorMap = t5.specularColorMap, this;
    }
  };
  Ua.prototype.isMeshPhysicalMaterial = true;
  var ka = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshPhongMaterial", this.color = new L2(16777215), this.specular = new L2(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L2(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.specular.copy(t5.specular), this.shininess = t5.shininess, this.map = t5.map, this.lightMap = t5.lightMap, this.lightMapIntensity = t5.lightMapIntensity, this.aoMap = t5.aoMap, this.aoMapIntensity = t5.aoMapIntensity, this.emissive.copy(t5.emissive), this.emissiveMap = t5.emissiveMap, this.emissiveIntensity = t5.emissiveIntensity, this.bumpMap = t5.bumpMap, this.bumpScale = t5.bumpScale, this.normalMap = t5.normalMap, this.normalMapType = t5.normalMapType, this.normalScale.copy(t5.normalScale), this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.specularMap = t5.specularMap, this.alphaMap = t5.alphaMap, this.envMap = t5.envMap, this.combine = t5.combine, this.reflectivity = t5.reflectivity, this.refractionRatio = t5.refractionRatio, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.wireframeLinecap = t5.wireframeLinecap, this.wireframeLinejoin = t5.wireframeLinejoin, this.flatShading = t5.flatShading, this;
    }
  };
  ka.prototype.isMeshPhongMaterial = true;
  var Ba = class extends ie {
    constructor(t5) {
      super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new L2(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L2(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.map = t5.map, this.gradientMap = t5.gradientMap, this.lightMap = t5.lightMap, this.lightMapIntensity = t5.lightMapIntensity, this.aoMap = t5.aoMap, this.aoMapIntensity = t5.aoMapIntensity, this.emissive.copy(t5.emissive), this.emissiveMap = t5.emissiveMap, this.emissiveIntensity = t5.emissiveIntensity, this.bumpMap = t5.bumpMap, this.bumpScale = t5.bumpScale, this.normalMap = t5.normalMap, this.normalMapType = t5.normalMapType, this.normalScale.copy(t5.normalScale), this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.alphaMap = t5.alphaMap, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.wireframeLinecap = t5.wireframeLinecap, this.wireframeLinejoin = t5.wireframeLinejoin, this;
    }
  };
  Ba.prototype.isMeshToonMaterial = true;
  var za = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.bumpMap = t5.bumpMap, this.bumpScale = t5.bumpScale, this.normalMap = t5.normalMap, this.normalMapType = t5.normalMapType, this.normalScale.copy(t5.normalScale), this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.flatShading = t5.flatShading, this;
    }
  };
  za.prototype.isMeshNormalMaterial = true;
  var Ha = class extends ie {
    constructor(t5) {
      super(), this.type = "MeshLambertMaterial", this.color = new L2(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L2(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.map = t5.map, this.lightMap = t5.lightMap, this.lightMapIntensity = t5.lightMapIntensity, this.aoMap = t5.aoMap, this.aoMapIntensity = t5.aoMapIntensity, this.emissive.copy(t5.emissive), this.emissiveMap = t5.emissiveMap, this.emissiveIntensity = t5.emissiveIntensity, this.specularMap = t5.specularMap, this.alphaMap = t5.alphaMap, this.envMap = t5.envMap, this.combine = t5.combine, this.reflectivity = t5.reflectivity, this.refractionRatio = t5.refractionRatio, this.wireframe = t5.wireframe, this.wireframeLinewidth = t5.wireframeLinewidth, this.wireframeLinecap = t5.wireframeLinecap, this.wireframeLinejoin = t5.wireframeLinejoin, this;
    }
  };
  Ha.prototype.isMeshLambertMaterial = true;
  var Va = class extends ie {
    constructor(t5) {
      super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new L2(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.defines = { MATCAP: "" }, this.color.copy(t5.color), this.matcap = t5.matcap, this.map = t5.map, this.bumpMap = t5.bumpMap, this.bumpScale = t5.bumpScale, this.normalMap = t5.normalMap, this.normalMapType = t5.normalMapType, this.normalScale.copy(t5.normalScale), this.displacementMap = t5.displacementMap, this.displacementScale = t5.displacementScale, this.displacementBias = t5.displacementBias, this.alphaMap = t5.alphaMap, this.flatShading = t5.flatShading, this;
    }
  };
  Va.prototype.isMeshMatcapMaterial = true;
  var Ga = class extends gs {
    constructor(t5) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.scale = t5.scale, this.dashSize = t5.dashSize, this.gapSize = t5.gapSize, this;
    }
  };
  Ga.prototype.isLineDashedMaterial = true;
  var Wa = { ShadowMaterial: Oa, SpriteMaterial: Br, RawShaderMaterial: Na, ShaderMaterial: Ve, PointsMaterial: As, MeshPhysicalMaterial: Ua, MeshStandardMaterial: Fa, MeshPhongMaterial: ka, MeshToonMaterial: Ba, MeshNormalMaterial: za, MeshLambertMaterial: Ha, MeshDepthMaterial: _r, MeshDistanceMaterial: wr, MeshBasicMaterial: re, MeshMatcapMaterial: Va, LineDashedMaterial: Ga, LineBasicMaterial: gs, Material: ie };
  ie.fromType = function(t5) {
    return new Wa[t5]();
  };
  var ja = { arraySlice: function(t5, e8, n8) {
    return ja.isTypedArray(t5) ? new t5.constructor(t5.subarray(e8, n8 !== void 0 ? n8 : t5.length)) : t5.slice(e8, n8);
  }, convertArray: function(t5, e8, n8) {
    return !t5 || !n8 && t5.constructor === e8 ? t5 : typeof e8.BYTES_PER_ELEMENT == "number" ? new e8(t5) : Array.prototype.slice.call(t5);
  }, isTypedArray: function(t5) {
    return ArrayBuffer.isView(t5) && !(t5 instanceof DataView);
  }, getKeyframeOrder: function(t5) {
    const e8 = t5.length, n8 = new Array(e8);
    for (let t6 = 0; t6 !== e8; ++t6)
      n8[t6] = t6;
    return n8.sort(function(e9, n9) {
      return t5[e9] - t5[n9];
    }), n8;
  }, sortedArray: function(t5, e8, n8) {
    const i6 = t5.length, r5 = new t5.constructor(i6);
    for (let s6 = 0, a4 = 0; a4 !== i6; ++s6) {
      const i7 = n8[s6] * e8;
      for (let n9 = 0; n9 !== e8; ++n9)
        r5[a4++] = t5[i7 + n9];
    }
    return r5;
  }, flattenJSON: function(t5, e8, n8, i6) {
    let r5 = 1, s6 = t5[0];
    for (; s6 !== void 0 && s6[i6] === void 0; )
      s6 = t5[r5++];
    if (s6 === void 0)
      return;
    let a4 = s6[i6];
    if (a4 !== void 0)
      if (Array.isArray(a4))
        do {
          a4 = s6[i6], a4 !== void 0 && (e8.push(s6.time), n8.push.apply(n8, a4)), s6 = t5[r5++];
        } while (s6 !== void 0);
      else if (a4.toArray !== void 0)
        do {
          a4 = s6[i6], a4 !== void 0 && (e8.push(s6.time), a4.toArray(n8, n8.length)), s6 = t5[r5++];
        } while (s6 !== void 0);
      else
        do {
          a4 = s6[i6], a4 !== void 0 && (e8.push(s6.time), n8.push(a4)), s6 = t5[r5++];
        } while (s6 !== void 0);
  }, subclip: function(t5, e8, n8, i6, r5 = 30) {
    const s6 = t5.clone();
    s6.name = e8;
    const a4 = [];
    for (let t6 = 0; t6 < s6.tracks.length; ++t6) {
      const e9 = s6.tracks[t6], o8 = e9.getValueSize(), l6 = [], h4 = [];
      for (let t7 = 0; t7 < e9.times.length; ++t7) {
        const s7 = e9.times[t7] * r5;
        if (!(s7 < n8 || s7 >= i6)) {
          l6.push(e9.times[t7]);
          for (let n9 = 0; n9 < o8; ++n9)
            h4.push(e9.values[t7 * o8 + n9]);
        }
      }
      l6.length !== 0 && (e9.times = ja.convertArray(l6, e9.times.constructor), e9.values = ja.convertArray(h4, e9.values.constructor), a4.push(e9));
    }
    s6.tracks = a4;
    let o7 = 1 / 0;
    for (let t6 = 0; t6 < s6.tracks.length; ++t6)
      o7 > s6.tracks[t6].times[0] && (o7 = s6.tracks[t6].times[0]);
    for (let t6 = 0; t6 < s6.tracks.length; ++t6)
      s6.tracks[t6].shift(-1 * o7);
    return s6.resetDuration(), s6;
  }, makeClipAdditive: function(t5, e8 = 0, n8 = t5, i6 = 30) {
    i6 <= 0 && (i6 = 30);
    const r5 = n8.tracks.length, s6 = e8 / i6;
    for (let e9 = 0; e9 < r5; ++e9) {
      const i7 = n8.tracks[e9], r6 = i7.ValueTypeName;
      if (r6 === "bool" || r6 === "string")
        continue;
      const a4 = t5.tracks.find(function(t6) {
        return t6.name === i7.name && t6.ValueTypeName === r6;
      });
      if (a4 === void 0)
        continue;
      let o7 = 0;
      const l6 = i7.getValueSize();
      i7.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o7 = l6 / 3);
      let h4 = 0;
      const c3 = a4.getValueSize();
      a4.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h4 = c3 / 3);
      const u3 = i7.times.length - 1;
      let d3;
      if (s6 <= i7.times[0]) {
        const t6 = o7, e10 = l6 - o7;
        d3 = ja.arraySlice(i7.values, t6, e10);
      } else if (s6 >= i7.times[u3]) {
        const t6 = u3 * l6 + o7, e10 = t6 + l6 - o7;
        d3 = ja.arraySlice(i7.values, t6, e10);
      } else {
        const t6 = i7.createInterpolant(), e10 = o7, n9 = l6 - o7;
        t6.evaluate(s6), d3 = ja.arraySlice(t6.resultBuffer, e10, n9);
      }
      if (r6 === "quaternion") {
        new H2().fromArray(d3).normalize().conjugate().toArray(d3);
      }
      const p3 = a4.times.length;
      for (let t6 = 0; t6 < p3; ++t6) {
        const e10 = t6 * c3 + h4;
        if (r6 === "quaternion")
          H2.multiplyQuaternionsFlat(a4.values, e10, d3, 0, a4.values, e10);
        else {
          const t7 = c3 - 2 * h4;
          for (let n9 = 0; n9 < t7; ++n9)
            a4.values[e10 + n9] -= d3[n9];
        }
      }
    }
    return t5.blendMode = 2501, t5;
  } };
  var qa = class {
    constructor(t5, e8, n8, i6) {
      this.parameterPositions = t5, this._cachedIndex = 0, this.resultBuffer = i6 !== void 0 ? i6 : new e8.constructor(n8), this.sampleValues = e8, this.valueSize = n8, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t5) {
      const e8 = this.parameterPositions;
      let n8 = this._cachedIndex, i6 = e8[n8], r5 = e8[n8 - 1];
      t: {
        e: {
          let s6;
          n: {
            i:
              if (!(t5 < i6)) {
                for (let s7 = n8 + 2; ; ) {
                  if (i6 === void 0) {
                    if (t5 < r5)
                      break i;
                    return n8 = e8.length, this._cachedIndex = n8, this.afterEnd_(n8 - 1, t5, r5);
                  }
                  if (n8 === s7)
                    break;
                  if (r5 = i6, i6 = e8[++n8], t5 < i6)
                    break e;
                }
                s6 = e8.length;
                break n;
              }
            if (t5 >= r5)
              break t;
            {
              const a4 = e8[1];
              t5 < a4 && (n8 = 2, r5 = a4);
              for (let s7 = n8 - 2; ; ) {
                if (r5 === void 0)
                  return this._cachedIndex = 0, this.beforeStart_(0, t5, i6);
                if (n8 === s7)
                  break;
                if (i6 = r5, r5 = e8[--n8 - 1], t5 >= r5)
                  break e;
              }
              s6 = n8, n8 = 0;
            }
          }
          for (; n8 < s6; ) {
            const i7 = n8 + s6 >>> 1;
            t5 < e8[i7] ? s6 = i7 : n8 = i7 + 1;
          }
          if (i6 = e8[n8], r5 = e8[n8 - 1], r5 === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t5, i6);
          if (i6 === void 0)
            return n8 = e8.length, this._cachedIndex = n8, this.afterEnd_(n8 - 1, r5, t5);
        }
        this._cachedIndex = n8, this.intervalChanged_(n8, r5, i6);
      }
      return this.interpolate_(n8, r5, t5, i6);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t5) {
      const e8 = this.resultBuffer, n8 = this.sampleValues, i6 = this.valueSize, r5 = t5 * i6;
      for (let t6 = 0; t6 !== i6; ++t6)
        e8[t6] = n8[r5 + t6];
      return e8;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  qa.prototype.beforeStart_ = qa.prototype.copySampleValue_, qa.prototype.afterEnd_ = qa.prototype.copySampleValue_;
  var Xa = class extends qa {
    constructor(t5, e8, n8, i6) {
      super(t5, e8, n8, i6), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
    }
    intervalChanged_(t5, e8, n8) {
      const i6 = this.parameterPositions;
      let r5 = t5 - 2, s6 = t5 + 1, a4 = i6[r5], o7 = i6[s6];
      if (a4 === void 0)
        switch (this.getSettings_().endingStart) {
          case 2401:
            r5 = t5, a4 = 2 * e8 - n8;
            break;
          case 2402:
            r5 = i6.length - 2, a4 = e8 + i6[r5] - i6[r5 + 1];
            break;
          default:
            r5 = t5, a4 = n8;
        }
      if (o7 === void 0)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            s6 = t5, o7 = 2 * n8 - e8;
            break;
          case 2402:
            s6 = 1, o7 = n8 + i6[1] - i6[0];
            break;
          default:
            s6 = t5 - 1, o7 = e8;
        }
      const l6 = 0.5 * (n8 - e8), h4 = this.valueSize;
      this._weightPrev = l6 / (e8 - a4), this._weightNext = l6 / (o7 - n8), this._offsetPrev = r5 * h4, this._offsetNext = s6 * h4;
    }
    interpolate_(t5, e8, n8, i6) {
      const r5 = this.resultBuffer, s6 = this.sampleValues, a4 = this.valueSize, o7 = t5 * a4, l6 = o7 - a4, h4 = this._offsetPrev, c3 = this._offsetNext, u3 = this._weightPrev, d3 = this._weightNext, p3 = (n8 - e8) / (i6 - e8), m3 = p3 * p3, f3 = m3 * p3, g3 = -u3 * f3 + 2 * u3 * m3 - u3 * p3, v3 = (1 + u3) * f3 + (-1.5 - 2 * u3) * m3 + (-0.5 + u3) * p3 + 1, y3 = (-1 - d3) * f3 + (1.5 + d3) * m3 + 0.5 * p3, x3 = d3 * f3 - d3 * m3;
      for (let t6 = 0; t6 !== a4; ++t6)
        r5[t6] = g3 * s6[h4 + t6] + v3 * s6[l6 + t6] + y3 * s6[o7 + t6] + x3 * s6[c3 + t6];
      return r5;
    }
  };
  var $a = class extends qa {
    constructor(t5, e8, n8, i6) {
      super(t5, e8, n8, i6);
    }
    interpolate_(t5, e8, n8, i6) {
      const r5 = this.resultBuffer, s6 = this.sampleValues, a4 = this.valueSize, o7 = t5 * a4, l6 = o7 - a4, h4 = (n8 - e8) / (i6 - e8), c3 = 1 - h4;
      for (let t6 = 0; t6 !== a4; ++t6)
        r5[t6] = s6[l6 + t6] * c3 + s6[o7 + t6] * h4;
      return r5;
    }
  };
  var Ya = class extends qa {
    constructor(t5, e8, n8, i6) {
      super(t5, e8, n8, i6);
    }
    interpolate_(t5) {
      return this.copySampleValue_(t5 - 1);
    }
  };
  var Ja = class {
    constructor(t5, e8, n8, i6) {
      if (t5 === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (e8 === void 0 || e8.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t5);
      this.name = t5, this.times = ja.convertArray(e8, this.TimeBufferType), this.values = ja.convertArray(n8, this.ValueBufferType), this.setInterpolation(i6 || this.DefaultInterpolation);
    }
    static toJSON(t5) {
      const e8 = t5.constructor;
      let n8;
      if (e8.toJSON !== this.toJSON)
        n8 = e8.toJSON(t5);
      else {
        n8 = { name: t5.name, times: ja.convertArray(t5.times, Array), values: ja.convertArray(t5.values, Array) };
        const e9 = t5.getInterpolation();
        e9 !== t5.DefaultInterpolation && (n8.interpolation = e9);
      }
      return n8.type = t5.ValueTypeName, n8;
    }
    InterpolantFactoryMethodDiscrete(t5) {
      return new Ya(this.times, this.values, this.getValueSize(), t5);
    }
    InterpolantFactoryMethodLinear(t5) {
      return new $a(this.times, this.values, this.getValueSize(), t5);
    }
    InterpolantFactoryMethodSmooth(t5) {
      return new Xa(this.times, this.values, this.getValueSize(), t5);
    }
    setInterpolation(t5) {
      let e8;
      switch (t5) {
        case 2300:
          e8 = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e8 = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e8 = this.InterpolantFactoryMethodSmooth;
      }
      if (e8 === void 0) {
        const e9 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (t5 === this.DefaultInterpolation)
            throw new Error(e9);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e9), this;
      }
      return this.createInterpolant = e8, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t5) {
      if (t5 !== 0) {
        const e8 = this.times;
        for (let n8 = 0, i6 = e8.length; n8 !== i6; ++n8)
          e8[n8] += t5;
      }
      return this;
    }
    scale(t5) {
      if (t5 !== 1) {
        const e8 = this.times;
        for (let n8 = 0, i6 = e8.length; n8 !== i6; ++n8)
          e8[n8] *= t5;
      }
      return this;
    }
    trim(t5, e8) {
      const n8 = this.times, i6 = n8.length;
      let r5 = 0, s6 = i6 - 1;
      for (; r5 !== i6 && n8[r5] < t5; )
        ++r5;
      for (; s6 !== -1 && n8[s6] > e8; )
        --s6;
      if (++s6, r5 !== 0 || s6 !== i6) {
        r5 >= s6 && (s6 = Math.max(s6, 1), r5 = s6 - 1);
        const t6 = this.getValueSize();
        this.times = ja.arraySlice(n8, r5, s6), this.values = ja.arraySlice(this.values, r5 * t6, s6 * t6);
      }
      return this;
    }
    validate() {
      let t5 = true;
      const e8 = this.getValueSize();
      e8 - Math.floor(e8) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t5 = false);
      const n8 = this.times, i6 = this.values, r5 = n8.length;
      r5 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t5 = false);
      let s6 = null;
      for (let e9 = 0; e9 !== r5; e9++) {
        const i7 = n8[e9];
        if (typeof i7 == "number" && isNaN(i7)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e9, i7), t5 = false;
          break;
        }
        if (s6 !== null && s6 > i7) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, e9, i7, s6), t5 = false;
          break;
        }
        s6 = i7;
      }
      if (i6 !== void 0 && ja.isTypedArray(i6))
        for (let e9 = 0, n9 = i6.length; e9 !== n9; ++e9) {
          const n10 = i6[e9];
          if (isNaN(n10)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e9, n10), t5 = false;
            break;
          }
        }
      return t5;
    }
    optimize() {
      const t5 = ja.arraySlice(this.times), e8 = ja.arraySlice(this.values), n8 = this.getValueSize(), i6 = this.getInterpolation() === 2302, r5 = t5.length - 1;
      let s6 = 1;
      for (let a4 = 1; a4 < r5; ++a4) {
        let r6 = false;
        const o7 = t5[a4];
        if (o7 !== t5[a4 + 1] && (a4 !== 1 || o7 !== t5[0]))
          if (i6)
            r6 = true;
          else {
            const t6 = a4 * n8, i7 = t6 - n8, s7 = t6 + n8;
            for (let a5 = 0; a5 !== n8; ++a5) {
              const n9 = e8[t6 + a5];
              if (n9 !== e8[i7 + a5] || n9 !== e8[s7 + a5]) {
                r6 = true;
                break;
              }
            }
          }
        if (r6) {
          if (a4 !== s6) {
            t5[s6] = t5[a4];
            const i7 = a4 * n8, r7 = s6 * n8;
            for (let t6 = 0; t6 !== n8; ++t6)
              e8[r7 + t6] = e8[i7 + t6];
          }
          ++s6;
        }
      }
      if (r5 > 0) {
        t5[s6] = t5[r5];
        for (let t6 = r5 * n8, i7 = s6 * n8, a4 = 0; a4 !== n8; ++a4)
          e8[i7 + a4] = e8[t6 + a4];
        ++s6;
      }
      return s6 !== t5.length ? (this.times = ja.arraySlice(t5, 0, s6), this.values = ja.arraySlice(e8, 0, s6 * n8)) : (this.times = t5, this.values = e8), this;
    }
    clone() {
      const t5 = ja.arraySlice(this.times, 0), e8 = ja.arraySlice(this.values, 0), n8 = new (0, this.constructor)(this.name, t5, e8);
      return n8.createInterpolant = this.createInterpolant, n8;
    }
  };
  Ja.prototype.TimeBufferType = Float32Array, Ja.prototype.ValueBufferType = Float32Array, Ja.prototype.DefaultInterpolation = 2301;
  var Ka = class extends Ja {
  };
  Ka.prototype.ValueTypeName = "bool", Ka.prototype.ValueBufferType = Array, Ka.prototype.DefaultInterpolation = 2300, Ka.prototype.InterpolantFactoryMethodLinear = void 0, Ka.prototype.InterpolantFactoryMethodSmooth = void 0;
  var Za = class extends Ja {
  };
  Za.prototype.ValueTypeName = "color";
  var Qa = class extends Ja {
  };
  Qa.prototype.ValueTypeName = "number";
  var to = class extends qa {
    constructor(t5, e8, n8, i6) {
      super(t5, e8, n8, i6);
    }
    interpolate_(t5, e8, n8, i6) {
      const r5 = this.resultBuffer, s6 = this.sampleValues, a4 = this.valueSize, o7 = (n8 - e8) / (i6 - e8);
      let l6 = t5 * a4;
      for (let t6 = l6 + a4; l6 !== t6; l6 += 4)
        H2.slerpFlat(r5, 0, s6, l6 - a4, s6, l6, o7);
      return r5;
    }
  };
  var eo = class extends Ja {
    InterpolantFactoryMethodLinear(t5) {
      return new to(this.times, this.values, this.getValueSize(), t5);
    }
  };
  eo.prototype.ValueTypeName = "quaternion", eo.prototype.DefaultInterpolation = 2301, eo.prototype.InterpolantFactoryMethodSmooth = void 0;
  var no = class extends Ja {
  };
  no.prototype.ValueTypeName = "string", no.prototype.ValueBufferType = Array, no.prototype.DefaultInterpolation = 2300, no.prototype.InterpolantFactoryMethodLinear = void 0, no.prototype.InterpolantFactoryMethodSmooth = void 0;
  var io = class extends Ja {
  };
  io.prototype.ValueTypeName = "vector";
  var ro = class {
    constructor(t5, e8 = -1, n8, i6 = 2500) {
      this.name = t5, this.tracks = n8, this.duration = e8, this.blendMode = i6, this.uuid = l5(), this.duration < 0 && this.resetDuration();
    }
    static parse(t5) {
      const e8 = [], n8 = t5.tracks, i6 = 1 / (t5.fps || 1);
      for (let t6 = 0, r6 = n8.length; t6 !== r6; ++t6)
        e8.push(so(n8[t6]).scale(i6));
      const r5 = new this(t5.name, t5.duration, e8, t5.blendMode);
      return r5.uuid = t5.uuid, r5;
    }
    static toJSON(t5) {
      const e8 = [], n8 = t5.tracks, i6 = { name: t5.name, duration: t5.duration, tracks: e8, uuid: t5.uuid, blendMode: t5.blendMode };
      for (let t6 = 0, i7 = n8.length; t6 !== i7; ++t6)
        e8.push(Ja.toJSON(n8[t6]));
      return i6;
    }
    static CreateFromMorphTargetSequence(t5, e8, n8, i6) {
      const r5 = e8.length, s6 = [];
      for (let t6 = 0; t6 < r5; t6++) {
        let a4 = [], o7 = [];
        a4.push((t6 + r5 - 1) % r5, t6, (t6 + 1) % r5), o7.push(0, 1, 0);
        const l6 = ja.getKeyframeOrder(a4);
        a4 = ja.sortedArray(a4, 1, l6), o7 = ja.sortedArray(o7, 1, l6), i6 || a4[0] !== 0 || (a4.push(r5), o7.push(o7[0])), s6.push(new Qa(".morphTargetInfluences[" + e8[t6].name + "]", a4, o7).scale(1 / n8));
      }
      return new this(t5, -1, s6);
    }
    static findByName(t5, e8) {
      let n8 = t5;
      if (!Array.isArray(t5)) {
        const e9 = t5;
        n8 = e9.geometry && e9.geometry.animations || e9.animations;
      }
      for (let t6 = 0; t6 < n8.length; t6++)
        if (n8[t6].name === e8)
          return n8[t6];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t5, e8, n8) {
      const i6 = {}, r5 = /^([\w-]*?)([\d]+)$/;
      for (let e9 = 0, n9 = t5.length; e9 < n9; e9++) {
        const n10 = t5[e9], s7 = n10.name.match(r5);
        if (s7 && s7.length > 1) {
          const t6 = s7[1];
          let e10 = i6[t6];
          e10 || (i6[t6] = e10 = []), e10.push(n10);
        }
      }
      const s6 = [];
      for (const t6 in i6)
        s6.push(this.CreateFromMorphTargetSequence(t6, i6[t6], e8, n8));
      return s6;
    }
    static parseAnimation(t5, e8) {
      if (!t5)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n8 = function(t6, e9, n9, i7, r6) {
        if (n9.length !== 0) {
          const s7 = [], a5 = [];
          ja.flattenJSON(n9, s7, a5, i7), s7.length !== 0 && r6.push(new t6(e9, s7, a5));
        }
      }, i6 = [], r5 = t5.name || "default", s6 = t5.fps || 30, a4 = t5.blendMode;
      let o7 = t5.length || -1;
      const l6 = t5.hierarchy || [];
      for (let t6 = 0; t6 < l6.length; t6++) {
        const r6 = l6[t6].keys;
        if (r6 && r6.length !== 0)
          if (r6[0].morphTargets) {
            const t7 = {};
            let e9;
            for (e9 = 0; e9 < r6.length; e9++)
              if (r6[e9].morphTargets)
                for (let n9 = 0; n9 < r6[e9].morphTargets.length; n9++)
                  t7[r6[e9].morphTargets[n9]] = -1;
            for (const n9 in t7) {
              const t8 = [], s7 = [];
              for (let i7 = 0; i7 !== r6[e9].morphTargets.length; ++i7) {
                const i8 = r6[e9];
                t8.push(i8.time), s7.push(i8.morphTarget === n9 ? 1 : 0);
              }
              i6.push(new Qa(".morphTargetInfluence[" + n9 + "]", t8, s7));
            }
            o7 = t7.length * s6;
          } else {
            const s7 = ".bones[" + e8[t6].name + "]";
            n8(io, s7 + ".position", r6, "pos", i6), n8(eo, s7 + ".quaternion", r6, "rot", i6), n8(io, s7 + ".scale", r6, "scl", i6);
          }
      }
      if (i6.length === 0)
        return null;
      return new this(r5, o7, i6, a4);
    }
    resetDuration() {
      let t5 = 0;
      for (let e8 = 0, n8 = this.tracks.length; e8 !== n8; ++e8) {
        const n9 = this.tracks[e8];
        t5 = Math.max(t5, n9.times[n9.times.length - 1]);
      }
      return this.duration = t5, this;
    }
    trim() {
      for (let t5 = 0; t5 < this.tracks.length; t5++)
        this.tracks[t5].trim(0, this.duration);
      return this;
    }
    validate() {
      let t5 = true;
      for (let e8 = 0; e8 < this.tracks.length; e8++)
        t5 = t5 && this.tracks[e8].validate();
      return t5;
    }
    optimize() {
      for (let t5 = 0; t5 < this.tracks.length; t5++)
        this.tracks[t5].optimize();
      return this;
    }
    clone() {
      const t5 = [];
      for (let e8 = 0; e8 < this.tracks.length; e8++)
        t5.push(this.tracks[e8].clone());
      return new this.constructor(this.name, this.duration, t5, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function so(t5) {
    if (t5.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e8 = function(t6) {
      switch (t6.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Qa;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return io;
        case "color":
          return Za;
        case "quaternion":
          return eo;
        case "bool":
        case "boolean":
          return Ka;
        case "string":
          return no;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t6);
    }(t5.type);
    if (t5.times === void 0) {
      const e9 = [], n8 = [];
      ja.flattenJSON(t5.keys, e9, n8, "value"), t5.times = e9, t5.values = n8;
    }
    return e8.parse !== void 0 ? e8.parse(t5) : new e8(t5.name, t5.times, t5.values, t5.interpolation);
  }
  var ao = { enabled: false, files: {}, add: function(t5, e8) {
    this.enabled !== false && (this.files[t5] = e8);
  }, get: function(t5) {
    if (this.enabled !== false)
      return this.files[t5];
  }, remove: function(t5) {
    delete this.files[t5];
  }, clear: function() {
    this.files = {};
  } };
  var oo = new class {
    constructor(t5, e8, n8) {
      const i6 = this;
      let r5, s6 = false, a4 = 0, o7 = 0;
      const l6 = [];
      this.onStart = void 0, this.onLoad = t5, this.onProgress = e8, this.onError = n8, this.itemStart = function(t6) {
        o7++, s6 === false && i6.onStart !== void 0 && i6.onStart(t6, a4, o7), s6 = true;
      }, this.itemEnd = function(t6) {
        a4++, i6.onProgress !== void 0 && i6.onProgress(t6, a4, o7), a4 === o7 && (s6 = false, i6.onLoad !== void 0 && i6.onLoad());
      }, this.itemError = function(t6) {
        i6.onError !== void 0 && i6.onError(t6);
      }, this.resolveURL = function(t6) {
        return r5 ? r5(t6) : t6;
      }, this.setURLModifier = function(t6) {
        return r5 = t6, this;
      }, this.addHandler = function(t6, e9) {
        return l6.push(t6, e9), this;
      }, this.removeHandler = function(t6) {
        const e9 = l6.indexOf(t6);
        return e9 !== -1 && l6.splice(e9, 2), this;
      }, this.getHandler = function(t6) {
        for (let e9 = 0, n9 = l6.length; e9 < n9; e9 += 2) {
          const n10 = l6[e9], i7 = l6[e9 + 1];
          if (n10.global && (n10.lastIndex = 0), n10.test(t6))
            return i7;
        }
        return null;
      };
    }
  }();
  var lo = class {
    constructor(t5) {
      this.manager = t5 !== void 0 ? t5 : oo, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(t5, e8) {
      const n8 = this;
      return new Promise(function(i6, r5) {
        n8.load(t5, i6, e8, r5);
      });
    }
    parse() {
    }
    setCrossOrigin(t5) {
      return this.crossOrigin = t5, this;
    }
    setWithCredentials(t5) {
      return this.withCredentials = t5, this;
    }
    setPath(t5) {
      return this.path = t5, this;
    }
    setResourcePath(t5) {
      return this.resourcePath = t5, this;
    }
    setRequestHeader(t5) {
      return this.requestHeader = t5, this;
    }
  };
  var ho = {};
  var co = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      t5 === void 0 && (t5 = ""), this.path !== void 0 && (t5 = this.path + t5), t5 = this.manager.resolveURL(t5);
      const r5 = ao.get(t5);
      if (r5 !== void 0)
        return this.manager.itemStart(t5), setTimeout(() => {
          e8 && e8(r5), this.manager.itemEnd(t5);
        }, 0), r5;
      if (ho[t5] !== void 0)
        return void ho[t5].push({ onLoad: e8, onProgress: n8, onError: i6 });
      ho[t5] = [], ho[t5].push({ onLoad: e8, onProgress: n8, onError: i6 });
      const s6 = new Request(t5, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a4 = this.mimeType, o7 = this.responseType;
      fetch(s6).then((e9) => {
        if (e9.status === 200 || e9.status === 0) {
          if (e9.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream == "undefined" || e9.body === void 0 || e9.body.getReader === void 0)
            return e9;
          const n9 = ho[t5], i7 = e9.body.getReader(), r6 = e9.headers.get("Content-Length"), s7 = r6 ? parseInt(r6) : 0, a5 = s7 !== 0;
          let o8 = 0;
          const l6 = new ReadableStream({ start(t6) {
            !function e10() {
              i7.read().then(({ done: i8, value: r7 }) => {
                if (i8)
                  t6.close();
                else {
                  o8 += r7.byteLength;
                  const i9 = new ProgressEvent("progress", { lengthComputable: a5, loaded: o8, total: s7 });
                  for (let t7 = 0, e11 = n9.length; t7 < e11; t7++) {
                    const e12 = n9[t7];
                    e12.onProgress && e12.onProgress(i9);
                  }
                  t6.enqueue(r7), e10();
                }
              });
            }();
          } });
          return new Response(l6);
        }
        throw Error(`fetch for "${e9.url}" responded with ${e9.status}: ${e9.statusText}`);
      }).then((t6) => {
        switch (o7) {
          case "arraybuffer":
            return t6.arrayBuffer();
          case "blob":
            return t6.blob();
          case "document":
            return t6.text().then((t7) => new DOMParser().parseFromString(t7, a4));
          case "json":
            return t6.json();
          default:
            if (a4 === void 0)
              return t6.text();
            {
              const e9 = /charset="?([^;"\s]*)"?/i.exec(a4), n9 = e9 && e9[1] ? e9[1].toLowerCase() : void 0, i7 = new TextDecoder(n9);
              return t6.arrayBuffer().then((t7) => i7.decode(t7));
            }
        }
      }).then((e9) => {
        ao.add(t5, e9);
        const n9 = ho[t5];
        delete ho[t5];
        for (let t6 = 0, i7 = n9.length; t6 < i7; t6++) {
          const i8 = n9[t6];
          i8.onLoad && i8.onLoad(e9);
        }
      }).catch((e9) => {
        const n9 = ho[t5];
        if (n9 === void 0)
          throw this.manager.itemError(t5), e9;
        delete ho[t5];
        for (let t6 = 0, i7 = n9.length; t6 < i7; t6++) {
          const i8 = n9[t6];
          i8.onError && i8.onError(e9);
        }
        this.manager.itemError(t5);
      }).finally(() => {
        this.manager.itemEnd(t5);
      }), this.manager.itemStart(t5);
    }
    setResponseType(t5) {
      return this.responseType = t5, this;
    }
    setMimeType(t5) {
      return this.mimeType = t5, this;
    }
  };
  var uo = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      this.path !== void 0 && (t5 = this.path + t5), t5 = this.manager.resolveURL(t5);
      const r5 = this, s6 = ao.get(t5);
      if (s6 !== void 0)
        return r5.manager.itemStart(t5), setTimeout(function() {
          e8 && e8(s6), r5.manager.itemEnd(t5);
        }, 0), s6;
      const a4 = x2("img");
      function o7() {
        h4(), ao.add(t5, this), e8 && e8(this), r5.manager.itemEnd(t5);
      }
      function l6(e9) {
        h4(), i6 && i6(e9), r5.manager.itemError(t5), r5.manager.itemEnd(t5);
      }
      function h4() {
        a4.removeEventListener("load", o7, false), a4.removeEventListener("error", l6, false);
      }
      return a4.addEventListener("load", o7, false), a4.addEventListener("error", l6, false), t5.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a4.crossOrigin = this.crossOrigin), r5.manager.itemStart(t5), a4.src = t5, a4;
    }
  };
  var po = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      const r5 = new qe(), s6 = new uo(this.manager);
      s6.setCrossOrigin(this.crossOrigin), s6.setPath(this.path);
      let a4 = 0;
      function o7(n9) {
        s6.load(t5[n9], function(t6) {
          r5.images[n9] = t6, a4++, a4 === 6 && (r5.needsUpdate = true, e8 && e8(r5));
        }, void 0, i6);
      }
      for (let e9 = 0; e9 < t5.length; ++e9)
        o7(e9);
      return r5;
    }
  };
  var mo = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      const r5 = this, s6 = new os(), a4 = new co(this.manager);
      return a4.setResponseType("arraybuffer"), a4.setRequestHeader(this.requestHeader), a4.setPath(this.path), a4.setWithCredentials(r5.withCredentials), a4.load(t5, function(t6) {
        const n9 = r5.parse(t6);
        n9 && (n9.image !== void 0 ? s6.image = n9.image : n9.data !== void 0 && (s6.image.width = n9.width, s6.image.height = n9.height, s6.image.data = n9.data), s6.wrapS = n9.wrapS !== void 0 ? n9.wrapS : 1001, s6.wrapT = n9.wrapT !== void 0 ? n9.wrapT : 1001, s6.magFilter = n9.magFilter !== void 0 ? n9.magFilter : 1006, s6.minFilter = n9.minFilter !== void 0 ? n9.minFilter : 1006, s6.anisotropy = n9.anisotropy !== void 0 ? n9.anisotropy : 1, n9.encoding !== void 0 && (s6.encoding = n9.encoding), n9.flipY !== void 0 && (s6.flipY = n9.flipY), n9.format !== void 0 && (s6.format = n9.format), n9.type !== void 0 && (s6.type = n9.type), n9.mipmaps !== void 0 && (s6.mipmaps = n9.mipmaps, s6.minFilter = 1008), n9.mipmapCount === 1 && (s6.minFilter = 1006), n9.generateMipmaps !== void 0 && (s6.generateMipmaps = n9.generateMipmaps), s6.needsUpdate = true, e8 && e8(s6, n9));
      }, n8, i6), s6;
    }
  };
  var fo = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      const r5 = new F(), s6 = new uo(this.manager);
      return s6.setCrossOrigin(this.crossOrigin), s6.setPath(this.path), s6.load(t5, function(t6) {
        r5.image = t6, r5.needsUpdate = true, e8 !== void 0 && e8(r5);
      }, n8, i6), r5;
    }
  };
  var go = class extends Wt {
    constructor(t5, e8 = 1) {
      super(), this.type = "Light", this.color = new L2(t5), this.intensity = e8;
    }
    dispose() {
    }
    copy(t5) {
      return super.copy(t5), this.color.copy(t5.color), this.intensity = t5.intensity, this;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.object.color = this.color.getHex(), e8.object.intensity = this.intensity, this.groundColor !== void 0 && (e8.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e8.object.distance = this.distance), this.angle !== void 0 && (e8.object.angle = this.angle), this.decay !== void 0 && (e8.object.decay = this.decay), this.penumbra !== void 0 && (e8.object.penumbra = this.penumbra), this.shadow !== void 0 && (e8.object.shadow = this.shadow.toJSON()), e8;
    }
  };
  go.prototype.isLight = true;
  (class extends go {
    constructor(t5, e8, n8) {
      super(t5, n8), this.type = "HemisphereLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.groundColor = new L2(e8);
    }
    copy(t5) {
      return go.prototype.copy.call(this, t5), this.groundColor.copy(t5.groundColor), this;
    }
  }).prototype.isHemisphereLight = true;
  var vo = new xt();
  var yo = new V2();
  var xo = new V2();
  var bo = class {
    constructor(t5) {
      this.camera = t5, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new g2(512, 512), this.map = null, this.mapPass = null, this.matrix = new xt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new tn(), this._frameExtents = new g2(1, 1), this._viewportCount = 1, this._viewports = [new U(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t5) {
      const e8 = this.camera, n8 = this.matrix;
      yo.setFromMatrixPosition(t5.matrixWorld), e8.position.copy(yo), xo.setFromMatrixPosition(t5.target.matrixWorld), e8.lookAt(xo), e8.updateMatrixWorld(), vo.multiplyMatrices(e8.projectionMatrix, e8.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vo), n8.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n8.multiply(e8.projectionMatrix), n8.multiply(e8.matrixWorldInverse);
    }
    getViewport(t5) {
      return this._viewports[t5];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t5) {
      return this.camera = t5.camera.clone(), this.bias = t5.bias, this.radius = t5.radius, this.mapSize.copy(t5.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t5 = {};
      return this.bias !== 0 && (t5.bias = this.bias), this.normalBias !== 0 && (t5.normalBias = this.normalBias), this.radius !== 1 && (t5.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t5.mapSize = this.mapSize.toArray()), t5.camera = this.camera.toJSON(false).object, delete t5.camera.matrix, t5;
    }
  };
  var _o = class extends bo {
    constructor() {
      super(new We(50, 1, 0.5, 500)), this.focus = 1;
    }
    updateMatrices(t5) {
      const e8 = this.camera, n8 = 2 * o6 * t5.angle * this.focus, i6 = this.mapSize.width / this.mapSize.height, r5 = t5.distance || e8.far;
      n8 === e8.fov && i6 === e8.aspect && r5 === e8.far || (e8.fov = n8, e8.aspect = i6, e8.far = r5, e8.updateProjectionMatrix()), super.updateMatrices(t5);
    }
    copy(t5) {
      return super.copy(t5), this.focus = t5.focus, this;
    }
  };
  _o.prototype.isSpotLightShadow = true;
  var wo = class extends go {
    constructor(t5, e8, n8 = 0, i6 = Math.PI / 3, r5 = 0, s6 = 1) {
      super(t5, e8), this.type = "SpotLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.target = new Wt(), this.distance = n8, this.angle = i6, this.penumbra = r5, this.decay = s6, this.shadow = new _o();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t5) {
      this.intensity = t5 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t5) {
      return super.copy(t5), this.distance = t5.distance, this.angle = t5.angle, this.penumbra = t5.penumbra, this.decay = t5.decay, this.target = t5.target.clone(), this.shadow = t5.shadow.clone(), this;
    }
  };
  wo.prototype.isSpotLight = true;
  var Mo = new xt();
  var So = new V2();
  var To = new V2();
  var Eo = class extends bo {
    constructor() {
      super(new We(90, 1, 0.5, 500)), this._frameExtents = new g2(4, 2), this._viewportCount = 6, this._viewports = [new U(2, 1, 1, 1), new U(0, 1, 1, 1), new U(3, 1, 1, 1), new U(1, 1, 1, 1), new U(3, 0, 1, 1), new U(1, 0, 1, 1)], this._cubeDirections = [new V2(1, 0, 0), new V2(-1, 0, 0), new V2(0, 0, 1), new V2(0, 0, -1), new V2(0, 1, 0), new V2(0, -1, 0)], this._cubeUps = [new V2(0, 1, 0), new V2(0, 1, 0), new V2(0, 1, 0), new V2(0, 1, 0), new V2(0, 0, 1), new V2(0, 0, -1)];
    }
    updateMatrices(t5, e8 = 0) {
      const n8 = this.camera, i6 = this.matrix, r5 = t5.distance || n8.far;
      r5 !== n8.far && (n8.far = r5, n8.updateProjectionMatrix()), So.setFromMatrixPosition(t5.matrixWorld), n8.position.copy(So), To.copy(n8.position), To.add(this._cubeDirections[e8]), n8.up.copy(this._cubeUps[e8]), n8.lookAt(To), n8.updateMatrixWorld(), i6.makeTranslation(-So.x, -So.y, -So.z), Mo.multiplyMatrices(n8.projectionMatrix, n8.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mo);
    }
  };
  Eo.prototype.isPointLightShadow = true;
  var Ao = class extends go {
    constructor(t5, e8, n8 = 0, i6 = 1) {
      super(t5, e8), this.type = "PointLight", this.distance = n8, this.decay = i6, this.shadow = new Eo();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t5) {
      this.intensity = t5 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t5) {
      return super.copy(t5), this.distance = t5.distance, this.decay = t5.decay, this.shadow = t5.shadow.clone(), this;
    }
  };
  Ao.prototype.isPointLight = true;
  var Ro = class extends bo {
    constructor() {
      super(new mn(-5, 5, 5, -5, 0.5, 500));
    }
  };
  Ro.prototype.isDirectionalLightShadow = true;
  var Co = class extends go {
    constructor(t5, e8) {
      super(t5, e8), this.type = "DirectionalLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.target = new Wt(), this.shadow = new Ro();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t5) {
      return super.copy(t5), this.target = t5.target.clone(), this.shadow = t5.shadow.clone(), this;
    }
  };
  Co.prototype.isDirectionalLight = true;
  (class extends go {
    constructor(t5, e8) {
      super(t5, e8), this.type = "AmbientLight";
    }
  }).prototype.isAmbientLight = true;
  (class extends go {
    constructor(t5, e8, n8 = 10, i6 = 10) {
      super(t5, e8), this.type = "RectAreaLight", this.width = n8, this.height = i6;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(t5) {
      this.intensity = t5 / (this.width * this.height * Math.PI);
    }
    copy(t5) {
      return super.copy(t5), this.width = t5.width, this.height = t5.height, this;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.object.width = this.width, e8.object.height = this.height, e8;
    }
  }).prototype.isRectAreaLight = true;
  var Lo = class {
    constructor() {
      this.coefficients = [];
      for (let t5 = 0; t5 < 9; t5++)
        this.coefficients.push(new V2());
    }
    set(t5) {
      for (let e8 = 0; e8 < 9; e8++)
        this.coefficients[e8].copy(t5[e8]);
      return this;
    }
    zero() {
      for (let t5 = 0; t5 < 9; t5++)
        this.coefficients[t5].set(0, 0, 0);
      return this;
    }
    getAt(t5, e8) {
      const n8 = t5.x, i6 = t5.y, r5 = t5.z, s6 = this.coefficients;
      return e8.copy(s6[0]).multiplyScalar(0.282095), e8.addScaledVector(s6[1], 0.488603 * i6), e8.addScaledVector(s6[2], 0.488603 * r5), e8.addScaledVector(s6[3], 0.488603 * n8), e8.addScaledVector(s6[4], n8 * i6 * 1.092548), e8.addScaledVector(s6[5], i6 * r5 * 1.092548), e8.addScaledVector(s6[6], 0.315392 * (3 * r5 * r5 - 1)), e8.addScaledVector(s6[7], n8 * r5 * 1.092548), e8.addScaledVector(s6[8], 0.546274 * (n8 * n8 - i6 * i6)), e8;
    }
    getIrradianceAt(t5, e8) {
      const n8 = t5.x, i6 = t5.y, r5 = t5.z, s6 = this.coefficients;
      return e8.copy(s6[0]).multiplyScalar(0.886227), e8.addScaledVector(s6[1], 1.023328 * i6), e8.addScaledVector(s6[2], 1.023328 * r5), e8.addScaledVector(s6[3], 1.023328 * n8), e8.addScaledVector(s6[4], 0.858086 * n8 * i6), e8.addScaledVector(s6[5], 0.858086 * i6 * r5), e8.addScaledVector(s6[6], 0.743125 * r5 * r5 - 0.247708), e8.addScaledVector(s6[7], 0.858086 * n8 * r5), e8.addScaledVector(s6[8], 0.429043 * (n8 * n8 - i6 * i6)), e8;
    }
    add(t5) {
      for (let e8 = 0; e8 < 9; e8++)
        this.coefficients[e8].add(t5.coefficients[e8]);
      return this;
    }
    addScaledSH(t5, e8) {
      for (let n8 = 0; n8 < 9; n8++)
        this.coefficients[n8].addScaledVector(t5.coefficients[n8], e8);
      return this;
    }
    scale(t5) {
      for (let e8 = 0; e8 < 9; e8++)
        this.coefficients[e8].multiplyScalar(t5);
      return this;
    }
    lerp(t5, e8) {
      for (let n8 = 0; n8 < 9; n8++)
        this.coefficients[n8].lerp(t5.coefficients[n8], e8);
      return this;
    }
    equals(t5) {
      for (let e8 = 0; e8 < 9; e8++)
        if (!this.coefficients[e8].equals(t5.coefficients[e8]))
          return false;
      return true;
    }
    copy(t5) {
      return this.set(t5.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t5, e8 = 0) {
      const n8 = this.coefficients;
      for (let i6 = 0; i6 < 9; i6++)
        n8[i6].fromArray(t5, e8 + 3 * i6);
      return this;
    }
    toArray(t5 = [], e8 = 0) {
      const n8 = this.coefficients;
      for (let i6 = 0; i6 < 9; i6++)
        n8[i6].toArray(t5, e8 + 3 * i6);
      return t5;
    }
    static getBasisAt(t5, e8) {
      const n8 = t5.x, i6 = t5.y, r5 = t5.z;
      e8[0] = 0.282095, e8[1] = 0.488603 * i6, e8[2] = 0.488603 * r5, e8[3] = 0.488603 * n8, e8[4] = 1.092548 * n8 * i6, e8[5] = 1.092548 * i6 * r5, e8[6] = 0.315392 * (3 * r5 * r5 - 1), e8[7] = 1.092548 * n8 * r5, e8[8] = 0.546274 * (n8 * n8 - i6 * i6);
    }
  };
  Lo.prototype.isSphericalHarmonics3 = true;
  var Po = class extends go {
    constructor(t5 = new Lo(), e8 = 1) {
      super(void 0, e8), this.sh = t5;
    }
    copy(t5) {
      return super.copy(t5), this.sh.copy(t5.sh), this;
    }
    fromJSON(t5) {
      return this.intensity = t5.intensity, this.sh.fromArray(t5.sh), this;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.object.sh = this.sh.toArray(), e8;
    }
  };
  Po.prototype.isLightProbe = true;
  var Do = class {
    static decodeText(t5) {
      if (typeof TextDecoder != "undefined")
        return new TextDecoder().decode(t5);
      let e8 = "";
      for (let n8 = 0, i6 = t5.length; n8 < i6; n8++)
        e8 += String.fromCharCode(t5[n8]);
      try {
        return decodeURIComponent(escape(e8));
      } catch (t6) {
        return e8;
      }
    }
    static extractUrlBase(t5) {
      const e8 = t5.lastIndexOf("/");
      return e8 === -1 ? "./" : t5.slice(0, e8 + 1);
    }
    static resolveURL(t5, e8) {
      return typeof t5 != "string" || t5 === "" ? "" : (/^https?:\/\//i.test(e8) && /^\//.test(t5) && (e8 = e8.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t5) || /^data:.*,.*$/i.test(t5) || /^blob:.*$/i.test(t5) ? t5 : e8 + t5);
    }
  };
  (class extends ye {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(t5) {
      return super.copy(t5), this.instanceCount = t5.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t5 = super.toJSON(this);
      return t5.instanceCount = this.instanceCount, t5.isInstancedBufferGeometry = true, t5;
    }
  }).prototype.isInstancedBufferGeometry = true;
  var Io = class extends lo {
    constructor(t5) {
      super(t5), typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(t5) {
      return this.options = t5, this;
    }
    load(t5, e8, n8, i6) {
      t5 === void 0 && (t5 = ""), this.path !== void 0 && (t5 = this.path + t5), t5 = this.manager.resolveURL(t5);
      const r5 = this, s6 = ao.get(t5);
      if (s6 !== void 0)
        return r5.manager.itemStart(t5), setTimeout(function() {
          e8 && e8(s6), r5.manager.itemEnd(t5);
        }, 0), s6;
      const a4 = {};
      a4.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a4.headers = this.requestHeader, fetch(t5, a4).then(function(t6) {
        return t6.blob();
      }).then(function(t6) {
        return createImageBitmap(t6, Object.assign(r5.options, { colorSpaceConversion: "none" }));
      }).then(function(n9) {
        ao.add(t5, n9), e8 && e8(n9), r5.manager.itemEnd(t5);
      }).catch(function(e9) {
        i6 && i6(e9), r5.manager.itemError(t5), r5.manager.itemEnd(t5);
      }), r5.manager.itemStart(t5);
    }
  };
  var Oo;
  Io.prototype.isImageBitmapLoader = true;
  var No = function() {
    return Oo === void 0 && (Oo = new (window.AudioContext || window.webkitAudioContext)()), Oo;
  };
  var Fo = class extends lo {
    constructor(t5) {
      super(t5);
    }
    load(t5, e8, n8, i6) {
      const r5 = this, s6 = new co(this.manager);
      s6.setResponseType("arraybuffer"), s6.setPath(this.path), s6.setRequestHeader(this.requestHeader), s6.setWithCredentials(this.withCredentials), s6.load(t5, function(n9) {
        try {
          const t6 = n9.slice(0);
          No().decodeAudioData(t6, function(t7) {
            e8(t7);
          });
        } catch (e9) {
          i6 ? i6(e9) : console.error(e9), r5.manager.itemError(t5);
        }
      }, n8, i6);
    }
  };
  (class extends Po {
    constructor(t5, e8, n8 = 1) {
      super(void 0, n8);
      const i6 = new L2().set(t5), r5 = new L2().set(e8), s6 = new V2(i6.r, i6.g, i6.b), a4 = new V2(r5.r, r5.g, r5.b), o7 = Math.sqrt(Math.PI), l6 = o7 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(s6).add(a4).multiplyScalar(o7), this.sh.coefficients[1].copy(s6).sub(a4).multiplyScalar(l6);
    }
  }).prototype.isHemisphereLightProbe = true;
  (class extends Po {
    constructor(t5, e8 = 1) {
      super(void 0, e8);
      const n8 = new L2().set(t5);
      this.sh.coefficients[0].set(n8.r, n8.g, n8.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }).prototype.isAmbientLightProbe = true;
  var Uo = class {
    constructor(t5, e8, n8) {
      let i6, r5, s6;
      switch (this.binding = t5, this.valueSize = n8, e8) {
        case "quaternion":
          i6 = this._slerp, r5 = this._slerpAdditive, s6 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n8), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          i6 = this._select, r5 = this._select, s6 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n8);
          break;
        default:
          i6 = this._lerp, r5 = this._lerpAdditive, s6 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n8);
      }
      this._mixBufferRegion = i6, this._mixBufferRegionAdditive = r5, this._setIdentity = s6, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(t5, e8) {
      const n8 = this.buffer, i6 = this.valueSize, r5 = t5 * i6 + i6;
      let s6 = this.cumulativeWeight;
      if (s6 === 0) {
        for (let t6 = 0; t6 !== i6; ++t6)
          n8[r5 + t6] = n8[t6];
        s6 = e8;
      } else {
        s6 += e8;
        const t6 = e8 / s6;
        this._mixBufferRegion(n8, r5, 0, t6, i6);
      }
      this.cumulativeWeight = s6;
    }
    accumulateAdditive(t5) {
      const e8 = this.buffer, n8 = this.valueSize, i6 = n8 * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e8, i6, 0, t5, n8), this.cumulativeWeightAdditive += t5;
    }
    apply(t5) {
      const e8 = this.valueSize, n8 = this.buffer, i6 = t5 * e8 + e8, r5 = this.cumulativeWeight, s6 = this.cumulativeWeightAdditive, a4 = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r5 < 1) {
        const t6 = e8 * this._origIndex;
        this._mixBufferRegion(n8, i6, t6, 1 - r5, e8);
      }
      s6 > 0 && this._mixBufferRegionAdditive(n8, i6, this._addIndex * e8, 1, e8);
      for (let t6 = e8, r6 = e8 + e8; t6 !== r6; ++t6)
        if (n8[t6] !== n8[t6 + e8]) {
          a4.setValue(n8, i6);
          break;
        }
    }
    saveOriginalState() {
      const t5 = this.binding, e8 = this.buffer, n8 = this.valueSize, i6 = n8 * this._origIndex;
      t5.getValue(e8, i6);
      for (let t6 = n8, r5 = i6; t6 !== r5; ++t6)
        e8[t6] = e8[i6 + t6 % n8];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const t5 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t5);
    }
    _setAdditiveIdentityNumeric() {
      const t5 = this._addIndex * this.valueSize, e8 = t5 + this.valueSize;
      for (let n8 = t5; n8 < e8; n8++)
        this.buffer[n8] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const t5 = this._origIndex * this.valueSize, e8 = this._addIndex * this.valueSize;
      for (let n8 = 0; n8 < this.valueSize; n8++)
        this.buffer[e8 + n8] = this.buffer[t5 + n8];
    }
    _select(t5, e8, n8, i6, r5) {
      if (i6 >= 0.5)
        for (let i7 = 0; i7 !== r5; ++i7)
          t5[e8 + i7] = t5[n8 + i7];
    }
    _slerp(t5, e8, n8, i6) {
      H2.slerpFlat(t5, e8, t5, e8, t5, n8, i6);
    }
    _slerpAdditive(t5, e8, n8, i6, r5) {
      const s6 = this._workIndex * r5;
      H2.multiplyQuaternionsFlat(t5, s6, t5, e8, t5, n8), H2.slerpFlat(t5, e8, t5, e8, t5, s6, i6);
    }
    _lerp(t5, e8, n8, i6, r5) {
      const s6 = 1 - i6;
      for (let a4 = 0; a4 !== r5; ++a4) {
        const r6 = e8 + a4;
        t5[r6] = t5[r6] * s6 + t5[n8 + a4] * i6;
      }
    }
    _lerpAdditive(t5, e8, n8, i6, r5) {
      for (let s6 = 0; s6 !== r5; ++s6) {
        const r6 = e8 + s6;
        t5[r6] = t5[r6] + t5[n8 + s6] * i6;
      }
    }
  };
  var ko = new RegExp("[\\[\\]\\.:\\/]", "g");
  var Bo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]";
  var zo = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
  var Ho = /(WCOD+)?/.source.replace("WCOD", Bo);
  var Vo = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]");
  var Go = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]");
  var Wo = new RegExp("^" + zo + Ho + Vo + Go + "$");
  var jo = ["material", "materials", "bones"];
  var qo = class {
    constructor(t5, e8, n8) {
      this.path = e8, this.parsedPath = n8 || qo.parseTrackName(e8), this.node = qo.findNode(t5, this.parsedPath.nodeName) || t5, this.rootNode = t5, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(t5, e8, n8) {
      return t5 && t5.isAnimationObjectGroup ? new qo.Composite(t5, e8, n8) : new qo(t5, e8, n8);
    }
    static sanitizeNodeName(t5) {
      return t5.replace(/\s/g, "_").replace(ko, "");
    }
    static parseTrackName(t5) {
      const e8 = Wo.exec(t5);
      if (e8 === null)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t5);
      const n8 = { nodeName: e8[2], objectName: e8[3], objectIndex: e8[4], propertyName: e8[5], propertyIndex: e8[6] }, i6 = n8.nodeName && n8.nodeName.lastIndexOf(".");
      if (i6 !== void 0 && i6 !== -1) {
        const t6 = n8.nodeName.substring(i6 + 1);
        jo.indexOf(t6) !== -1 && (n8.nodeName = n8.nodeName.substring(0, i6), n8.objectName = t6);
      }
      if (n8.propertyName === null || n8.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t5);
      return n8;
    }
    static findNode(t5, e8) {
      if (e8 === void 0 || e8 === "" || e8 === "." || e8 === -1 || e8 === t5.name || e8 === t5.uuid)
        return t5;
      if (t5.skeleton) {
        const n8 = t5.skeleton.getBoneByName(e8);
        if (n8 !== void 0)
          return n8;
      }
      if (t5.children) {
        const n8 = function(t6) {
          for (let i7 = 0; i7 < t6.length; i7++) {
            const r5 = t6[i7];
            if (r5.name === e8 || r5.uuid === e8)
              return r5;
            const s6 = n8(r5.children);
            if (s6)
              return s6;
          }
          return null;
        }, i6 = n8(t5.children);
        if (i6)
          return i6;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(t5, e8) {
      t5[e8] = this.targetObject[this.propertyName];
    }
    _getValue_array(t5, e8) {
      const n8 = this.resolvedProperty;
      for (let i6 = 0, r5 = n8.length; i6 !== r5; ++i6)
        t5[e8++] = n8[i6];
    }
    _getValue_arrayElement(t5, e8) {
      t5[e8] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t5, e8) {
      this.resolvedProperty.toArray(t5, e8);
    }
    _setValue_direct(t5, e8) {
      this.targetObject[this.propertyName] = t5[e8];
    }
    _setValue_direct_setNeedsUpdate(t5, e8) {
      this.targetObject[this.propertyName] = t5[e8], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t5, e8) {
      this.targetObject[this.propertyName] = t5[e8], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(t5, e8) {
      const n8 = this.resolvedProperty;
      for (let i6 = 0, r5 = n8.length; i6 !== r5; ++i6)
        n8[i6] = t5[e8++];
    }
    _setValue_array_setNeedsUpdate(t5, e8) {
      const n8 = this.resolvedProperty;
      for (let i6 = 0, r5 = n8.length; i6 !== r5; ++i6)
        n8[i6] = t5[e8++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t5, e8) {
      const n8 = this.resolvedProperty;
      for (let i6 = 0, r5 = n8.length; i6 !== r5; ++i6)
        n8[i6] = t5[e8++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(t5, e8) {
      this.resolvedProperty[this.propertyIndex] = t5[e8];
    }
    _setValue_arrayElement_setNeedsUpdate(t5, e8) {
      this.resolvedProperty[this.propertyIndex] = t5[e8], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t5, e8) {
      this.resolvedProperty[this.propertyIndex] = t5[e8], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(t5, e8) {
      this.resolvedProperty.fromArray(t5, e8);
    }
    _setValue_fromArray_setNeedsUpdate(t5, e8) {
      this.resolvedProperty.fromArray(t5, e8), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t5, e8) {
      this.resolvedProperty.fromArray(t5, e8), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(t5, e8) {
      this.bind(), this.getValue(t5, e8);
    }
    _setValue_unbound(t5, e8) {
      this.bind(), this.setValue(t5, e8);
    }
    bind() {
      let t5 = this.node;
      const e8 = this.parsedPath, n8 = e8.objectName, i6 = e8.propertyName;
      let r5 = e8.propertyIndex;
      if (t5 || (t5 = qo.findNode(this.rootNode, e8.nodeName) || this.rootNode, this.node = t5), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t5)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (n8) {
        let i7 = e8.objectIndex;
        switch (n8) {
          case "materials":
            if (!t5.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t5.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t5 = t5.material.materials;
            break;
          case "bones":
            if (!t5.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t5 = t5.skeleton.bones;
            for (let e9 = 0; e9 < t5.length; e9++)
              if (t5[e9].name === i7) {
                i7 = e9;
                break;
              }
            break;
          default:
            if (t5[n8] === void 0)
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t5 = t5[n8];
        }
        if (i7 !== void 0) {
          if (t5[i7] === void 0)
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t5);
          t5 = t5[i7];
        }
      }
      const s6 = t5[i6];
      if (s6 === void 0) {
        const n9 = e8.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n9 + "." + i6 + " but it wasn't found.", t5);
      }
      let a4 = this.Versioning.None;
      this.targetObject = t5, t5.needsUpdate !== void 0 ? a4 = this.Versioning.NeedsUpdate : t5.matrixWorldNeedsUpdate !== void 0 && (a4 = this.Versioning.MatrixWorldNeedsUpdate);
      let o7 = this.BindingType.Direct;
      if (r5 !== void 0) {
        if (i6 === "morphTargetInfluences") {
          if (!t5.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t5.geometry.isBufferGeometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          if (!t5.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          t5.morphTargetDictionary[r5] !== void 0 && (r5 = t5.morphTargetDictionary[r5]);
        }
        o7 = this.BindingType.ArrayElement, this.resolvedProperty = s6, this.propertyIndex = r5;
      } else
        s6.fromArray !== void 0 && s6.toArray !== void 0 ? (o7 = this.BindingType.HasFromToArray, this.resolvedProperty = s6) : Array.isArray(s6) ? (o7 = this.BindingType.EntireArray, this.resolvedProperty = s6) : this.propertyName = i6;
      this.getValue = this.GetterByBindingType[o7], this.setValue = this.SetterByBindingTypeAndVersioning[o7][a4];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  };
  qo.Composite = class {
    constructor(t5, e8, n8) {
      const i6 = n8 || qo.parseTrackName(e8);
      this._targetGroup = t5, this._bindings = t5.subscribe_(e8, i6);
    }
    getValue(t5, e8) {
      this.bind();
      const n8 = this._targetGroup.nCachedObjects_, i6 = this._bindings[n8];
      i6 !== void 0 && i6.getValue(t5, e8);
    }
    setValue(t5, e8) {
      const n8 = this._bindings;
      for (let i6 = this._targetGroup.nCachedObjects_, r5 = n8.length; i6 !== r5; ++i6)
        n8[i6].setValue(t5, e8);
    }
    bind() {
      const t5 = this._bindings;
      for (let e8 = this._targetGroup.nCachedObjects_, n8 = t5.length; e8 !== n8; ++e8)
        t5[e8].bind();
    }
    unbind() {
      const t5 = this._bindings;
      for (let e8 = this._targetGroup.nCachedObjects_, n8 = t5.length; e8 !== n8; ++e8)
        t5[e8].unbind();
    }
  }, qo.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, qo.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, qo.prototype.GetterByBindingType = [qo.prototype._getValue_direct, qo.prototype._getValue_array, qo.prototype._getValue_arrayElement, qo.prototype._getValue_toArray], qo.prototype.SetterByBindingTypeAndVersioning = [[qo.prototype._setValue_direct, qo.prototype._setValue_direct_setNeedsUpdate, qo.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [qo.prototype._setValue_array, qo.prototype._setValue_array_setNeedsUpdate, qo.prototype._setValue_array_setMatrixWorldNeedsUpdate], [qo.prototype._setValue_arrayElement, qo.prototype._setValue_arrayElement_setNeedsUpdate, qo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [qo.prototype._setValue_fromArray, qo.prototype._setValue_fromArray_setNeedsUpdate, qo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  var Xo = class {
    constructor(t5, e8, n8 = null, i6 = e8.blendMode) {
      this._mixer = t5, this._clip = e8, this._localRoot = n8, this.blendMode = i6;
      const r5 = e8.tracks, s6 = r5.length, a4 = new Array(s6), o7 = { endingStart: 2400, endingEnd: 2400 };
      for (let t6 = 0; t6 !== s6; ++t6) {
        const e9 = r5[t6].createInterpolant(null);
        a4[t6] = e9, e9.settings = o7;
      }
      this._interpolantSettings = o7, this._interpolants = a4, this._propertyBindings = new Array(s6), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(t5) {
      return this._startTime = t5, this;
    }
    setLoop(t5, e8) {
      return this.loop = t5, this.repetitions = e8, this;
    }
    setEffectiveWeight(t5) {
      return this.weight = t5, this._effectiveWeight = this.enabled ? t5 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(t5) {
      return this._scheduleFading(t5, 0, 1);
    }
    fadeOut(t5) {
      return this._scheduleFading(t5, 1, 0);
    }
    crossFadeFrom(t5, e8, n8) {
      if (t5.fadeOut(e8), this.fadeIn(e8), n8) {
        const n9 = this._clip.duration, i6 = t5._clip.duration, r5 = i6 / n9, s6 = n9 / i6;
        t5.warp(1, r5, e8), this.warp(s6, 1, e8);
      }
      return this;
    }
    crossFadeTo(t5, e8, n8) {
      return t5.crossFadeFrom(this, e8, n8);
    }
    stopFading() {
      const t5 = this._weightInterpolant;
      return t5 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t5)), this;
    }
    setEffectiveTimeScale(t5) {
      return this.timeScale = t5, this._effectiveTimeScale = this.paused ? 0 : t5, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(t5) {
      return this.timeScale = this._clip.duration / t5, this.stopWarping();
    }
    syncWith(t5) {
      return this.time = t5.time, this.timeScale = t5.timeScale, this.stopWarping();
    }
    halt(t5) {
      return this.warp(this._effectiveTimeScale, 0, t5);
    }
    warp(t5, e8, n8) {
      const i6 = this._mixer, r5 = i6.time, s6 = this.timeScale;
      let a4 = this._timeScaleInterpolant;
      a4 === null && (a4 = i6._lendControlInterpolant(), this._timeScaleInterpolant = a4);
      const o7 = a4.parameterPositions, l6 = a4.sampleValues;
      return o7[0] = r5, o7[1] = r5 + n8, l6[0] = t5 / s6, l6[1] = e8 / s6, this;
    }
    stopWarping() {
      const t5 = this._timeScaleInterpolant;
      return t5 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t5)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(t5, e8, n8, i6) {
      if (!this.enabled)
        return void this._updateWeight(t5);
      const r5 = this._startTime;
      if (r5 !== null) {
        const i7 = (t5 - r5) * n8;
        if (i7 < 0 || n8 === 0)
          return;
        this._startTime = null, e8 = n8 * i7;
      }
      e8 *= this._updateTimeScale(t5);
      const s6 = this._updateTime(e8), a4 = this._updateWeight(t5);
      if (a4 > 0) {
        const t6 = this._interpolants, e9 = this._propertyBindings;
        if (this.blendMode === 2501)
          for (let n9 = 0, i7 = t6.length; n9 !== i7; ++n9)
            t6[n9].evaluate(s6), e9[n9].accumulateAdditive(a4);
        else
          for (let n9 = 0, r6 = t6.length; n9 !== r6; ++n9)
            t6[n9].evaluate(s6), e9[n9].accumulate(i6, a4);
      }
    }
    _updateWeight(t5) {
      let e8 = 0;
      if (this.enabled) {
        e8 = this.weight;
        const n8 = this._weightInterpolant;
        if (n8 !== null) {
          const i6 = n8.evaluate(t5)[0];
          e8 *= i6, t5 > n8.parameterPositions[1] && (this.stopFading(), i6 === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = e8, e8;
    }
    _updateTimeScale(t5) {
      let e8 = 0;
      if (!this.paused) {
        e8 = this.timeScale;
        const n8 = this._timeScaleInterpolant;
        if (n8 !== null) {
          e8 *= n8.evaluate(t5)[0], t5 > n8.parameterPositions[1] && (this.stopWarping(), e8 === 0 ? this.paused = true : this.timeScale = e8);
        }
      }
      return this._effectiveTimeScale = e8, e8;
    }
    _updateTime(t5) {
      const e8 = this._clip.duration, n8 = this.loop;
      let i6 = this.time + t5, r5 = this._loopCount;
      const s6 = n8 === 2202;
      if (t5 === 0)
        return r5 === -1 ? i6 : s6 && (1 & r5) == 1 ? e8 - i6 : i6;
      if (n8 === 2200) {
        r5 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        t: {
          if (i6 >= e8)
            i6 = e8;
          else {
            if (!(i6 < 0)) {
              this.time = i6;
              break t;
            }
            i6 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i6, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t5 < 0 ? -1 : 1 });
        }
      } else {
        if (r5 === -1 && (t5 >= 0 ? (r5 = 0, this._setEndings(true, this.repetitions === 0, s6)) : this._setEndings(this.repetitions === 0, true, s6)), i6 >= e8 || i6 < 0) {
          const n9 = Math.floor(i6 / e8);
          i6 -= e8 * n9, r5 += Math.abs(n9);
          const a4 = this.repetitions - r5;
          if (a4 <= 0)
            this.clampWhenFinished ? this.paused = true : this.enabled = false, i6 = t5 > 0 ? e8 : 0, this.time = i6, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t5 > 0 ? 1 : -1 });
          else {
            if (a4 === 1) {
              const e9 = t5 < 0;
              this._setEndings(e9, !e9, s6);
            } else
              this._setEndings(false, false, s6);
            this._loopCount = r5, this.time = i6, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n9 });
          }
        } else
          this.time = i6;
        if (s6 && (1 & r5) == 1)
          return e8 - i6;
      }
      return i6;
    }
    _setEndings(t5, e8, n8) {
      const i6 = this._interpolantSettings;
      n8 ? (i6.endingStart = 2401, i6.endingEnd = 2401) : (i6.endingStart = t5 ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i6.endingEnd = e8 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    }
    _scheduleFading(t5, e8, n8) {
      const i6 = this._mixer, r5 = i6.time;
      let s6 = this._weightInterpolant;
      s6 === null && (s6 = i6._lendControlInterpolant(), this._weightInterpolant = s6);
      const a4 = s6.parameterPositions, o7 = s6.sampleValues;
      return a4[0] = r5, o7[0] = e8, a4[1] = r5 + t5, o7[1] = n8, this;
    }
  };
  var $o = class extends i5 {
    constructor(t5) {
      super(), this._root = t5, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(t5, e8) {
      const n8 = t5._localRoot || this._root, i6 = t5._clip.tracks, r5 = i6.length, s6 = t5._propertyBindings, a4 = t5._interpolants, o7 = n8.uuid, l6 = this._bindingsByRootAndName;
      let h4 = l6[o7];
      h4 === void 0 && (h4 = {}, l6[o7] = h4);
      for (let t6 = 0; t6 !== r5; ++t6) {
        const r6 = i6[t6], l7 = r6.name;
        let c3 = h4[l7];
        if (c3 !== void 0)
          ++c3.referenceCount, s6[t6] = c3;
        else {
          if (c3 = s6[t6], c3 !== void 0) {
            c3._cacheIndex === null && (++c3.referenceCount, this._addInactiveBinding(c3, o7, l7));
            continue;
          }
          const i7 = e8 && e8._propertyBindings[t6].binding.parsedPath;
          c3 = new Uo(qo.create(n8, l7, i7), r6.ValueTypeName, r6.getValueSize()), ++c3.referenceCount, this._addInactiveBinding(c3, o7, l7), s6[t6] = c3;
        }
        a4[t6].resultBuffer = c3.buffer;
      }
    }
    _activateAction(t5) {
      if (!this._isActiveAction(t5)) {
        if (t5._cacheIndex === null) {
          const e9 = (t5._localRoot || this._root).uuid, n8 = t5._clip.uuid, i6 = this._actionsByClip[n8];
          this._bindAction(t5, i6 && i6.knownActions[0]), this._addInactiveAction(t5, n8, e9);
        }
        const e8 = t5._propertyBindings;
        for (let t6 = 0, n8 = e8.length; t6 !== n8; ++t6) {
          const n9 = e8[t6];
          n9.useCount++ == 0 && (this._lendBinding(n9), n9.saveOriginalState());
        }
        this._lendAction(t5);
      }
    }
    _deactivateAction(t5) {
      if (this._isActiveAction(t5)) {
        const e8 = t5._propertyBindings;
        for (let t6 = 0, n8 = e8.length; t6 !== n8; ++t6) {
          const n9 = e8[t6];
          --n9.useCount == 0 && (n9.restoreOriginalState(), this._takeBackBinding(n9));
        }
        this._takeBackAction(t5);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const t5 = this;
      this.stats = { actions: { get total() {
        return t5._actions.length;
      }, get inUse() {
        return t5._nActiveActions;
      } }, bindings: { get total() {
        return t5._bindings.length;
      }, get inUse() {
        return t5._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return t5._controlInterpolants.length;
      }, get inUse() {
        return t5._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(t5) {
      const e8 = t5._cacheIndex;
      return e8 !== null && e8 < this._nActiveActions;
    }
    _addInactiveAction(t5, e8, n8) {
      const i6 = this._actions, r5 = this._actionsByClip;
      let s6 = r5[e8];
      if (s6 === void 0)
        s6 = { knownActions: [t5], actionByRoot: {} }, t5._byClipCacheIndex = 0, r5[e8] = s6;
      else {
        const e9 = s6.knownActions;
        t5._byClipCacheIndex = e9.length, e9.push(t5);
      }
      t5._cacheIndex = i6.length, i6.push(t5), s6.actionByRoot[n8] = t5;
    }
    _removeInactiveAction(t5) {
      const e8 = this._actions, n8 = e8[e8.length - 1], i6 = t5._cacheIndex;
      n8._cacheIndex = i6, e8[i6] = n8, e8.pop(), t5._cacheIndex = null;
      const r5 = t5._clip.uuid, s6 = this._actionsByClip, a4 = s6[r5], o7 = a4.knownActions, l6 = o7[o7.length - 1], h4 = t5._byClipCacheIndex;
      l6._byClipCacheIndex = h4, o7[h4] = l6, o7.pop(), t5._byClipCacheIndex = null;
      delete a4.actionByRoot[(t5._localRoot || this._root).uuid], o7.length === 0 && delete s6[r5], this._removeInactiveBindingsForAction(t5);
    }
    _removeInactiveBindingsForAction(t5) {
      const e8 = t5._propertyBindings;
      for (let t6 = 0, n8 = e8.length; t6 !== n8; ++t6) {
        const n9 = e8[t6];
        --n9.referenceCount == 0 && this._removeInactiveBinding(n9);
      }
    }
    _lendAction(t5) {
      const e8 = this._actions, n8 = t5._cacheIndex, i6 = this._nActiveActions++, r5 = e8[i6];
      t5._cacheIndex = i6, e8[i6] = t5, r5._cacheIndex = n8, e8[n8] = r5;
    }
    _takeBackAction(t5) {
      const e8 = this._actions, n8 = t5._cacheIndex, i6 = --this._nActiveActions, r5 = e8[i6];
      t5._cacheIndex = i6, e8[i6] = t5, r5._cacheIndex = n8, e8[n8] = r5;
    }
    _addInactiveBinding(t5, e8, n8) {
      const i6 = this._bindingsByRootAndName, r5 = this._bindings;
      let s6 = i6[e8];
      s6 === void 0 && (s6 = {}, i6[e8] = s6), s6[n8] = t5, t5._cacheIndex = r5.length, r5.push(t5);
    }
    _removeInactiveBinding(t5) {
      const e8 = this._bindings, n8 = t5.binding, i6 = n8.rootNode.uuid, r5 = n8.path, s6 = this._bindingsByRootAndName, a4 = s6[i6], o7 = e8[e8.length - 1], l6 = t5._cacheIndex;
      o7._cacheIndex = l6, e8[l6] = o7, e8.pop(), delete a4[r5], Object.keys(a4).length === 0 && delete s6[i6];
    }
    _lendBinding(t5) {
      const e8 = this._bindings, n8 = t5._cacheIndex, i6 = this._nActiveBindings++, r5 = e8[i6];
      t5._cacheIndex = i6, e8[i6] = t5, r5._cacheIndex = n8, e8[n8] = r5;
    }
    _takeBackBinding(t5) {
      const e8 = this._bindings, n8 = t5._cacheIndex, i6 = --this._nActiveBindings, r5 = e8[i6];
      t5._cacheIndex = i6, e8[i6] = t5, r5._cacheIndex = n8, e8[n8] = r5;
    }
    _lendControlInterpolant() {
      const t5 = this._controlInterpolants, e8 = this._nActiveControlInterpolants++;
      let n8 = t5[e8];
      return n8 === void 0 && (n8 = new $a(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n8.__cacheIndex = e8, t5[e8] = n8), n8;
    }
    _takeBackControlInterpolant(t5) {
      const e8 = this._controlInterpolants, n8 = t5.__cacheIndex, i6 = --this._nActiveControlInterpolants, r5 = e8[i6];
      t5.__cacheIndex = i6, e8[i6] = t5, r5.__cacheIndex = n8, e8[n8] = r5;
    }
    clipAction(t5, e8, n8) {
      const i6 = e8 || this._root, r5 = i6.uuid;
      let s6 = typeof t5 == "string" ? ro.findByName(i6, t5) : t5;
      const a4 = s6 !== null ? s6.uuid : t5, o7 = this._actionsByClip[a4];
      let l6 = null;
      if (n8 === void 0 && (n8 = s6 !== null ? s6.blendMode : 2500), o7 !== void 0) {
        const t6 = o7.actionByRoot[r5];
        if (t6 !== void 0 && t6.blendMode === n8)
          return t6;
        l6 = o7.knownActions[0], s6 === null && (s6 = l6._clip);
      }
      if (s6 === null)
        return null;
      const h4 = new Xo(this, s6, e8, n8);
      return this._bindAction(h4, l6), this._addInactiveAction(h4, a4, r5), h4;
    }
    existingAction(t5, e8) {
      const n8 = e8 || this._root, i6 = n8.uuid, r5 = typeof t5 == "string" ? ro.findByName(n8, t5) : t5, s6 = r5 ? r5.uuid : t5, a4 = this._actionsByClip[s6];
      return a4 !== void 0 && a4.actionByRoot[i6] || null;
    }
    stopAllAction() {
      const t5 = this._actions;
      for (let e8 = this._nActiveActions - 1; e8 >= 0; --e8)
        t5[e8].stop();
      return this;
    }
    update(t5) {
      t5 *= this.timeScale;
      const e8 = this._actions, n8 = this._nActiveActions, i6 = this.time += t5, r5 = Math.sign(t5), s6 = this._accuIndex ^= 1;
      for (let a5 = 0; a5 !== n8; ++a5) {
        e8[a5]._update(i6, t5, r5, s6);
      }
      const a4 = this._bindings, o7 = this._nActiveBindings;
      for (let t6 = 0; t6 !== o7; ++t6)
        a4[t6].apply(s6);
      return this;
    }
    setTime(t5) {
      this.time = 0;
      for (let t6 = 0; t6 < this._actions.length; t6++)
        this._actions[t6].time = 0;
      return this.update(t5);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(t5) {
      const e8 = this._actions, n8 = t5.uuid, i6 = this._actionsByClip, r5 = i6[n8];
      if (r5 !== void 0) {
        const t6 = r5.knownActions;
        for (let n9 = 0, i7 = t6.length; n9 !== i7; ++n9) {
          const i8 = t6[n9];
          this._deactivateAction(i8);
          const r6 = i8._cacheIndex, s6 = e8[e8.length - 1];
          i8._cacheIndex = null, i8._byClipCacheIndex = null, s6._cacheIndex = r6, e8[r6] = s6, e8.pop(), this._removeInactiveBindingsForAction(i8);
        }
        delete i6[n8];
      }
    }
    uncacheRoot(t5) {
      const e8 = t5.uuid, n8 = this._actionsByClip;
      for (const t6 in n8) {
        const i7 = n8[t6].actionByRoot[e8];
        i7 !== void 0 && (this._deactivateAction(i7), this._removeInactiveAction(i7));
      }
      const i6 = this._bindingsByRootAndName[e8];
      if (i6 !== void 0)
        for (const t6 in i6) {
          const e9 = i6[t6];
          e9.restoreOriginalState(), this._removeInactiveBinding(e9);
        }
    }
    uncacheAction(t5, e8) {
      const n8 = this.existingAction(t5, e8);
      n8 !== null && (this._deactivateAction(n8), this._removeInactiveAction(n8));
    }
  };
  $o.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  (class extends Fr {
    constructor(t5, e8, n8 = 1) {
      super(t5, e8), this.meshPerAttribute = n8;
    }
    copy(t5) {
      return super.copy(t5), this.meshPerAttribute = t5.meshPerAttribute, this;
    }
    clone(t5) {
      const e8 = super.clone(t5);
      return e8.meshPerAttribute = this.meshPerAttribute, e8;
    }
    toJSON(t5) {
      const e8 = super.toJSON(t5);
      return e8.isInstancedInterleavedBuffer = true, e8.meshPerAttribute = this.meshPerAttribute, e8;
    }
  }).prototype.isInstancedInterleavedBuffer = true;
  function Yo(t5, e8) {
    return t5.distance - e8.distance;
  }
  function Jo(t5, e8, n8, i6) {
    if (t5.layers.test(e8.layers) && t5.raycast(e8, n8), i6 === true) {
      const i7 = t5.children;
      for (let t6 = 0, r5 = i7.length; t6 < r5; t6++)
        Jo(i7[t6], e8, n8, true);
    }
  }
  var Ko = class {
    constructor(t5 = 1, e8 = 0, n8 = 0) {
      return this.radius = t5, this.phi = e8, this.theta = n8, this;
    }
    set(t5, e8, n8) {
      return this.radius = t5, this.phi = e8, this.theta = n8, this;
    }
    copy(t5) {
      return this.radius = t5.radius, this.phi = t5.phi, this.theta = t5.theta, this;
    }
    makeSafe() {
      const t5 = 1e-6;
      return this.phi = Math.max(t5, Math.min(Math.PI - t5, this.phi)), this;
    }
    setFromVector3(t5) {
      return this.setFromCartesianCoords(t5.x, t5.y, t5.z);
    }
    setFromCartesianCoords(t5, e8, n8) {
      return this.radius = Math.sqrt(t5 * t5 + e8 * e8 + n8 * n8), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t5, n8), this.phi = Math.acos(h3(e8 / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Zo = new V2();
  var Qo = new xt();
  var tl = new xt();
  function el(t5) {
    const e8 = [];
    t5.isBone === true && e8.push(t5);
    for (let n8 = 0; n8 < t5.children.length; n8++)
      e8.push.apply(e8, el(t5.children[n8]));
    return e8;
  }
  var nl = class {
    static toHalfFloat(t5) {
      Math.abs(t5) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t5 = h3(t5, -65504, 65504), rl[0] = t5;
      const e8 = sl[0], n8 = e8 >> 23 & 511;
      return al[n8] + ((8388607 & e8) >> ol[n8]);
    }
    static fromHalfFloat(t5) {
      const e8 = t5 >> 10;
      return sl[0] = ll[cl[e8] + (1023 & t5)] + hl[e8], rl[0];
    }
  };
  var il = new ArrayBuffer(4);
  var rl = new Float32Array(il);
  var sl = new Uint32Array(il);
  var al = new Uint32Array(512);
  var ol = new Uint32Array(512);
  for (let t5 = 0; t5 < 256; ++t5) {
    const e8 = t5 - 127;
    e8 < -27 ? (al[t5] = 0, al[256 | t5] = 32768, ol[t5] = 24, ol[256 | t5] = 24) : e8 < -14 ? (al[t5] = 1024 >> -e8 - 14, al[256 | t5] = 1024 >> -e8 - 14 | 32768, ol[t5] = -e8 - 1, ol[256 | t5] = -e8 - 1) : e8 <= 15 ? (al[t5] = e8 + 15 << 10, al[256 | t5] = e8 + 15 << 10 | 32768, ol[t5] = 13, ol[256 | t5] = 13) : e8 < 128 ? (al[t5] = 31744, al[256 | t5] = 64512, ol[t5] = 24, ol[256 | t5] = 24) : (al[t5] = 31744, al[256 | t5] = 64512, ol[t5] = 13, ol[256 | t5] = 13);
  }
  var ll = new Uint32Array(2048);
  var hl = new Uint32Array(64);
  var cl = new Uint32Array(64);
  for (let t5 = 1; t5 < 1024; ++t5) {
    let e8 = t5 << 13, n8 = 0;
    for (; (8388608 & e8) == 0; )
      e8 <<= 1, n8 -= 8388608;
    e8 &= -8388609, n8 += 947912704, ll[t5] = e8 | n8;
  }
  for (let t5 = 1024; t5 < 2048; ++t5)
    ll[t5] = 939524096 + (t5 - 1024 << 13);
  for (let t5 = 1; t5 < 31; ++t5)
    hl[t5] = t5 << 23;
  hl[31] = 1199570944, hl[32] = 2147483648;
  for (let t5 = 33; t5 < 63; ++t5)
    hl[t5] = 2147483648 + (t5 - 32 << 23);
  hl[63] = 3347054592;
  for (let t5 = 1; t5 < 64; ++t5)
    t5 !== 32 && (cl[t5] = 1024);
  Ns.create = function(t5, e8) {
    return console.log("THREE.Curve.create() has been deprecated"), t5.prototype = Object.create(Ns.prototype), t5.prototype.constructor = t5, t5.prototype.getPoint = e8, t5;
  }, ea.prototype.fromPoints = function(t5) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t5);
  }, class extends Ts {
    constructor(t5 = 10, e8 = 10, n8 = 4473924, i6 = 8947848) {
      n8 = new L2(n8), i6 = new L2(i6);
      const r5 = e8 / 2, s6 = t5 / e8, a4 = t5 / 2, o7 = [], l6 = [];
      for (let t6 = 0, h5 = 0, c3 = -a4; t6 <= e8; t6++, c3 += s6) {
        o7.push(-a4, 0, c3, a4, 0, c3), o7.push(c3, 0, -a4, c3, 0, a4);
        const e9 = t6 === r5 ? n8 : i6;
        e9.toArray(l6, h5), h5 += 3, e9.toArray(l6, h5), h5 += 3, e9.toArray(l6, h5), h5 += 3, e9.toArray(l6, h5), h5 += 3;
      }
      const h4 = new ye();
      h4.setAttribute("position", new ce(o7, 3)), h4.setAttribute("color", new ce(l6, 3));
      super(h4, new gs({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
    }
  }.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  }, class extends Ts {
    constructor(t5) {
      const e8 = el(t5), n8 = new ye(), i6 = [], r5 = [], s6 = new L2(0, 0, 1), a4 = new L2(0, 1, 0);
      for (let t6 = 0; t6 < e8.length; t6++) {
        const n9 = e8[t6];
        n9.parent && n9.parent.isBone && (i6.push(0, 0, 0), i6.push(0, 0, 0), r5.push(s6.r, s6.g, s6.b), r5.push(a4.r, a4.g, a4.b));
      }
      n8.setAttribute("position", new ce(i6, 3)), n8.setAttribute("color", new ce(r5, 3));
      super(n8, new gs({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t5, this.bones = e8, this.matrix = t5.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(t5) {
      const e8 = this.bones, n8 = this.geometry, i6 = n8.getAttribute("position");
      tl.copy(this.root.matrixWorld).invert();
      for (let t6 = 0, n9 = 0; t6 < e8.length; t6++) {
        const r5 = e8[t6];
        r5.parent && r5.parent.isBone && (Qo.multiplyMatrices(tl, r5.matrixWorld), Zo.setFromMatrixPosition(Qo), i6.setXYZ(n9, Zo.x, Zo.y, Zo.z), Qo.multiplyMatrices(tl, r5.parent.matrixWorld), Zo.setFromMatrixPosition(Qo), i6.setXYZ(n9 + 1, Zo.x, Zo.y, Zo.z), n9 += 2);
      }
      n8.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t5);
    }
  }.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  }, lo.prototype.extractUrlBase = function(t5) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Do.extractUrlBase(t5);
  }, lo.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } }, j.prototype.center = function(t5) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t5);
  }, j.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, j.prototype.isIntersectionBox = function(t5) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t5);
  }, j.prototype.isIntersectionSphere = function(t5) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t5);
  }, j.prototype.size = function(t5) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t5);
  }, Ct.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }, ct.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, tn.prototype.setFromMatrix = function(t5) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t5);
  }, v2.prototype.flattenToArrayOffset = function(t5, e8) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t5, e8);
  }, v2.prototype.multiplyVector3 = function(t5) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t5.applyMatrix3(this);
  }, v2.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, v2.prototype.applyToBufferAttribute = function(t5) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t5.applyMatrix3(this);
  }, v2.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }, v2.prototype.getInverse = function(t5) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t5).invert();
  }, xt.prototype.extractPosition = function(t5) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t5);
  }, xt.prototype.flattenToArrayOffset = function(t5, e8) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t5, e8);
  }, xt.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new V2().setFromMatrixColumn(this, 3);
  }, xt.prototype.setRotationFromQuaternion = function(t5) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t5);
  }, xt.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, xt.prototype.multiplyVector3 = function(t5) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t5.applyMatrix4(this);
  }, xt.prototype.multiplyVector4 = function(t5) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t5.applyMatrix4(this);
  }, xt.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, xt.prototype.rotateAxis = function(t5) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t5.transformDirection(this);
  }, xt.prototype.crossVector = function(t5) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t5.applyMatrix4(this);
  }, xt.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, xt.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, xt.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, xt.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, xt.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, xt.prototype.applyToBufferAttribute = function(t5) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t5.applyMatrix4(this);
  }, xt.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, xt.prototype.makeFrustum = function(t5, e8, n8, i6, r5, s6) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t5, e8, i6, n8, r5, s6);
  }, xt.prototype.getInverse = function(t5) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t5).invert();
  }, Ke.prototype.isIntersectionLine = function(t5) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t5);
  }, H2.prototype.multiplyVector3 = function(t5) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t5.applyQuaternion(this);
  }, H2.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }, yt.prototype.isIntersectionBox = function(t5) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t5);
  }, yt.prototype.isIntersectionPlane = function(t5) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t5);
  }, yt.prototype.isIntersectionSphere = function(t5) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t5);
  }, ee.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  }, ee.prototype.barycoordFromPoint = function(t5, e8) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t5, e8);
  }, ee.prototype.midpoint = function(t5) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t5);
  }, ee.prototypenormal = function(t5) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t5);
  }, ee.prototype.plane = function(t5) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t5);
  }, ee.barycoordFromPoint = function(t5, e8, n8, i6, r5) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ee.getBarycoord(t5, e8, n8, i6, r5);
  }, ee.normal = function(t5, e8, n8, i6) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ee.getNormal(t5, e8, n8, i6);
  }, na.prototype.extractAllPoints = function(t5) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t5);
  }, na.prototype.extrude = function(t5) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pa(this, t5);
  }, na.prototype.makeGeometry = function(t5) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ia(this, t5);
  }, g2.prototype.fromAttribute = function(t5, e8, n8) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t5, e8, n8);
  }, g2.prototype.distanceToManhattan = function(t5) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t5);
  }, g2.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, V2.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, V2.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, V2.prototype.getPositionFromMatrix = function(t5) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t5);
  }, V2.prototype.getScaleFromMatrix = function(t5) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t5);
  }, V2.prototype.getColumnFromMatrix = function(t5, e8) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e8, t5);
  }, V2.prototype.applyProjection = function(t5) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t5);
  }, V2.prototype.fromAttribute = function(t5, e8, n8) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t5, e8, n8);
  }, V2.prototype.distanceToManhattan = function(t5) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t5);
  }, V2.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, U.prototype.fromAttribute = function(t5, e8, n8) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t5, e8, n8);
  }, U.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, Wt.prototype.getChildByName = function(t5) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t5);
  }, Wt.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, Wt.prototype.translate = function(t5, e8) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e8, t5);
  }, Wt.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, Wt.prototype.applyMatrix = function(t5) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t5);
  }, Object.defineProperties(Wt.prototype, { eulerOrder: { get: function() {
    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
  }, set: function(t5) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t5;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } }), Fe.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }, Object.defineProperties(Fe.prototype, { drawMode: { get: function() {
    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } }), ss.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }, We.prototype.setLens = function(t5, e8) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e8 !== void 0 && (this.filmGauge = e8), this.setFocalLength(t5);
  }, Object.defineProperties(go.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t5;
  } }, shadowCameraLeft: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t5;
  } }, shadowCameraRight: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t5;
  } }, shadowCameraTop: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t5;
  } }, shadowCameraBottom: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t5;
  } }, shadowCameraNear: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t5;
  } }, shadowCameraFar: { set: function(t5) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t5;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(t5) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t5;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(t5) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t5;
  } }, shadowMapHeight: { set: function(t5) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t5;
  } } }), Object.defineProperties(oe.prototype, { length: { get: function() {
    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
  } }, dynamic: { get: function() {
    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === 35048;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
  } } }), oe.prototype.setDynamic = function(t5) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t5 === true ? 35048 : 35044), this;
  }, oe.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, oe.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, ye.prototype.addIndex = function(t5) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t5);
  }, ye.prototype.addAttribute = function(t5, e8) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e8 && e8.isBufferAttribute || e8 && e8.isInterleavedBufferAttribute ? t5 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e8), this) : this.setAttribute(t5, e8) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t5, new oe(arguments[1], arguments[2])));
  }, ye.prototype.addDrawCall = function(t5, e8, n8) {
    n8 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t5, e8);
  }, ye.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  }, ye.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, ye.prototype.removeAttribute = function(t5) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t5);
  }, ye.prototype.applyMatrix = function(t5) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t5);
  }, Object.defineProperties(ye.prototype, { drawcalls: { get: function() {
    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
  } }, offsets: { get: function() {
    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
  } } }), Fr.prototype.setDynamic = function(t5) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t5 === true ? 35048 : 35044), this;
  }, Fr.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, Pa.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  }, Pa.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  }, Pa.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  }, Nr.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }, Object.defineProperties(ie.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    return console.warn("THREE.Material: .wrapRGB has been removed."), new L2();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(t5) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t5 === 1;
  } }, stencilMask: { get: function() {
    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
  }, set: function(t5) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t5;
  } }, vertexTangents: { get: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  }, set: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  } } }), Object.defineProperties(Ve.prototype, { derivatives: { get: function() {
    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
  }, set: function(t5) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t5;
  } } }), Or.prototype.clearTarget = function(t5, e8, n8, i6) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t5), this.clear(e8, n8, i6);
  }, Or.prototype.animate = function(t5) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t5);
  }, Or.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  }, Or.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  }, Or.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  }, Or.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  }, Or.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  }, Or.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  }, Or.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  }, Or.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, Or.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, Or.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  }, Or.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  }, Or.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  }, Or.prototype.enableScissorTest = function(t5) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t5);
  }, Or.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, Or.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, Or.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, Or.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, Or.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }, Or.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  }, Or.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  }, Or.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  }, Or.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }, Or.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }, Object.defineProperties(Or.prototype, { shadowMapEnabled: { get: function() {
    return this.shadowMap.enabled;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t5;
  } }, shadowMapType: { get: function() {
    return this.shadowMap.type;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t5;
  } }, shadowMapCullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  } }, context: { get: function() {
    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
  } }, vr: { get: function() {
    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
  } }, gammaInput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  } }, gammaOutput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t5 === true ? 3001 : 3e3;
  } }, toneMappingWhitePoint: { get: function() {
    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
  } }, gammaFactor: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
  } } }), Object.defineProperties(Mr.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  } }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } }), Object.defineProperties(k2.prototype, { wrapS: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t5;
  } }, wrapT: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t5;
  } }, magFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t5;
  } }, minFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t5;
  } }, anisotropy: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t5;
  } }, offset: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t5;
  } }, repeat: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t5;
  } }, format: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t5;
  } }, type: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t5;
  } }, generateMipmaps: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
  }, set: function(t5) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t5;
  } } }), class extends Wt {
    constructor(t5) {
      super(), this.type = "Audio", this.listener = t5, this.context = t5.context, this.gain = this.context.createGain(), this.gain.connect(t5.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(t5) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t5, this.connect(), this;
    }
    setMediaElementSource(t5) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t5), this.connect(), this;
    }
    setMediaStreamSource(t5) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t5), this.connect(), this;
    }
    setBuffer(t5) {
      return this.buffer = t5, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(t5 = 0) {
      if (this.isPlaying === true)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (this.hasPlaybackControl === false)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t5;
      const e8 = this.context.createBufferSource();
      return e8.buffer = this.buffer, e8.loop = this.loop, e8.loopStart = this.loopStart, e8.loopEnd = this.loopEnd, e8.onended = this.onEnded.bind(this), e8.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e8, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl !== false)
        return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (this.hasPlaybackControl !== false)
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t5 = 1, e8 = this.filters.length; t5 < e8; t5++)
          this.filters[t5 - 1].connect(this.filters[t5]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t5 = 1, e8 = this.filters.length; t5 < e8; t5++)
          this.filters[t5 - 1].disconnect(this.filters[t5]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(t5) {
      return t5 || (t5 = []), this._connected === true ? (this.disconnect(), this.filters = t5.slice(), this.connect()) : this.filters = t5.slice(), this;
    }
    setDetune(t5) {
      if (this.detune = t5, this.source.detune !== void 0)
        return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(t5) {
      return this.setFilters(t5 ? [t5] : []);
    }
    setPlaybackRate(t5) {
      if (this.hasPlaybackControl !== false)
        return this.playbackRate = t5, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(t5) {
      if (this.hasPlaybackControl !== false)
        return this.loop = t5, this.isPlaying === true && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(t5) {
      return this.loopStart = t5, this;
    }
    setLoopEnd(t5) {
      return this.loopEnd = t5, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(t5) {
      return this.gain.gain.setTargetAtTime(t5, this.context.currentTime, 0.01), this;
    }
  }.prototype.load = function(t5) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e8 = this;
    return new Fo().load(t5, function(t6) {
      e8.setBuffer(t6);
    }), this;
  }, je.prototype.updateCubeMap = function(t5, e8) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t5, e8);
  }, je.prototype.clear = function(t5, e8, n8, i6) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t5, e8, n8, i6);
  }, D.crossOrigin = void 0, D.loadTexture = function(t5, e8, n8, i6) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const r5 = new fo();
    r5.setCrossOrigin(this.crossOrigin);
    const s6 = r5.load(t5, n8, void 0, i6);
    return e8 && (s6.mapping = e8), s6;
  }, D.loadTextureCube = function(t5, e8, n8, i6) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const r5 = new po();
    r5.setCrossOrigin(this.crossOrigin);
    const s6 = r5.load(t5, n8, void 0, i6);
    return e8 && (s6.mapping = e8), s6;
  }, D.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, D.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "139" } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "139");
  var ul = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var dl = Symbol();
  var pl = /* @__PURE__ */ new Map();
  var ml = class {
    constructor(t5, e8) {
      if (this._$cssResult$ = true, e8 !== dl)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t5;
    }
    get styleSheet() {
      let t5 = pl.get(this.cssText);
      return ul && t5 === void 0 && (pl.set(this.cssText, t5 = new CSSStyleSheet()), t5.replaceSync(this.cssText)), t5;
    }
    toString() {
      return this.cssText;
    }
  };
  var fl = ul ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
    let e8 = "";
    for (const n8 of t6.cssRules)
      e8 += n8.cssText;
    return ((t7) => new ml(typeof t7 == "string" ? t7 : t7 + "", dl))(e8);
  })(t5) : t5;
  var gl;
  var vl = window.trustedTypes;
  var yl = vl ? vl.emptyScript : "";
  var xl = window.reactiveElementPolyfillSupport;
  var bl = { toAttribute(t5, e8) {
    switch (e8) {
      case Boolean:
        t5 = t5 ? yl : null;
        break;
      case Object:
      case Array:
        t5 = t5 == null ? t5 : JSON.stringify(t5);
    }
    return t5;
  }, fromAttribute(t5, e8) {
    let n8 = t5;
    switch (e8) {
      case Boolean:
        n8 = t5 !== null;
        break;
      case Number:
        n8 = t5 === null ? null : Number(t5);
        break;
      case Object:
      case Array:
        try {
          n8 = JSON.parse(t5);
        } catch (t6) {
          n8 = null;
        }
    }
    return n8;
  } };
  var _l = (t5, e8) => e8 !== t5 && (e8 == e8 || t5 == t5);
  var wl = { attribute: true, type: String, converter: bl, reflect: false, hasChanged: _l };
  var Ml = class extends HTMLElement {
    constructor() {
      super(), this._$Et = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$Ei = null, this.o();
    }
    static addInitializer(t5) {
      var e8;
      (e8 = this.l) !== null && e8 !== void 0 || (this.l = []), this.l.push(t5);
    }
    static get observedAttributes() {
      this.finalize();
      const t5 = [];
      return this.elementProperties.forEach((e8, n8) => {
        const i6 = this._$Eh(n8, e8);
        i6 !== void 0 && (this._$Eu.set(i6, n8), t5.push(i6));
      }), t5;
    }
    static createProperty(t5, e8 = wl) {
      if (e8.state && (e8.attribute = false), this.finalize(), this.elementProperties.set(t5, e8), !e8.noAccessor && !this.prototype.hasOwnProperty(t5)) {
        const n8 = typeof t5 == "symbol" ? Symbol() : "__" + t5, i6 = this.getPropertyDescriptor(t5, n8, e8);
        i6 !== void 0 && Object.defineProperty(this.prototype, t5, i6);
      }
    }
    static getPropertyDescriptor(t5, e8, n8) {
      return { get() {
        return this[e8];
      }, set(i6) {
        const r5 = this[t5];
        this[e8] = i6, this.requestUpdate(t5, r5, n8);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t5) {
      return this.elementProperties.get(t5) || wl;
    }
    static finalize() {
      if (this.hasOwnProperty("finalized"))
        return false;
      this.finalized = true;
      const t5 = Object.getPrototypeOf(this);
      if (t5.finalize(), this.elementProperties = new Map(t5.elementProperties), this._$Eu = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t6 = this.properties, e8 = [...Object.getOwnPropertyNames(t6), ...Object.getOwnPropertySymbols(t6)];
        for (const n8 of e8)
          this.createProperty(n8, t6[n8]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(t5) {
      const e8 = [];
      if (Array.isArray(t5)) {
        const n8 = new Set(t5.flat(1 / 0).reverse());
        for (const t6 of n8)
          e8.unshift(fl(t6));
      } else
        t5 !== void 0 && e8.push(fl(t5));
      return e8;
    }
    static _$Eh(t5, e8) {
      const n8 = e8.attribute;
      return n8 === false ? void 0 : typeof n8 == "string" ? n8 : typeof t5 == "string" ? t5.toLowerCase() : void 0;
    }
    o() {
      var t5;
      this._$Ep = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$Em(), this.requestUpdate(), (t5 = this.constructor.l) === null || t5 === void 0 || t5.forEach((t6) => t6(this));
    }
    addController(t5) {
      var e8, n8;
      ((e8 = this._$Eg) !== null && e8 !== void 0 ? e8 : this._$Eg = []).push(t5), this.renderRoot !== void 0 && this.isConnected && ((n8 = t5.hostConnected) === null || n8 === void 0 || n8.call(t5));
    }
    removeController(t5) {
      var e8;
      (e8 = this._$Eg) === null || e8 === void 0 || e8.splice(this._$Eg.indexOf(t5) >>> 0, 1);
    }
    _$Em() {
      this.constructor.elementProperties.forEach((t5, e8) => {
        this.hasOwnProperty(e8) && (this._$Et.set(e8, this[e8]), delete this[e8]);
      });
    }
    createRenderRoot() {
      var t5;
      const e8 = (t5 = this.shadowRoot) !== null && t5 !== void 0 ? t5 : this.attachShadow(this.constructor.shadowRootOptions);
      return ((t6, e9) => {
        ul ? t6.adoptedStyleSheets = e9.map((t7) => t7 instanceof CSSStyleSheet ? t7 : t7.styleSheet) : e9.forEach((e10) => {
          const n8 = document.createElement("style"), i6 = window.litNonce;
          i6 !== void 0 && n8.setAttribute("nonce", i6), n8.textContent = e10.cssText, t6.appendChild(n8);
        });
      })(e8, this.constructor.elementStyles), e8;
    }
    connectedCallback() {
      var t5;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
        var e8;
        return (e8 = t6.hostConnected) === null || e8 === void 0 ? void 0 : e8.call(t6);
      });
    }
    enableUpdating(t5) {
    }
    disconnectedCallback() {
      var t5;
      (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
        var e8;
        return (e8 = t6.hostDisconnected) === null || e8 === void 0 ? void 0 : e8.call(t6);
      });
    }
    attributeChangedCallback(t5, e8, n8) {
      this._$AK(t5, n8);
    }
    _$ES(t5, e8, n8 = wl) {
      var i6, r5;
      const s6 = this.constructor._$Eh(t5, n8);
      if (s6 !== void 0 && n8.reflect === true) {
        const a4 = ((r5 = (i6 = n8.converter) === null || i6 === void 0 ? void 0 : i6.toAttribute) !== null && r5 !== void 0 ? r5 : bl.toAttribute)(e8, n8.type);
        this._$Ei = t5, a4 == null ? this.removeAttribute(s6) : this.setAttribute(s6, a4), this._$Ei = null;
      }
    }
    _$AK(t5, e8) {
      var n8, i6, r5;
      const s6 = this.constructor, a4 = s6._$Eu.get(t5);
      if (a4 !== void 0 && this._$Ei !== a4) {
        const t6 = s6.getPropertyOptions(a4), o7 = t6.converter, l6 = (r5 = (i6 = (n8 = o7) === null || n8 === void 0 ? void 0 : n8.fromAttribute) !== null && i6 !== void 0 ? i6 : typeof o7 == "function" ? o7 : null) !== null && r5 !== void 0 ? r5 : bl.fromAttribute;
        this._$Ei = a4, this[a4] = l6(e8, t6.type), this._$Ei = null;
      }
    }
    requestUpdate(t5, e8, n8) {
      let i6 = true;
      t5 !== void 0 && (((n8 = n8 || this.constructor.getPropertyOptions(t5)).hasChanged || _l)(this[t5], e8) ? (this._$AL.has(t5) || this._$AL.set(t5, e8), n8.reflect === true && this._$Ei !== t5 && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t5, n8))) : i6 = false), !this.isUpdatePending && i6 && (this._$Ep = this._$E_());
    }
    async _$E_() {
      this.isUpdatePending = true;
      try {
        await this._$Ep;
      } catch (t6) {
        Promise.reject(t6);
      }
      const t5 = this.scheduleUpdate();
      return t5 != null && await t5, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t5;
      if (!this.isUpdatePending)
        return;
      this.hasUpdated, this._$Et && (this._$Et.forEach((t6, e9) => this[e9] = t6), this._$Et = void 0);
      let e8 = false;
      const n8 = this._$AL;
      try {
        e8 = this.shouldUpdate(n8), e8 ? (this.willUpdate(n8), (t5 = this._$Eg) === null || t5 === void 0 || t5.forEach((t6) => {
          var e9;
          return (e9 = t6.hostUpdate) === null || e9 === void 0 ? void 0 : e9.call(t6);
        }), this.update(n8)) : this._$EU();
      } catch (t6) {
        throw e8 = false, this._$EU(), t6;
      }
      e8 && this._$AE(n8);
    }
    willUpdate(t5) {
    }
    _$AE(t5) {
      var e8;
      (e8 = this._$Eg) === null || e8 === void 0 || e8.forEach((t6) => {
        var e9;
        return (e9 = t6.hostUpdated) === null || e9 === void 0 ? void 0 : e9.call(t6);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
    }
    _$EU() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$Ep;
    }
    shouldUpdate(t5) {
      return true;
    }
    update(t5) {
      this._$EC !== void 0 && (this._$EC.forEach((t6, e8) => this._$ES(e8, this[e8], t6)), this._$EC = void 0), this._$EU();
    }
    updated(t5) {
    }
    firstUpdated(t5) {
    }
  };
  var Sl;
  Ml.finalized = true, Ml.elementProperties = /* @__PURE__ */ new Map(), Ml.elementStyles = [], Ml.shadowRootOptions = { mode: "open" }, xl == null || xl({ ReactiveElement: Ml }), ((gl = globalThis.reactiveElementVersions) !== null && gl !== void 0 ? gl : globalThis.reactiveElementVersions = []).push("1.3.2");
  var Tl = globalThis.trustedTypes;
  var El = Tl ? Tl.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
  var Al = `lit$${(Math.random() + "").slice(9)}$`;
  var Rl = "?" + Al;
  var Cl = `<${Rl}>`;
  var Ll = document;
  var Pl = (t5 = "") => Ll.createComment(t5);
  var Dl = (t5) => t5 === null || typeof t5 != "object" && typeof t5 != "function";
  var Il = Array.isArray;
  var Ol = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var Nl = /-->/g;
  var Fl = />/g;
  var Ul = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g;
  var kl = /'/g;
  var Bl = /"/g;
  var zl = /^(?:script|style|textarea|title)$/i;
  var Hl = ((t5) => (e8, ...n8) => ({ _$litType$: t5, strings: e8, values: n8 }))(1);
  var Vl = Symbol.for("lit-noChange");
  var Gl = Symbol.for("lit-nothing");
  var Wl = /* @__PURE__ */ new WeakMap();
  var jl = (t5, e8, n8) => {
    var i6, r5;
    const s6 = (i6 = n8 == null ? void 0 : n8.renderBefore) !== null && i6 !== void 0 ? i6 : e8;
    let a4 = s6._$litPart$;
    if (a4 === void 0) {
      const t6 = (r5 = n8 == null ? void 0 : n8.renderBefore) !== null && r5 !== void 0 ? r5 : null;
      s6._$litPart$ = a4 = new Kl(e8.insertBefore(Pl(), t6), t6, void 0, n8 != null ? n8 : {});
    }
    return a4._$AI(t5), a4;
  };
  var ql = Ll.createTreeWalker(Ll, 129, null, false);
  var Xl = (t5, e8) => {
    const n8 = t5.length - 1, i6 = [];
    let r5, s6 = e8 === 2 ? "<svg>" : "", a4 = Ol;
    for (let e9 = 0; e9 < n8; e9++) {
      const n9 = t5[e9];
      let o8, l6, h4 = -1, c3 = 0;
      for (; c3 < n9.length && (a4.lastIndex = c3, l6 = a4.exec(n9), l6 !== null); )
        c3 = a4.lastIndex, a4 === Ol ? l6[1] === "!--" ? a4 = Nl : l6[1] !== void 0 ? a4 = Fl : l6[2] !== void 0 ? (zl.test(l6[2]) && (r5 = RegExp("</" + l6[2], "g")), a4 = Ul) : l6[3] !== void 0 && (a4 = Ul) : a4 === Ul ? l6[0] === ">" ? (a4 = r5 != null ? r5 : Ol, h4 = -1) : l6[1] === void 0 ? h4 = -2 : (h4 = a4.lastIndex - l6[2].length, o8 = l6[1], a4 = l6[3] === void 0 ? Ul : l6[3] === '"' ? Bl : kl) : a4 === Bl || a4 === kl ? a4 = Ul : a4 === Nl || a4 === Fl ? a4 = Ol : (a4 = Ul, r5 = void 0);
      const u3 = a4 === Ul && t5[e9 + 1].startsWith("/>") ? " " : "";
      s6 += a4 === Ol ? n9 + Cl : h4 >= 0 ? (i6.push(o8), n9.slice(0, h4) + "$lit$" + n9.slice(h4) + Al + u3) : n9 + Al + (h4 === -2 ? (i6.push(void 0), e9) : u3);
    }
    const o7 = s6 + (t5[n8] || "<?>") + (e8 === 2 ? "</svg>" : "");
    if (!Array.isArray(t5) || !t5.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return [El !== void 0 ? El.createHTML(o7) : o7, i6];
  };
  var $l = class {
    constructor({ strings: t5, _$litType$: e8 }, n8) {
      let i6;
      this.parts = [];
      let r5 = 0, s6 = 0;
      const a4 = t5.length - 1, o7 = this.parts, [l6, h4] = Xl(t5, e8);
      if (this.el = $l.createElement(l6, n8), ql.currentNode = this.el.content, e8 === 2) {
        const t6 = this.el.content, e9 = t6.firstChild;
        e9.remove(), t6.append(...e9.childNodes);
      }
      for (; (i6 = ql.nextNode()) !== null && o7.length < a4; ) {
        if (i6.nodeType === 1) {
          if (i6.hasAttributes()) {
            const t6 = [];
            for (const e9 of i6.getAttributeNames())
              if (e9.endsWith("$lit$") || e9.startsWith(Al)) {
                const n9 = h4[s6++];
                if (t6.push(e9), n9 !== void 0) {
                  const t7 = i6.getAttribute(n9.toLowerCase() + "$lit$").split(Al), e10 = /([.?@])?(.*)/.exec(n9);
                  o7.push({ type: 1, index: r5, name: e10[2], strings: t7, ctor: e10[1] === "." ? Ql : e10[1] === "?" ? eh : e10[1] === "@" ? nh : Zl });
                } else
                  o7.push({ type: 6, index: r5 });
              }
            for (const e9 of t6)
              i6.removeAttribute(e9);
          }
          if (zl.test(i6.tagName)) {
            const t6 = i6.textContent.split(Al), e9 = t6.length - 1;
            if (e9 > 0) {
              i6.textContent = Tl ? Tl.emptyScript : "";
              for (let n9 = 0; n9 < e9; n9++)
                i6.append(t6[n9], Pl()), ql.nextNode(), o7.push({ type: 2, index: ++r5 });
              i6.append(t6[e9], Pl());
            }
          }
        } else if (i6.nodeType === 8)
          if (i6.data === Rl)
            o7.push({ type: 2, index: r5 });
          else {
            let t6 = -1;
            for (; (t6 = i6.data.indexOf(Al, t6 + 1)) !== -1; )
              o7.push({ type: 7, index: r5 }), t6 += Al.length - 1;
          }
        r5++;
      }
    }
    static createElement(t5, e8) {
      const n8 = Ll.createElement("template");
      return n8.innerHTML = t5, n8;
    }
  };
  function Yl(t5, e8, n8 = t5, i6) {
    var r5, s6, a4, o7;
    if (e8 === Vl)
      return e8;
    let l6 = i6 !== void 0 ? (r5 = n8._$Cl) === null || r5 === void 0 ? void 0 : r5[i6] : n8._$Cu;
    const h4 = Dl(e8) ? void 0 : e8._$litDirective$;
    return (l6 == null ? void 0 : l6.constructor) !== h4 && ((s6 = l6 == null ? void 0 : l6._$AO) === null || s6 === void 0 || s6.call(l6, false), h4 === void 0 ? l6 = void 0 : (l6 = new h4(t5), l6._$AT(t5, n8, i6)), i6 !== void 0 ? ((a4 = (o7 = n8)._$Cl) !== null && a4 !== void 0 ? a4 : o7._$Cl = [])[i6] = l6 : n8._$Cu = l6), l6 !== void 0 && (e8 = Yl(t5, l6._$AS(t5, e8.values), l6, i6)), e8;
  }
  var Jl = class {
    constructor(t5, e8) {
      this.v = [], this._$AN = void 0, this._$AD = t5, this._$AM = e8;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    p(t5) {
      var e8;
      const { el: { content: n8 }, parts: i6 } = this._$AD, r5 = ((e8 = t5 == null ? void 0 : t5.creationScope) !== null && e8 !== void 0 ? e8 : Ll).importNode(n8, true);
      ql.currentNode = r5;
      let s6 = ql.nextNode(), a4 = 0, o7 = 0, l6 = i6[0];
      for (; l6 !== void 0; ) {
        if (a4 === l6.index) {
          let e9;
          l6.type === 2 ? e9 = new Kl(s6, s6.nextSibling, this, t5) : l6.type === 1 ? e9 = new l6.ctor(s6, l6.name, l6.strings, this, t5) : l6.type === 6 && (e9 = new ih(s6, this, t5)), this.v.push(e9), l6 = i6[++o7];
        }
        a4 !== (l6 == null ? void 0 : l6.index) && (s6 = ql.nextNode(), a4++);
      }
      return r5;
    }
    m(t5) {
      let e8 = 0;
      for (const n8 of this.v)
        n8 !== void 0 && (n8.strings !== void 0 ? (n8._$AI(t5, n8, e8), e8 += n8.strings.length - 2) : n8._$AI(t5[e8])), e8++;
    }
  };
  var Kl = class {
    constructor(t5, e8, n8, i6) {
      var r5;
      this.type = 2, this._$AH = Gl, this._$AN = void 0, this._$AA = t5, this._$AB = e8, this._$AM = n8, this.options = i6, this._$Cg = (r5 = i6 == null ? void 0 : i6.isConnected) === null || r5 === void 0 || r5;
    }
    get _$AU() {
      var t5, e8;
      return (e8 = (t5 = this._$AM) === null || t5 === void 0 ? void 0 : t5._$AU) !== null && e8 !== void 0 ? e8 : this._$Cg;
    }
    get parentNode() {
      let t5 = this._$AA.parentNode;
      const e8 = this._$AM;
      return e8 !== void 0 && t5.nodeType === 11 && (t5 = e8.parentNode), t5;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t5, e8 = this) {
      t5 = Yl(this, t5, e8), Dl(t5) ? t5 === Gl || t5 == null || t5 === "" ? (this._$AH !== Gl && this._$AR(), this._$AH = Gl) : t5 !== this._$AH && t5 !== Vl && this.$(t5) : t5._$litType$ !== void 0 ? this.T(t5) : t5.nodeType !== void 0 ? this.k(t5) : ((t6) => {
        var e9;
        return Il(t6) || typeof ((e9 = t6) === null || e9 === void 0 ? void 0 : e9[Symbol.iterator]) == "function";
      })(t5) ? this.S(t5) : this.$(t5);
    }
    M(t5, e8 = this._$AB) {
      return this._$AA.parentNode.insertBefore(t5, e8);
    }
    k(t5) {
      this._$AH !== t5 && (this._$AR(), this._$AH = this.M(t5));
    }
    $(t5) {
      this._$AH !== Gl && Dl(this._$AH) ? this._$AA.nextSibling.data = t5 : this.k(Ll.createTextNode(t5)), this._$AH = t5;
    }
    T(t5) {
      var e8;
      const { values: n8, _$litType$: i6 } = t5, r5 = typeof i6 == "number" ? this._$AC(t5) : (i6.el === void 0 && (i6.el = $l.createElement(i6.h, this.options)), i6);
      if (((e8 = this._$AH) === null || e8 === void 0 ? void 0 : e8._$AD) === r5)
        this._$AH.m(n8);
      else {
        const t6 = new Jl(r5, this), e9 = t6.p(this.options);
        t6.m(n8), this.k(e9), this._$AH = t6;
      }
    }
    _$AC(t5) {
      let e8 = Wl.get(t5.strings);
      return e8 === void 0 && Wl.set(t5.strings, e8 = new $l(t5)), e8;
    }
    S(t5) {
      Il(this._$AH) || (this._$AH = [], this._$AR());
      const e8 = this._$AH;
      let n8, i6 = 0;
      for (const r5 of t5)
        i6 === e8.length ? e8.push(n8 = new Kl(this.M(Pl()), this.M(Pl()), this, this.options)) : n8 = e8[i6], n8._$AI(r5), i6++;
      i6 < e8.length && (this._$AR(n8 && n8._$AB.nextSibling, i6), e8.length = i6);
    }
    _$AR(t5 = this._$AA.nextSibling, e8) {
      var n8;
      for ((n8 = this._$AP) === null || n8 === void 0 || n8.call(this, false, true, e8); t5 && t5 !== this._$AB; ) {
        const e9 = t5.nextSibling;
        t5.remove(), t5 = e9;
      }
    }
    setConnected(t5) {
      var e8;
      this._$AM === void 0 && (this._$Cg = t5, (e8 = this._$AP) === null || e8 === void 0 || e8.call(this, t5));
    }
  };
  var Zl = class {
    constructor(t5, e8, n8, i6, r5) {
      this.type = 1, this._$AH = Gl, this._$AN = void 0, this.element = t5, this.name = e8, this._$AM = i6, this.options = r5, n8.length > 2 || n8[0] !== "" || n8[1] !== "" ? (this._$AH = Array(n8.length - 1).fill(new String()), this.strings = n8) : this._$AH = Gl;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5, e8 = this, n8, i6) {
      const r5 = this.strings;
      let s6 = false;
      if (r5 === void 0)
        t5 = Yl(this, t5, e8, 0), s6 = !Dl(t5) || t5 !== this._$AH && t5 !== Vl, s6 && (this._$AH = t5);
      else {
        const i7 = t5;
        let a4, o7;
        for (t5 = r5[0], a4 = 0; a4 < r5.length - 1; a4++)
          o7 = Yl(this, i7[n8 + a4], e8, a4), o7 === Vl && (o7 = this._$AH[a4]), s6 || (s6 = !Dl(o7) || o7 !== this._$AH[a4]), o7 === Gl ? t5 = Gl : t5 !== Gl && (t5 += (o7 != null ? o7 : "") + r5[a4 + 1]), this._$AH[a4] = o7;
      }
      s6 && !i6 && this.C(t5);
    }
    C(t5) {
      t5 === Gl ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 != null ? t5 : "");
    }
  };
  var Ql = class extends Zl {
    constructor() {
      super(...arguments), this.type = 3;
    }
    C(t5) {
      this.element[this.name] = t5 === Gl ? void 0 : t5;
    }
  };
  var th = Tl ? Tl.emptyScript : "";
  var eh = class extends Zl {
    constructor() {
      super(...arguments), this.type = 4;
    }
    C(t5) {
      t5 && t5 !== Gl ? this.element.setAttribute(this.name, th) : this.element.removeAttribute(this.name);
    }
  };
  var nh = class extends Zl {
    constructor(t5, e8, n8, i6, r5) {
      super(t5, e8, n8, i6, r5), this.type = 5;
    }
    _$AI(t5, e8 = this) {
      var n8;
      if ((t5 = (n8 = Yl(this, t5, e8, 0)) !== null && n8 !== void 0 ? n8 : Gl) === Vl)
        return;
      const i6 = this._$AH, r5 = t5 === Gl && i6 !== Gl || t5.capture !== i6.capture || t5.once !== i6.once || t5.passive !== i6.passive, s6 = t5 !== Gl && (i6 === Gl || r5);
      r5 && this.element.removeEventListener(this.name, this, i6), s6 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
    }
    handleEvent(t5) {
      var e8, n8;
      typeof this._$AH == "function" ? this._$AH.call((n8 = (e8 = this.options) === null || e8 === void 0 ? void 0 : e8.host) !== null && n8 !== void 0 ? n8 : this.element, t5) : this._$AH.handleEvent(t5);
    }
  };
  var ih = class {
    constructor(t5, e8, n8) {
      this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = e8, this.options = n8;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5) {
      Yl(this, t5);
    }
  };
  var rh = window.litHtmlPolyfillSupport;
  var sh;
  var ah;
  rh == null || rh($l, Kl), ((Sl = globalThis.litHtmlVersions) !== null && Sl !== void 0 ? Sl : globalThis.litHtmlVersions = []).push("2.2.3");
  var oh = class extends Ml {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Dt = void 0;
    }
    createRenderRoot() {
      var t5, e8;
      const n8 = super.createRenderRoot();
      return (t5 = (e8 = this.renderOptions).renderBefore) !== null && t5 !== void 0 || (e8.renderBefore = n8.firstChild), n8;
    }
    update(t5) {
      const e8 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Dt = jl(e8, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t5;
      super.connectedCallback(), (t5 = this._$Dt) === null || t5 === void 0 || t5.setConnected(true);
    }
    disconnectedCallback() {
      var t5;
      super.disconnectedCallback(), (t5 = this._$Dt) === null || t5 === void 0 || t5.setConnected(false);
    }
    render() {
      return Vl;
    }
  };
  oh.finalized = true, oh._$litElement$ = true, (sh = globalThis.litElementHydrateSupport) === null || sh === void 0 || sh.call(globalThis, { LitElement: oh });
  var lh = globalThis.litElementPolyfillSupport;
  lh == null || lh({ LitElement: oh }), ((ah = globalThis.litElementVersions) !== null && ah !== void 0 ? ah : globalThis.litElementVersions = []).push("3.2.0");
  var hh = navigator.xr != null && self.XRSession != null && navigator.xr.isSessionSupported != null;
  var ch = hh && self.XRSession.prototype.requestHitTestSource;
  var uh = self.ResizeObserver != null;
  var dh = self.IntersectionObserver != null;
  var ph = ch;
  (() => {
    const t5 = navigator.userAgent || navigator.vendor || self.opera;
    let e8 = false;
    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t5) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t5.substr(0, 4))) && (e8 = true);
  })(), /\bCrOS\b/.test(navigator.userAgent);
  var mh = /android/i.test(navigator.userAgent);
  var fh = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  var gh = (() => {
    const t5 = document.createElement("a");
    return Boolean(t5.relList && t5.relList.supports && t5.relList.supports("ar"));
  })();
  /Safari\//.test(navigator.userAgent);
  var vh = /firefox/i.test(navigator.userAgent);
  var yh = /OculusBrowser/.test(navigator.userAgent);
  fh && /CriOS\//.test(navigator.userAgent);
  var xh = mh && !vh && !yh;
  var bh = Hl`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

/* NOTE: This ruleset is our integration surface area with the
 * :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196 */
:host([data-js-focus-visible]:focus:not(.focus-visible)),
:host([data-js-focus-visible]) :focus:not(.focus-visible) {
  outline: none;
}

.container {
  position: relative;
}

.userInput {
  width: 100%;
  height: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

canvas.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  opacity: 0;
  transition: opacity 0.3s 0.3s;
  background-color: inherit;
}

.slot.poster.show {
  opacity: 1;
  transition: none;
}

.slot.poster.quick {
  transition: none;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: var(--poster-color, #fff);
  background-image: var(--poster-image, none);
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--progress-mask, #fff);
  transition: opacity 0.3s;
  opacity: 0.2;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View in your space">
        ${Hl`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${Hl`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="mask" part="default-progress-mask"></div>
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${Hl`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`;
  var _h = /* @__PURE__ */ new WeakMap();
  function wh() {
    let t5, e8;
    function n8(t6, e9, n9, i6, r5, s6) {
      const a4 = s6.num_components(), o7 = n9.num_points() * a4, l6 = o7 * r5.BYTES_PER_ELEMENT, h4 = function(t7, e10) {
        switch (e10) {
          case Float32Array:
            return t7.DT_FLOAT32;
          case Int8Array:
            return t7.DT_INT8;
          case Int16Array:
            return t7.DT_INT16;
          case Int32Array:
            return t7.DT_INT32;
          case Uint8Array:
            return t7.DT_UINT8;
          case Uint16Array:
            return t7.DT_UINT16;
          case Uint32Array:
            return t7.DT_UINT32;
        }
      }(t6, r5), c3 = t6._malloc(l6);
      e9.GetAttributeDataArrayForAllPoints(n9, s6, h4, l6, c3);
      const u3 = new r5(t6.HEAPF32.buffer, c3, o7).slice();
      return t6._free(c3), { name: i6, array: u3, itemSize: a4 };
    }
    onmessage = function(i6) {
      const r5 = i6.data;
      switch (r5.type) {
        case "init":
          t5 = r5.decoderConfig, e8 = new Promise(function(e9) {
            t5.onModuleLoaded = function(t6) {
              e9({ draco: t6 });
            }, DracoDecoderModule(t5);
          });
          break;
        case "decode":
          const i7 = r5.buffer, s6 = r5.taskConfig;
          e8.then((t6) => {
            const e9 = t6.draco, a4 = new e9.Decoder(), o7 = new e9.DecoderBuffer();
            o7.Init(new Int8Array(i7), i7.byteLength);
            try {
              const t7 = function(t8, e10, i9, r6) {
                const s7 = r6.attributeIDs, a5 = r6.attributeTypes;
                let o8, l6;
                const h4 = e10.GetEncodedGeometryType(i9);
                if (h4 === t8.TRIANGULAR_MESH)
                  o8 = new t8.Mesh(), l6 = e10.DecodeBufferToMesh(i9, o8);
                else {
                  if (h4 !== t8.POINT_CLOUD)
                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                  o8 = new t8.PointCloud(), l6 = e10.DecodeBufferToPointCloud(i9, o8);
                }
                if (!l6.ok() || o8.ptr === 0)
                  throw new Error("THREE.DRACOLoader: Decoding failed: " + l6.error_msg());
                const c3 = { index: null, attributes: [] };
                for (const i10 in s7) {
                  const l7 = self[a5[i10]];
                  let h5, u3;
                  if (r6.useUniqueIDs)
                    u3 = s7[i10], h5 = e10.GetAttributeByUniqueId(o8, u3);
                  else {
                    if (u3 = e10.GetAttributeId(o8, t8[s7[i10]]), u3 === -1)
                      continue;
                    h5 = e10.GetAttribute(o8, u3);
                  }
                  c3.attributes.push(n8(t8, e10, o8, i10, l7, h5));
                }
                h4 === t8.TRIANGULAR_MESH && (c3.index = function(t9, e11, n9) {
                  const i10 = 3 * n9.num_faces(), r7 = 4 * i10, s8 = t9._malloc(r7);
                  e11.GetTrianglesUInt32Array(n9, r7, s8);
                  const a6 = new Uint32Array(t9.HEAPF32.buffer, s8, i10).slice();
                  return t9._free(s8), { array: a6, itemSize: 1 };
                }(t8, e10, o8));
                return t8.destroy(o8), c3;
              }(e9, a4, o7, s6), i8 = t7.attributes.map((t8) => t8.array.buffer);
              t7.index && i8.push(t7.index.array.buffer), self.postMessage({ type: "decode", id: r5.id, geometry: t7 }, i8);
            } catch (t7) {
              console.error(t7), self.postMessage({ type: "error", id: r5.id, error: t7.message });
            } finally {
              e9.destroy(o7), e9.destroy(a4);
            }
          });
      }
    };
  }
  var Mh = class extends lo {
    constructor(t5) {
      super(t5), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t6) {
        return new Rh(t6);
      }), this.register(function(t6) {
        return new Oh(t6);
      }), this.register(function(t6) {
        return new Nh(t6);
      }), this.register(function(t6) {
        return new Ch(t6);
      }), this.register(function(t6) {
        return new Lh(t6);
      }), this.register(function(t6) {
        return new Ph(t6);
      }), this.register(function(t6) {
        return new Dh(t6);
      }), this.register(function(t6) {
        return new Ih(t6);
      }), this.register(function(t6) {
        return new Eh(t6);
      }), this.register(function(t6) {
        return new Fh(t6);
      });
    }
    load(t5, e8, n8, i6) {
      const r5 = this;
      let s6;
      s6 = this.resourcePath !== "" ? this.resourcePath : this.path !== "" ? this.path : Do.extractUrlBase(t5), this.manager.itemStart(t5);
      const a4 = function(e9) {
        i6 ? i6(e9) : console.error(e9), r5.manager.itemError(t5), r5.manager.itemEnd(t5);
      }, o7 = new co(this.manager);
      o7.setPath(this.path), o7.setResponseType("arraybuffer"), o7.setRequestHeader(this.requestHeader), o7.setWithCredentials(this.withCredentials), o7.load(t5, function(n9) {
        try {
          r5.parse(n9, s6, function(n10) {
            e8(n10), r5.manager.itemEnd(t5);
          }, a4);
        } catch (t6) {
          a4(t6);
        }
      }, n8, a4);
    }
    setDRACOLoader(t5) {
      return this.dracoLoader = t5, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(t5) {
      return this.ktx2Loader = t5, this;
    }
    setMeshoptDecoder(t5) {
      return this.meshoptDecoder = t5, this;
    }
    register(t5) {
      return this.pluginCallbacks.indexOf(t5) === -1 && this.pluginCallbacks.push(t5), this;
    }
    unregister(t5) {
      return this.pluginCallbacks.indexOf(t5) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t5), 1), this;
    }
    parse(t5, e8, n8, i6) {
      let r5;
      const s6 = {}, a4 = {};
      if (typeof t5 == "string")
        r5 = t5;
      else {
        if (Do.decodeText(new Uint8Array(t5, 0, 4)) === Uh) {
          try {
            s6[Th.KHR_BINARY_GLTF] = new zh(t5);
          } catch (t6) {
            return void (i6 && i6(t6));
          }
          r5 = s6[Th.KHR_BINARY_GLTF].content;
        } else
          r5 = Do.decodeText(new Uint8Array(t5));
      }
      const o7 = JSON.parse(r5);
      if (o7.asset === void 0 || o7.asset.version[0] < 2)
        return void (i6 && i6(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const l6 = new xc(o7, { path: e8 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
      l6.fileLoader.setRequestHeader(this.requestHeader);
      for (let t6 = 0; t6 < this.pluginCallbacks.length; t6++) {
        const e9 = this.pluginCallbacks[t6](l6);
        a4[e9.name] = e9, s6[e9.name] = true;
      }
      if (o7.extensionsUsed)
        for (let t6 = 0; t6 < o7.extensionsUsed.length; ++t6) {
          const e9 = o7.extensionsUsed[t6], n9 = o7.extensionsRequired || [];
          switch (e9) {
            case Th.KHR_MATERIALS_UNLIT:
              s6[e9] = new Ah();
              break;
            case Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              s6[e9] = new Wh();
              break;
            case Th.KHR_DRACO_MESH_COMPRESSION:
              s6[e9] = new Hh(o7, this.dracoLoader);
              break;
            case Th.KHR_TEXTURE_TRANSFORM:
              s6[e9] = new Vh();
              break;
            case Th.KHR_MESH_QUANTIZATION:
              s6[e9] = new jh();
              break;
            default:
              n9.indexOf(e9) >= 0 && a4[e9] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + e9 + '".');
          }
        }
      l6.setExtensions(s6), l6.setPlugins(a4), l6.parse(n8, i6);
    }
    parseAsync(t5, e8) {
      const n8 = this;
      return new Promise(function(i6, r5) {
        n8.parse(t5, e8, i6, r5);
      });
    }
  };
  function Sh() {
    let t5 = {};
    return { get: function(e8) {
      return t5[e8];
    }, add: function(e8, n8) {
      t5[e8] = n8;
    }, remove: function(e8) {
      delete t5[e8];
    }, removeAll: function() {
      t5 = {};
    } };
  }
  var Th = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
  var Eh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      const t5 = this.parser, e8 = this.parser.json.nodes || [];
      for (let n8 = 0, i6 = e8.length; n8 < i6; n8++) {
        const i7 = e8[n8];
        i7.extensions && i7.extensions[this.name] && i7.extensions[this.name].light !== void 0 && t5._addNodeRef(this.cache, i7.extensions[this.name].light);
      }
    }
    _loadLight(t5) {
      const e8 = this.parser, n8 = "light:" + t5;
      let i6 = e8.cache.get(n8);
      if (i6)
        return i6;
      const r5 = e8.json, s6 = ((r5.extensions && r5.extensions[this.name] || {}).lights || [])[t5];
      let a4;
      const o7 = new L2(16777215);
      s6.color !== void 0 && o7.fromArray(s6.color);
      const l6 = s6.range !== void 0 ? s6.range : 0;
      switch (s6.type) {
        case "directional":
          a4 = new Co(o7), a4.target.position.set(0, 0, -1), a4.add(a4.target);
          break;
        case "point":
          a4 = new Ao(o7), a4.distance = l6;
          break;
        case "spot":
          a4 = new wo(o7), a4.distance = l6, s6.spot = s6.spot || {}, s6.spot.innerConeAngle = s6.spot.innerConeAngle !== void 0 ? s6.spot.innerConeAngle : 0, s6.spot.outerConeAngle = s6.spot.outerConeAngle !== void 0 ? s6.spot.outerConeAngle : Math.PI / 4, a4.angle = s6.spot.outerConeAngle, a4.penumbra = 1 - s6.spot.innerConeAngle / s6.spot.outerConeAngle, a4.target.position.set(0, 0, -1), a4.add(a4.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + s6.type);
      }
      return a4.position.set(0, 0, 0), a4.decay = 2, s6.intensity !== void 0 && (a4.intensity = s6.intensity), a4.name = e8.createUniqueName(s6.name || "light_" + t5), i6 = Promise.resolve(a4), e8.cache.add(n8, i6), i6;
    }
    createNodeAttachment(t5) {
      const e8 = this, n8 = this.parser, i6 = n8.json.nodes[t5], r5 = (i6.extensions && i6.extensions[this.name] || {}).light;
      return r5 === void 0 ? null : this._loadLight(r5).then(function(t6) {
        return n8._getNodeRef(e8.cache, r5, t6);
      });
    }
  };
  var Ah = class {
    constructor() {
      this.name = Th.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return re;
    }
    extendParams(t5, e8, n8) {
      const i6 = [];
      t5.color = new L2(1, 1, 1), t5.opacity = 1;
      const r5 = e8.pbrMetallicRoughness;
      if (r5) {
        if (Array.isArray(r5.baseColorFactor)) {
          const e9 = r5.baseColorFactor;
          t5.color.fromArray(e9), t5.opacity = e9[3];
        }
        r5.baseColorTexture !== void 0 && i6.push(n8.assignTexture(t5, "map", r5.baseColorTexture, 3001));
      }
      return Promise.all(i6);
    }
  };
  var Rh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser, i6 = n8.json.materials[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return Promise.resolve();
      const r5 = [], s6 = i6.extensions[this.name];
      if (s6.clearcoatFactor !== void 0 && (e8.clearcoat = s6.clearcoatFactor), s6.clearcoatTexture !== void 0 && r5.push(n8.assignTexture(e8, "clearcoatMap", s6.clearcoatTexture)), s6.clearcoatRoughnessFactor !== void 0 && (e8.clearcoatRoughness = s6.clearcoatRoughnessFactor), s6.clearcoatRoughnessTexture !== void 0 && r5.push(n8.assignTexture(e8, "clearcoatRoughnessMap", s6.clearcoatRoughnessTexture)), s6.clearcoatNormalTexture !== void 0 && (r5.push(n8.assignTexture(e8, "clearcoatNormalMap", s6.clearcoatNormalTexture)), s6.clearcoatNormalTexture.scale !== void 0)) {
        const t6 = s6.clearcoatNormalTexture.scale;
        e8.clearcoatNormalScale = new g2(t6, t6);
      }
      return Promise.all(r5);
    }
  };
  var Ch = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser, i6 = n8.json.materials[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return Promise.resolve();
      const r5 = [];
      e8.sheenColor = new L2(0, 0, 0), e8.sheenRoughness = 0, e8.sheen = 1;
      const s6 = i6.extensions[this.name];
      return s6.sheenColorFactor !== void 0 && e8.sheenColor.fromArray(s6.sheenColorFactor), s6.sheenRoughnessFactor !== void 0 && (e8.sheenRoughness = s6.sheenRoughnessFactor), s6.sheenColorTexture !== void 0 && r5.push(n8.assignTexture(e8, "sheenColorMap", s6.sheenColorTexture, 3001)), s6.sheenRoughnessTexture !== void 0 && r5.push(n8.assignTexture(e8, "sheenRoughnessMap", s6.sheenRoughnessTexture)), Promise.all(r5);
    }
  };
  var Lh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser, i6 = n8.json.materials[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return Promise.resolve();
      const r5 = [], s6 = i6.extensions[this.name];
      return s6.transmissionFactor !== void 0 && (e8.transmission = s6.transmissionFactor), s6.transmissionTexture !== void 0 && r5.push(n8.assignTexture(e8, "transmissionMap", s6.transmissionTexture)), Promise.all(r5);
    }
  };
  var Ph = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser, i6 = n8.json.materials[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return Promise.resolve();
      const r5 = [], s6 = i6.extensions[this.name];
      e8.thickness = s6.thicknessFactor !== void 0 ? s6.thicknessFactor : 0, s6.thicknessTexture !== void 0 && r5.push(n8.assignTexture(e8, "thicknessMap", s6.thicknessTexture)), e8.attenuationDistance = s6.attenuationDistance || 0;
      const a4 = s6.attenuationColor || [1, 1, 1];
      return e8.attenuationColor = new L2(a4[0], a4[1], a4[2]), Promise.all(r5);
    }
  };
  var Dh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_IOR;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser.json.materials[t5];
      if (!n8.extensions || !n8.extensions[this.name])
        return Promise.resolve();
      const i6 = n8.extensions[this.name];
      return e8.ior = i6.ior !== void 0 ? i6.ior : 1.5, Promise.resolve();
    }
  };
  var Ih = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(t5) {
      const e8 = this.parser.json.materials[t5];
      return e8.extensions && e8.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t5, e8) {
      const n8 = this.parser, i6 = n8.json.materials[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return Promise.resolve();
      const r5 = [], s6 = i6.extensions[this.name];
      e8.specularIntensity = s6.specularFactor !== void 0 ? s6.specularFactor : 1, s6.specularTexture !== void 0 && r5.push(n8.assignTexture(e8, "specularIntensityMap", s6.specularTexture));
      const a4 = s6.specularColorFactor || [1, 1, 1];
      return e8.specularColor = new L2(a4[0], a4[1], a4[2]), s6.specularColorTexture !== void 0 && r5.push(n8.assignTexture(e8, "specularColorMap", s6.specularColorTexture, 3001)), Promise.all(r5);
    }
  };
  var Oh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.KHR_TEXTURE_BASISU;
    }
    loadTexture(t5) {
      const e8 = this.parser, n8 = e8.json, i6 = n8.textures[t5];
      if (!i6.extensions || !i6.extensions[this.name])
        return null;
      const r5 = i6.extensions[this.name], s6 = e8.options.ktx2Loader;
      if (!s6) {
        if (n8.extensionsRequired && n8.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return e8.loadTextureImage(t5, r5.source, s6);
    }
  };
  var Nh = class {
    constructor(t5) {
      this.parser = t5, this.name = Th.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(t5) {
      const e8 = this.name, n8 = this.parser, i6 = n8.json, r5 = i6.textures[t5];
      if (!r5.extensions || !r5.extensions[e8])
        return null;
      const s6 = r5.extensions[e8], a4 = i6.images[s6.source];
      let o7 = n8.textureLoader;
      if (a4.uri) {
        const t6 = n8.options.manager.getHandler(a4.uri);
        t6 !== null && (o7 = t6);
      }
      return this.detectSupport().then(function(r6) {
        if (r6)
          return n8.loadTextureImage(t5, s6.source, o7);
        if (i6.extensionsRequired && i6.extensionsRequired.indexOf(e8) >= 0)
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n8.loadTexture(t5);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(t5) {
        const e8 = new Image();
        e8.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e8.onload = e8.onerror = function() {
          t5(e8.height === 1);
        };
      })), this.isSupported;
    }
  };
  var Fh = class {
    constructor(t5) {
      this.name = Th.EXT_MESHOPT_COMPRESSION, this.parser = t5;
    }
    loadBufferView(t5) {
      const e8 = this.parser.json, n8 = e8.bufferViews[t5];
      if (n8.extensions && n8.extensions[this.name]) {
        const t6 = n8.extensions[this.name], i6 = this.parser.getDependency("buffer", t6.buffer), r5 = this.parser.options.meshoptDecoder;
        if (!r5 || !r5.supported) {
          if (e8.extensionsRequired && e8.extensionsRequired.indexOf(this.name) >= 0)
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return Promise.all([i6, r5.ready]).then(function(e9) {
          const n9 = t6.byteOffset || 0, i7 = t6.byteLength || 0, s6 = t6.count, a4 = t6.byteStride, o7 = new ArrayBuffer(s6 * a4), l6 = new Uint8Array(e9[0], n9, i7);
          return r5.decodeGltfBuffer(new Uint8Array(o7), s6, a4, l6, t6.mode, t6.filter), o7;
        });
      }
      return null;
    }
  };
  var Uh = "glTF";
  var kh = 1313821514;
  var Bh = 5130562;
  var zh = class {
    constructor(t5) {
      this.name = Th.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const e8 = new DataView(t5, 0, 12);
      if (this.header = { magic: Do.decodeText(new Uint8Array(t5.slice(0, 4))), version: e8.getUint32(4, true), length: e8.getUint32(8, true) }, this.header.magic !== Uh)
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n8 = this.header.length - 12, i6 = new DataView(t5, 12);
      let r5 = 0;
      for (; r5 < n8; ) {
        const e9 = i6.getUint32(r5, true);
        r5 += 4;
        const n9 = i6.getUint32(r5, true);
        if (r5 += 4, n9 === kh) {
          const n10 = new Uint8Array(t5, 12 + r5, e9);
          this.content = Do.decodeText(n10);
        } else if (n9 === Bh) {
          const n10 = 12 + r5;
          this.body = t5.slice(n10, n10 + e9);
        }
        r5 += e9;
      }
      if (this.content === null)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  };
  var Hh = class {
    constructor(t5, e8) {
      if (!e8)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = Th.KHR_DRACO_MESH_COMPRESSION, this.json = t5, this.dracoLoader = e8, this.dracoLoader.preload();
    }
    decodePrimitive(t5, e8) {
      const n8 = this.json, i6 = this.dracoLoader, r5 = t5.extensions[this.name].bufferView, s6 = t5.extensions[this.name].attributes, a4 = {}, o7 = {}, l6 = {};
      for (const t6 in s6) {
        const e9 = ac[t6] || t6.toLowerCase();
        a4[e9] = s6[t6];
      }
      for (const e9 in t5.attributes) {
        const i7 = ac[e9] || e9.toLowerCase();
        if (s6[e9] !== void 0) {
          const r6 = n8.accessors[t5.attributes[e9]], s7 = nc[r6.componentType];
          l6[i7] = s7, o7[i7] = r6.normalized === true;
        }
      }
      return e8.getDependency("bufferView", r5).then(function(t6) {
        return new Promise(function(e9) {
          i6.decodeDracoFile(t6, function(t7) {
            for (const e10 in t7.attributes) {
              const n9 = t7.attributes[e10], i7 = o7[e10];
              i7 !== void 0 && (n9.normalized = i7);
            }
            e9(t7);
          }, a4, l6);
        });
      });
    }
  };
  var Vh = class {
    constructor() {
      this.name = Th.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t5, e8) {
      return e8.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e8.offset === void 0 && e8.rotation === void 0 && e8.scale === void 0 || (t5 = t5.clone(), e8.offset !== void 0 && t5.offset.fromArray(e8.offset), e8.rotation !== void 0 && (t5.rotation = e8.rotation), e8.scale !== void 0 && t5.repeat.fromArray(e8.scale), t5.needsUpdate = true), t5;
    }
  };
  var Gh = class extends Fa {
    constructor(t5) {
      super(), this.isGLTFSpecularGlossinessMaterial = true;
      const e8 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), n8 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), i6 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r5 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s6 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a4 = { specular: { value: new L2().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
      this._extraUniforms = a4, this.onBeforeCompile = function(t6) {
        for (const e9 in a4)
          t6.uniforms[e9] = a4[e9];
        t6.fragmentShader = t6.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e8).replace("#include <metalnessmap_pars_fragment>", n8).replace("#include <roughnessmap_fragment>", i6).replace("#include <metalnessmap_fragment>", r5).replace("#include <lights_physical_fragment>", s6);
      }, Object.defineProperties(this, { specular: { get: function() {
        return a4.specular.value;
      }, set: function(t6) {
        a4.specular.value = t6;
      } }, specularMap: { get: function() {
        return a4.specularMap.value;
      }, set: function(t6) {
        a4.specularMap.value = t6, t6 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
      } }, glossiness: { get: function() {
        return a4.glossiness.value;
      }, set: function(t6) {
        a4.glossiness.value = t6;
      } }, glossinessMap: { get: function() {
        return a4.glossinessMap.value;
      }, set: function(t6) {
        a4.glossinessMap.value = t6, t6 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
      } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t5);
    }
    copy(t5) {
      return super.copy(t5), this.specularMap = t5.specularMap, this.specular.copy(t5.specular), this.glossinessMap = t5.glossinessMap, this.glossiness = t5.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }
  };
  var Wh = class {
    constructor() {
      this.name = Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
    }
    getMaterialType() {
      return Gh;
    }
    extendParams(t5, e8, n8) {
      const i6 = e8.extensions[this.name];
      t5.color = new L2(1, 1, 1), t5.opacity = 1;
      const r5 = [];
      if (Array.isArray(i6.diffuseFactor)) {
        const e9 = i6.diffuseFactor;
        t5.color.fromArray(e9), t5.opacity = e9[3];
      }
      if (i6.diffuseTexture !== void 0 && r5.push(n8.assignTexture(t5, "map", i6.diffuseTexture, 3001)), t5.emissive = new L2(0, 0, 0), t5.glossiness = i6.glossinessFactor !== void 0 ? i6.glossinessFactor : 1, t5.specular = new L2(1, 1, 1), Array.isArray(i6.specularFactor) && t5.specular.fromArray(i6.specularFactor), i6.specularGlossinessTexture !== void 0) {
        const e9 = i6.specularGlossinessTexture;
        r5.push(n8.assignTexture(t5, "glossinessMap", e9)), r5.push(n8.assignTexture(t5, "specularMap", e9, 3001));
      }
      return Promise.all(r5);
    }
    createMaterial(t5) {
      const e8 = new Gh(t5);
      return e8.fog = true, e8.color = t5.color, e8.map = t5.map === void 0 ? null : t5.map, e8.lightMap = null, e8.lightMapIntensity = 1, e8.aoMap = t5.aoMap === void 0 ? null : t5.aoMap, e8.aoMapIntensity = 1, e8.emissive = t5.emissive, e8.emissiveIntensity = 1, e8.emissiveMap = t5.emissiveMap === void 0 ? null : t5.emissiveMap, e8.bumpMap = t5.bumpMap === void 0 ? null : t5.bumpMap, e8.bumpScale = 1, e8.normalMap = t5.normalMap === void 0 ? null : t5.normalMap, e8.normalMapType = 0, t5.normalScale && (e8.normalScale = t5.normalScale), e8.displacementMap = null, e8.displacementScale = 1, e8.displacementBias = 0, e8.specularMap = t5.specularMap === void 0 ? null : t5.specularMap, e8.specular = t5.specular, e8.glossinessMap = t5.glossinessMap === void 0 ? null : t5.glossinessMap, e8.glossiness = t5.glossiness, e8.alphaMap = null, e8.envMap = t5.envMap === void 0 ? null : t5.envMap, e8.envMapIntensity = 1, e8;
    }
  };
  var jh = class {
    constructor() {
      this.name = Th.KHR_MESH_QUANTIZATION;
    }
  };
  var qh = class extends qa {
    constructor(t5, e8, n8, i6) {
      super(t5, e8, n8, i6);
    }
    copySampleValue_(t5) {
      const e8 = this.resultBuffer, n8 = this.sampleValues, i6 = this.valueSize, r5 = t5 * i6 * 3 + i6;
      for (let t6 = 0; t6 !== i6; t6++)
        e8[t6] = n8[r5 + t6];
      return e8;
    }
  };
  qh.prototype.beforeStart_ = qh.prototype.copySampleValue_, qh.prototype.afterEnd_ = qh.prototype.copySampleValue_, qh.prototype.interpolate_ = function(t5, e8, n8, i6) {
    const r5 = this.resultBuffer, s6 = this.sampleValues, a4 = this.valueSize, o7 = 2 * a4, l6 = 3 * a4, h4 = i6 - e8, c3 = (n8 - e8) / h4, u3 = c3 * c3, d3 = u3 * c3, p3 = t5 * l6, m3 = p3 - l6, f3 = -2 * d3 + 3 * u3, g3 = d3 - u3, v3 = 1 - f3, y3 = g3 - u3 + c3;
    for (let t6 = 0; t6 !== a4; t6++) {
      const e9 = s6[m3 + t6 + a4], n9 = s6[m3 + t6 + o7] * h4, i7 = s6[p3 + t6 + a4], l7 = s6[p3 + t6] * h4;
      r5[t6] = v3 * e9 + y3 * n9 + f3 * i7 + g3 * l7;
    }
    return r5;
  };
  var Xh = new H2();
  var $h = class extends qh {
    interpolate_(t5, e8, n8, i6) {
      const r5 = super.interpolate_(t5, e8, n8, i6);
      return Xh.fromArray(r5).normalize().toArray(r5), r5;
    }
  };
  var Yh = 0;
  var Jh = 1;
  var Kh = 2;
  var Zh = 3;
  var Qh = 4;
  var tc = 5;
  var ec = 6;
  var nc = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
  var ic = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 };
  var rc = { 33071: 1001, 33648: 1002, 10497: 1e3 };
  var sc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
  var ac = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" };
  var oc = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" };
  var lc = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 };
  var hc = "OPAQUE";
  var cc = "MASK";
  var uc = "BLEND";
  function dc(t5) {
    return t5.DefaultMaterial === void 0 && (t5.DefaultMaterial = new Fa({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: 0 })), t5.DefaultMaterial;
  }
  function pc(t5, e8, n8) {
    for (const i6 in n8.extensions)
      t5[i6] === void 0 && (e8.userData.gltfExtensions = e8.userData.gltfExtensions || {}, e8.userData.gltfExtensions[i6] = n8.extensions[i6]);
  }
  function mc(t5, e8) {
    e8.extras !== void 0 && (typeof e8.extras == "object" ? Object.assign(t5.userData, e8.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e8.extras));
  }
  function fc(t5, e8) {
    if (t5.updateMorphTargets(), e8.weights !== void 0)
      for (let n8 = 0, i6 = e8.weights.length; n8 < i6; n8++)
        t5.morphTargetInfluences[n8] = e8.weights[n8];
    if (e8.extras && Array.isArray(e8.extras.targetNames)) {
      const n8 = e8.extras.targetNames;
      if (t5.morphTargetInfluences.length === n8.length) {
        t5.morphTargetDictionary = {};
        for (let e9 = 0, i6 = n8.length; e9 < i6; e9++)
          t5.morphTargetDictionary[n8[e9]] = e9;
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function gc(t5) {
    const e8 = t5.extensions && t5.extensions[Th.KHR_DRACO_MESH_COMPRESSION];
    let n8;
    return n8 = e8 ? "draco:" + e8.bufferView + ":" + e8.indices + ":" + vc(e8.attributes) : t5.indices + ":" + vc(t5.attributes) + ":" + t5.mode, n8;
  }
  function vc(t5) {
    let e8 = "";
    const n8 = Object.keys(t5).sort();
    for (let i6 = 0, r5 = n8.length; i6 < r5; i6++)
      e8 += n8[i6] + ":" + t5[n8[i6]] + ";";
    return e8;
  }
  function yc(t5) {
    switch (t5) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  var xc = class {
    constructor(t5 = {}, e8 = {}) {
      this.json = t5, this.extensions = {}, this.plugins = {}, this.options = e8, this.cache = new Sh(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}, typeof createImageBitmap != "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === false ? this.textureLoader = new Io(this.options.manager) : this.textureLoader = new fo(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new co(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(t5) {
      this.extensions = t5;
    }
    setPlugins(t5) {
      this.plugins = t5;
    }
    parse(t5, e8) {
      const n8 = this, i6 = this.json, r5 = this.extensions;
      this.cache.removeAll(), this._invokeAll(function(t6) {
        return t6._markDefs && t6._markDefs();
      }), Promise.all(this._invokeAll(function(t6) {
        return t6.beforeRoot && t6.beforeRoot();
      })).then(function() {
        return Promise.all([n8.getDependencies("scene"), n8.getDependencies("animation"), n8.getDependencies("camera")]);
      }).then(function(e9) {
        const s6 = { scene: e9[0][i6.scene || 0], scenes: e9[0], animations: e9[1], cameras: e9[2], asset: i6.asset, parser: n8, userData: {} };
        pc(r5, s6, i6), mc(s6, i6), Promise.all(n8._invokeAll(function(t6) {
          return t6.afterRoot && t6.afterRoot(s6);
        })).then(function() {
          t5(s6);
        });
      }).catch(e8);
    }
    _markDefs() {
      const t5 = this.json.nodes || [], e8 = this.json.skins || [], n8 = this.json.meshes || [];
      for (let n9 = 0, i6 = e8.length; n9 < i6; n9++) {
        const i7 = e8[n9].joints;
        for (let e9 = 0, n10 = i7.length; e9 < n10; e9++)
          t5[i7[e9]].isBone = true;
      }
      for (let e9 = 0, i6 = t5.length; e9 < i6; e9++) {
        const i7 = t5[e9];
        i7.mesh !== void 0 && (this._addNodeRef(this.meshCache, i7.mesh), i7.skin !== void 0 && (n8[i7.mesh].isSkinnedMesh = true)), i7.camera !== void 0 && this._addNodeRef(this.cameraCache, i7.camera);
      }
    }
    _addNodeRef(t5, e8) {
      e8 !== void 0 && (t5.refs[e8] === void 0 && (t5.refs[e8] = t5.uses[e8] = 0), t5.refs[e8]++);
    }
    _getNodeRef(t5, e8, n8) {
      if (t5.refs[e8] <= 1)
        return n8;
      const i6 = n8.clone(), r5 = (t6, e9) => {
        const n9 = this.associations.get(t6);
        n9 != null && this.associations.set(e9, n9);
        for (const [n10, i7] of t6.children.entries())
          r5(i7, e9.children[n10]);
      };
      return r5(n8, i6), i6.name += "_instance_" + t5.uses[e8]++, i6;
    }
    _invokeOne(t5) {
      const e8 = Object.values(this.plugins);
      e8.push(this);
      for (let n8 = 0; n8 < e8.length; n8++) {
        const i6 = t5(e8[n8]);
        if (i6)
          return i6;
      }
      return null;
    }
    _invokeAll(t5) {
      const e8 = Object.values(this.plugins);
      e8.unshift(this);
      const n8 = [];
      for (let i6 = 0; i6 < e8.length; i6++) {
        const r5 = t5(e8[i6]);
        r5 && n8.push(r5);
      }
      return n8;
    }
    getDependency(t5, e8) {
      const n8 = t5 + ":" + e8;
      let i6 = this.cache.get(n8);
      if (!i6) {
        switch (t5) {
          case "scene":
            i6 = this.loadScene(e8);
            break;
          case "node":
            i6 = this.loadNode(e8);
            break;
          case "mesh":
            i6 = this._invokeOne(function(t6) {
              return t6.loadMesh && t6.loadMesh(e8);
            });
            break;
          case "accessor":
            i6 = this.loadAccessor(e8);
            break;
          case "bufferView":
            i6 = this._invokeOne(function(t6) {
              return t6.loadBufferView && t6.loadBufferView(e8);
            });
            break;
          case "buffer":
            i6 = this.loadBuffer(e8);
            break;
          case "material":
            i6 = this._invokeOne(function(t6) {
              return t6.loadMaterial && t6.loadMaterial(e8);
            });
            break;
          case "texture":
            i6 = this._invokeOne(function(t6) {
              return t6.loadTexture && t6.loadTexture(e8);
            });
            break;
          case "skin":
            i6 = this.loadSkin(e8);
            break;
          case "animation":
            i6 = this.loadAnimation(e8);
            break;
          case "camera":
            i6 = this.loadCamera(e8);
            break;
          default:
            throw new Error("Unknown type: " + t5);
        }
        this.cache.add(n8, i6);
      }
      return i6;
    }
    getDependencies(t5) {
      let e8 = this.cache.get(t5);
      if (!e8) {
        const n8 = this, i6 = this.json[t5 + (t5 === "mesh" ? "es" : "s")] || [];
        e8 = Promise.all(i6.map(function(e9, i7) {
          return n8.getDependency(t5, i7);
        })), this.cache.add(t5, e8);
      }
      return e8;
    }
    loadBuffer(t5) {
      const e8 = this.json.buffers[t5], n8 = this.fileLoader;
      if (e8.type && e8.type !== "arraybuffer")
        throw new Error("THREE.GLTFLoader: " + e8.type + " buffer type is not supported.");
      if (e8.uri === void 0 && t5 === 0)
        return Promise.resolve(this.extensions[Th.KHR_BINARY_GLTF].body);
      const i6 = this.options;
      return new Promise(function(t6, r5) {
        n8.load(Do.resolveURL(e8.uri, i6.path), t6, void 0, function() {
          r5(new Error('THREE.GLTFLoader: Failed to load buffer "' + e8.uri + '".'));
        });
      });
    }
    loadBufferView(t5) {
      const e8 = this.json.bufferViews[t5];
      return this.getDependency("buffer", e8.buffer).then(function(t6) {
        const n8 = e8.byteLength || 0, i6 = e8.byteOffset || 0;
        return t6.slice(i6, i6 + n8);
      });
    }
    loadAccessor(t5) {
      const e8 = this, n8 = this.json, i6 = this.json.accessors[t5];
      if (i6.bufferView === void 0 && i6.sparse === void 0)
        return Promise.resolve(null);
      const r5 = [];
      return i6.bufferView !== void 0 ? r5.push(this.getDependency("bufferView", i6.bufferView)) : r5.push(null), i6.sparse !== void 0 && (r5.push(this.getDependency("bufferView", i6.sparse.indices.bufferView)), r5.push(this.getDependency("bufferView", i6.sparse.values.bufferView))), Promise.all(r5).then(function(t6) {
        const r6 = t6[0], s6 = sc[i6.type], a4 = nc[i6.componentType], o7 = a4.BYTES_PER_ELEMENT, l6 = o7 * s6, h4 = i6.byteOffset || 0, c3 = i6.bufferView !== void 0 ? n8.bufferViews[i6.bufferView].byteStride : void 0, u3 = i6.normalized === true;
        let d3, p3;
        if (c3 && c3 !== l6) {
          const t7 = Math.floor(h4 / c3), n9 = "InterleavedBuffer:" + i6.bufferView + ":" + i6.componentType + ":" + t7 + ":" + i6.count;
          let l7 = e8.cache.get(n9);
          l7 || (d3 = new a4(r6, t7 * c3, i6.count * c3 / o7), l7 = new Fr(d3, c3 / o7), e8.cache.add(n9, l7)), p3 = new kr(l7, s6, h4 % c3 / o7, u3);
        } else
          d3 = r6 === null ? new a4(i6.count * s6) : new a4(r6, h4, i6.count * s6), p3 = new oe(d3, s6, u3);
        if (i6.sparse !== void 0) {
          const e9 = sc.SCALAR, n9 = nc[i6.sparse.indices.componentType], o8 = i6.sparse.indices.byteOffset || 0, l7 = i6.sparse.values.byteOffset || 0, h5 = new n9(t6[1], o8, i6.sparse.count * e9), c4 = new a4(t6[2], l7, i6.sparse.count * s6);
          r6 !== null && (p3 = new oe(p3.array.slice(), p3.itemSize, p3.normalized));
          for (let t7 = 0, e10 = h5.length; t7 < e10; t7++) {
            const e11 = h5[t7];
            if (p3.setX(e11, c4[t7 * s6]), s6 >= 2 && p3.setY(e11, c4[t7 * s6 + 1]), s6 >= 3 && p3.setZ(e11, c4[t7 * s6 + 2]), s6 >= 4 && p3.setW(e11, c4[t7 * s6 + 3]), s6 >= 5)
              throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return p3;
      });
    }
    loadTexture(t5) {
      const e8 = this.json, n8 = this.options, i6 = e8.textures[t5].source, r5 = e8.images[i6];
      let s6 = this.textureLoader;
      if (r5.uri) {
        const t6 = n8.manager.getHandler(r5.uri);
        t6 !== null && (s6 = t6);
      }
      return this.loadTextureImage(t5, i6, s6);
    }
    loadTextureImage(t5, e8, n8) {
      const i6 = this, r5 = this.json, s6 = r5.textures[t5], a4 = r5.images[e8], o7 = (a4.uri || a4.bufferView) + ":" + s6.sampler;
      if (this.textureCache[o7])
        return this.textureCache[o7];
      const l6 = this.loadImageSource(e8, n8).then(function(e9) {
        e9.flipY = false, s6.name && (e9.name = s6.name);
        const n9 = (r5.samplers || {})[s6.sampler] || {};
        return e9.magFilter = ic[n9.magFilter] || 1006, e9.minFilter = ic[n9.minFilter] || 1008, e9.wrapS = rc[n9.wrapS] || 1e3, e9.wrapT = rc[n9.wrapT] || 1e3, i6.associations.set(e9, { textures: t5 }), e9;
      }).catch(function() {
        return null;
      });
      return this.textureCache[o7] = l6, l6;
    }
    loadImageSource(t5, e8) {
      const n8 = this, i6 = this.json, r5 = this.options;
      if (this.sourceCache[t5] !== void 0)
        return this.sourceCache[t5].then((t6) => t6.clone());
      const s6 = i6.images[t5], a4 = self.URL || self.webkitURL;
      let o7 = s6.uri || "", l6 = false;
      if (s6.bufferView !== void 0)
        o7 = n8.getDependency("bufferView", s6.bufferView).then(function(t6) {
          l6 = true;
          const e9 = new Blob([t6], { type: s6.mimeType });
          return o7 = a4.createObjectURL(e9), o7;
        });
      else if (s6.uri === void 0)
        throw new Error("THREE.GLTFLoader: Image " + t5 + " is missing URI and bufferView");
      const h4 = Promise.resolve(o7).then(function(t6) {
        return new Promise(function(n9, i7) {
          let s7 = n9;
          e8.isImageBitmapLoader === true && (s7 = function(t7) {
            const e9 = new F(t7);
            e9.needsUpdate = true, n9(e9);
          }), e8.load(Do.resolveURL(t6, r5.path), s7, void 0, i7);
        });
      }).then(function(t6) {
        var e9;
        return l6 === true && a4.revokeObjectURL(o7), t6.userData.mimeType = s6.mimeType || ((e9 = s6.uri).search(/\.jpe?g($|\?)/i) > 0 || e9.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : e9.search(/\.webp($|\?)/i) > 0 || e9.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"), t6;
      }).catch(function(t6) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", o7), t6;
      });
      return this.sourceCache[t5] = h4, h4;
    }
    assignTexture(t5, e8, n8, i6) {
      const r5 = this;
      return this.getDependency("texture", n8.index).then(function(s6) {
        if (n8.texCoord === void 0 || n8.texCoord == 0 || e8 === "aoMap" && n8.texCoord == 1 || console.warn("THREE.GLTFLoader: Custom UV set " + n8.texCoord + " for texture " + e8 + " not yet supported."), r5.extensions[Th.KHR_TEXTURE_TRANSFORM]) {
          const t6 = n8.extensions !== void 0 ? n8.extensions[Th.KHR_TEXTURE_TRANSFORM] : void 0;
          if (t6) {
            const e9 = r5.associations.get(s6);
            s6 = r5.extensions[Th.KHR_TEXTURE_TRANSFORM].extendTexture(s6, t6), r5.associations.set(s6, e9);
          }
        }
        return i6 !== void 0 && (s6.encoding = i6), t5[e8] = s6, s6;
      });
    }
    assignFinalMaterial(t5) {
      const e8 = t5.geometry;
      let n8 = t5.material;
      const i6 = e8.attributes.tangent === void 0, r5 = e8.attributes.color !== void 0, s6 = e8.attributes.normal === void 0;
      if (t5.isPoints) {
        const t6 = "PointsMaterial:" + n8.uuid;
        let e9 = this.cache.get(t6);
        e9 || (e9 = new As(), ie.prototype.copy.call(e9, n8), e9.color.copy(n8.color), e9.map = n8.map, e9.sizeAttenuation = false, this.cache.add(t6, e9)), n8 = e9;
      } else if (t5.isLine) {
        const t6 = "LineBasicMaterial:" + n8.uuid;
        let e9 = this.cache.get(t6);
        e9 || (e9 = new gs(), ie.prototype.copy.call(e9, n8), e9.color.copy(n8.color), this.cache.add(t6, e9)), n8 = e9;
      }
      if (i6 || r5 || s6) {
        let t6 = "ClonedMaterial:" + n8.uuid + ":";
        n8.isGLTFSpecularGlossinessMaterial && (t6 += "specular-glossiness:"), i6 && (t6 += "derivative-tangents:"), r5 && (t6 += "vertex-colors:"), s6 && (t6 += "flat-shading:");
        let e9 = this.cache.get(t6);
        e9 || (e9 = n8.clone(), r5 && (e9.vertexColors = true), s6 && (e9.flatShading = true), i6 && (e9.normalScale && (e9.normalScale.y *= -1), e9.clearcoatNormalScale && (e9.clearcoatNormalScale.y *= -1)), this.cache.add(t6, e9), this.associations.set(e9, this.associations.get(n8))), n8 = e9;
      }
      n8.aoMap && e8.attributes.uv2 === void 0 && e8.attributes.uv !== void 0 && e8.setAttribute("uv2", e8.attributes.uv), t5.material = n8;
    }
    getMaterialType() {
      return Fa;
    }
    loadMaterial(t5) {
      const e8 = this, n8 = this.json, i6 = this.extensions, r5 = n8.materials[t5];
      let s6;
      const a4 = {}, o7 = r5.extensions || {}, l6 = [];
      if (o7[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const t6 = i6[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        s6 = t6.getMaterialType(), l6.push(t6.extendParams(a4, r5, e8));
      } else if (o7[Th.KHR_MATERIALS_UNLIT]) {
        const t6 = i6[Th.KHR_MATERIALS_UNLIT];
        s6 = t6.getMaterialType(), l6.push(t6.extendParams(a4, r5, e8));
      } else {
        const n9 = r5.pbrMetallicRoughness || {};
        if (a4.color = new L2(1, 1, 1), a4.opacity = 1, Array.isArray(n9.baseColorFactor)) {
          const t6 = n9.baseColorFactor;
          a4.color.fromArray(t6), a4.opacity = t6[3];
        }
        n9.baseColorTexture !== void 0 && l6.push(e8.assignTexture(a4, "map", n9.baseColorTexture, 3001)), a4.metalness = n9.metallicFactor !== void 0 ? n9.metallicFactor : 1, a4.roughness = n9.roughnessFactor !== void 0 ? n9.roughnessFactor : 1, n9.metallicRoughnessTexture !== void 0 && (l6.push(e8.assignTexture(a4, "metalnessMap", n9.metallicRoughnessTexture)), l6.push(e8.assignTexture(a4, "roughnessMap", n9.metallicRoughnessTexture))), s6 = this._invokeOne(function(e9) {
          return e9.getMaterialType && e9.getMaterialType(t5);
        }), l6.push(Promise.all(this._invokeAll(function(e9) {
          return e9.extendMaterialParams && e9.extendMaterialParams(t5, a4);
        })));
      }
      r5.doubleSided === true && (a4.side = 2);
      const h4 = r5.alphaMode || hc;
      if (h4 === uc ? (a4.transparent = true, a4.depthWrite = false) : (a4.transparent = false, h4 === cc && (a4.alphaTest = r5.alphaCutoff !== void 0 ? r5.alphaCutoff : 0.5)), r5.normalTexture !== void 0 && s6 !== re && (l6.push(e8.assignTexture(a4, "normalMap", r5.normalTexture)), a4.normalScale = new g2(1, 1), r5.normalTexture.scale !== void 0)) {
        const t6 = r5.normalTexture.scale;
        a4.normalScale.set(t6, t6);
      }
      return r5.occlusionTexture !== void 0 && s6 !== re && (l6.push(e8.assignTexture(a4, "aoMap", r5.occlusionTexture)), r5.occlusionTexture.strength !== void 0 && (a4.aoMapIntensity = r5.occlusionTexture.strength)), r5.emissiveFactor !== void 0 && s6 !== re && (a4.emissive = new L2().fromArray(r5.emissiveFactor)), r5.emissiveTexture !== void 0 && s6 !== re && l6.push(e8.assignTexture(a4, "emissiveMap", r5.emissiveTexture, 3001)), Promise.all(l6).then(function() {
        let n9;
        return n9 = s6 === Gh ? i6[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a4) : new s6(a4), r5.name && (n9.name = r5.name), mc(n9, r5), e8.associations.set(n9, { materials: t5 }), r5.extensions && pc(i6, n9, r5), n9;
      });
    }
    createUniqueName(t5) {
      const e8 = qo.sanitizeNodeName(t5 || "");
      let n8 = e8;
      for (let t6 = 1; this.nodeNamesUsed[n8]; ++t6)
        n8 = e8 + "_" + t6;
      return this.nodeNamesUsed[n8] = true, n8;
    }
    loadGeometries(t5) {
      const e8 = this, n8 = this.extensions, i6 = this.primitiveCache;
      function r5(t6) {
        return n8[Th.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t6, e8).then(function(n9) {
          return _c(n9, t6, e8);
        });
      }
      const s6 = [];
      for (let n9 = 0, a4 = t5.length; n9 < a4; n9++) {
        const a5 = t5[n9], o7 = gc(a5), l6 = i6[o7];
        if (l6)
          s6.push(l6.promise);
        else {
          let t6;
          t6 = a5.extensions && a5.extensions[Th.KHR_DRACO_MESH_COMPRESSION] ? r5(a5) : _c(new ye(), a5, e8), i6[o7] = { primitive: a5, promise: t6 }, s6.push(t6);
        }
      }
      return Promise.all(s6);
    }
    loadMesh(t5) {
      const e8 = this, n8 = this.json, i6 = this.extensions, r5 = n8.meshes[t5], s6 = r5.primitives, a4 = [];
      for (let t6 = 0, e9 = s6.length; t6 < e9; t6++) {
        const e10 = s6[t6].material === void 0 ? dc(this.cache) : this.getDependency("material", s6[t6].material);
        a4.push(e10);
      }
      return a4.push(e8.loadGeometries(s6)), Promise.all(a4).then(function(n9) {
        const a5 = n9.slice(0, n9.length - 1), o7 = n9[n9.length - 1], l6 = [];
        for (let n10 = 0, h5 = o7.length; n10 < h5; n10++) {
          const h6 = o7[n10], c3 = s6[n10];
          let u3;
          const d3 = a5[n10];
          if (c3.mode === Qh || c3.mode === tc || c3.mode === ec || c3.mode === void 0)
            u3 = r5.isSkinnedMesh === true ? new ss(h6, d3) : new Fe(h6, d3), u3.isSkinnedMesh !== true || u3.geometry.attributes.skinWeight.normalized || u3.normalizeSkinWeights(), c3.mode === tc ? u3.geometry = wc(u3.geometry, 1) : c3.mode === ec && (u3.geometry = wc(u3.geometry, 2));
          else if (c3.mode === Jh)
            u3 = new Ts(h6, d3);
          else if (c3.mode === Zh)
            u3 = new ws(h6, d3);
          else if (c3.mode === Kh)
            u3 = new Es(h6, d3);
          else {
            if (c3.mode !== Yh)
              throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c3.mode);
            u3 = new Ds(h6, d3);
          }
          Object.keys(u3.geometry.morphAttributes).length > 0 && fc(u3, r5), u3.name = e8.createUniqueName(r5.name || "mesh_" + t5), mc(u3, r5), c3.extensions && pc(i6, u3, c3), e8.assignFinalMaterial(u3), l6.push(u3);
        }
        for (let n10 = 0, i7 = l6.length; n10 < i7; n10++)
          e8.associations.set(l6[n10], { meshes: t5, primitives: n10 });
        if (l6.length === 1)
          return l6[0];
        const h4 = new Rr();
        e8.associations.set(h4, { meshes: t5 });
        for (let t6 = 0, e9 = l6.length; t6 < e9; t6++)
          h4.add(l6[t6]);
        return h4;
      });
    }
    loadCamera(t5) {
      let e8;
      const n8 = this.json.cameras[t5], i6 = n8[n8.type];
      if (i6)
        return n8.type === "perspective" ? e8 = new We(f2.radToDeg(i6.yfov), i6.aspectRatio || 1, i6.znear || 1, i6.zfar || 2e6) : n8.type === "orthographic" && (e8 = new mn(-i6.xmag, i6.xmag, i6.ymag, -i6.ymag, i6.znear, i6.zfar)), n8.name && (e8.name = this.createUniqueName(n8.name)), mc(e8, n8), Promise.resolve(e8);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(t5) {
      const e8 = this.json.skins[t5], n8 = { joints: e8.joints };
      return e8.inverseBindMatrices === void 0 ? Promise.resolve(n8) : this.getDependency("accessor", e8.inverseBindMatrices).then(function(t6) {
        return n8.inverseBindMatrices = t6, n8;
      });
    }
    loadAnimation(t5) {
      const e8 = this.json.animations[t5], n8 = [], i6 = [], r5 = [], s6 = [], a4 = [];
      for (let t6 = 0, o7 = e8.channels.length; t6 < o7; t6++) {
        const o8 = e8.channels[t6], l6 = e8.samplers[o8.sampler], h4 = o8.target, c3 = h4.node !== void 0 ? h4.node : h4.id, u3 = e8.parameters !== void 0 ? e8.parameters[l6.input] : l6.input, d3 = e8.parameters !== void 0 ? e8.parameters[l6.output] : l6.output;
        n8.push(this.getDependency("node", c3)), i6.push(this.getDependency("accessor", u3)), r5.push(this.getDependency("accessor", d3)), s6.push(l6), a4.push(h4);
      }
      return Promise.all([Promise.all(n8), Promise.all(i6), Promise.all(r5), Promise.all(s6), Promise.all(a4)]).then(function(n9) {
        const i7 = n9[0], r6 = n9[1], s7 = n9[2], a5 = n9[3], o7 = n9[4], l6 = [];
        for (let t6 = 0, e9 = i7.length; t6 < e9; t6++) {
          const e10 = i7[t6], n10 = r6[t6], h5 = s7[t6], c3 = a5[t6], u3 = o7[t6];
          if (e10 === void 0)
            continue;
          let d3;
          switch (e10.updateMatrix(), e10.matrixAutoUpdate = true, oc[u3.path]) {
            case oc.weights:
              d3 = Qa;
              break;
            case oc.rotation:
              d3 = eo;
              break;
            default:
              d3 = io;
          }
          const p3 = e10.name ? e10.name : e10.uuid, m3 = c3.interpolation !== void 0 ? lc[c3.interpolation] : 2301, f3 = [];
          oc[u3.path] === oc.weights ? e10.traverse(function(t7) {
            t7.morphTargetInfluences && f3.push(t7.name ? t7.name : t7.uuid);
          }) : f3.push(p3);
          let g3 = h5.array;
          if (h5.normalized) {
            const t7 = yc(g3.constructor), e11 = new Float32Array(g3.length);
            for (let n11 = 0, i8 = g3.length; n11 < i8; n11++)
              e11[n11] = g3[n11] * t7;
            g3 = e11;
          }
          for (let t7 = 0, e11 = f3.length; t7 < e11; t7++) {
            const e12 = new d3(f3[t7] + "." + oc[u3.path], n10.array, g3, m3);
            c3.interpolation === "CUBICSPLINE" && (e12.createInterpolant = function(t8) {
              return new (this instanceof eo ? $h : qh)(this.times, this.values, this.getValueSize() / 3, t8);
            }, e12.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l6.push(e12);
          }
        }
        const h4 = e8.name ? e8.name : "animation_" + t5;
        return new ro(h4, void 0, l6);
      });
    }
    createNodeMesh(t5) {
      const e8 = this.json, n8 = this, i6 = e8.nodes[t5];
      return i6.mesh === void 0 ? null : n8.getDependency("mesh", i6.mesh).then(function(t6) {
        const e9 = n8._getNodeRef(n8.meshCache, i6.mesh, t6);
        return i6.weights !== void 0 && e9.traverse(function(t7) {
          if (t7.isMesh)
            for (let e10 = 0, n9 = i6.weights.length; e10 < n9; e10++)
              t7.morphTargetInfluences[e10] = i6.weights[e10];
        }), e9;
      });
    }
    loadNode(t5) {
      const e8 = this.json, n8 = this.extensions, i6 = this, r5 = e8.nodes[t5], s6 = r5.name ? i6.createUniqueName(r5.name) : "";
      return function() {
        const e9 = [], n9 = i6._invokeOne(function(e10) {
          return e10.createNodeMesh && e10.createNodeMesh(t5);
        });
        return n9 && e9.push(n9), r5.camera !== void 0 && e9.push(i6.getDependency("camera", r5.camera).then(function(t6) {
          return i6._getNodeRef(i6.cameraCache, r5.camera, t6);
        })), i6._invokeAll(function(e10) {
          return e10.createNodeAttachment && e10.createNodeAttachment(t5);
        }).forEach(function(t6) {
          e9.push(t6);
        }), Promise.all(e9);
      }().then(function(e9) {
        let a4;
        if (a4 = r5.isBone === true ? new as() : e9.length > 1 ? new Rr() : e9.length === 1 ? e9[0] : new Wt(), a4 !== e9[0])
          for (let t6 = 0, n9 = e9.length; t6 < n9; t6++)
            a4.add(e9[t6]);
        if (r5.name && (a4.userData.name = r5.name, a4.name = s6), mc(a4, r5), r5.extensions && pc(n8, a4, r5), r5.matrix !== void 0) {
          const t6 = new xt();
          t6.fromArray(r5.matrix), a4.applyMatrix4(t6);
        } else
          r5.translation !== void 0 && a4.position.fromArray(r5.translation), r5.rotation !== void 0 && a4.quaternion.fromArray(r5.rotation), r5.scale !== void 0 && a4.scale.fromArray(r5.scale);
        return i6.associations.has(a4) || i6.associations.set(a4, {}), i6.associations.get(a4).nodes = t5, a4;
      });
    }
    loadScene(t5) {
      const e8 = this.json, n8 = this.extensions, i6 = this.json.scenes[t5], r5 = this, s6 = new Rr();
      i6.name && (s6.name = r5.createUniqueName(i6.name)), mc(s6, i6), i6.extensions && pc(n8, s6, i6);
      const a4 = i6.nodes || [], o7 = [];
      for (let t6 = 0, n9 = a4.length; t6 < n9; t6++)
        o7.push(bc(a4[t6], s6, e8, r5));
      return Promise.all(o7).then(function() {
        return r5.associations = ((t6) => {
          const e9 = /* @__PURE__ */ new Map();
          for (const [t7, n9] of r5.associations)
            (t7 instanceof ie || t7 instanceof F) && e9.set(t7, n9);
          return t6.traverse((t7) => {
            const n9 = r5.associations.get(t7);
            n9 != null && e9.set(t7, n9);
          }), e9;
        })(s6), s6;
      });
    }
  };
  function bc(t5, e8, n8, i6) {
    const r5 = n8.nodes[t5];
    return i6.getDependency("node", t5).then(function(t6) {
      if (r5.skin === void 0)
        return t6;
      let e9;
      return i6.getDependency("skin", r5.skin).then(function(t7) {
        e9 = t7;
        const n9 = [];
        for (let t8 = 0, r6 = e9.joints.length; t8 < r6; t8++)
          n9.push(i6.getDependency("node", e9.joints[t8]));
        return Promise.all(n9);
      }).then(function(n9) {
        return t6.traverse(function(t7) {
          if (!t7.isMesh)
            return;
          const i7 = [], r6 = [];
          for (let t8 = 0, s6 = n9.length; t8 < s6; t8++) {
            const s7 = n9[t8];
            if (s7) {
              i7.push(s7);
              const n10 = new xt();
              e9.inverseBindMatrices !== void 0 && n10.fromArray(e9.inverseBindMatrices.array, 16 * t8), r6.push(n10);
            } else
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e9.joints[t8]);
          }
          t7.bind(new cs(i7, r6), t7.matrixWorld);
        }), t6;
      });
    }).then(function(t6) {
      e8.add(t6);
      const s6 = [];
      if (r5.children) {
        const e9 = r5.children;
        for (let r6 = 0, a4 = e9.length; r6 < a4; r6++) {
          const a5 = e9[r6];
          s6.push(bc(a5, t6, n8, i6));
        }
      }
      return Promise.all(s6);
    });
  }
  function _c(t5, e8, n8) {
    const i6 = e8.attributes, r5 = [];
    function s6(e9, i7) {
      return n8.getDependency("accessor", e9).then(function(e10) {
        t5.setAttribute(i7, e10);
      });
    }
    for (const e9 in i6) {
      const n9 = ac[e9] || e9.toLowerCase();
      n9 in t5.attributes || r5.push(s6(i6[e9], n9));
    }
    if (e8.indices !== void 0 && !t5.index) {
      const i7 = n8.getDependency("accessor", e8.indices).then(function(e9) {
        t5.setIndex(e9);
      });
      r5.push(i7);
    }
    return mc(t5, e8), function(t6, e9, n9) {
      const i7 = e9.attributes, r6 = new j();
      if (i7.POSITION === void 0)
        return;
      {
        const t7 = n9.json.accessors[i7.POSITION], e10 = t7.min, s8 = t7.max;
        if (e10 === void 0 || s8 === void 0)
          return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (r6.set(new V2(e10[0], e10[1], e10[2]), new V2(s8[0], s8[1], s8[2])), t7.normalized) {
          const e11 = yc(nc[t7.componentType]);
          r6.min.multiplyScalar(e11), r6.max.multiplyScalar(e11);
        }
      }
      const s7 = e9.targets;
      if (s7 !== void 0) {
        const t7 = new V2(), e10 = new V2();
        for (let i8 = 0, r7 = s7.length; i8 < r7; i8++) {
          const r8 = s7[i8];
          if (r8.POSITION !== void 0) {
            const i9 = n9.json.accessors[r8.POSITION], s8 = i9.min, a5 = i9.max;
            if (s8 !== void 0 && a5 !== void 0) {
              if (e10.setX(Math.max(Math.abs(s8[0]), Math.abs(a5[0]))), e10.setY(Math.max(Math.abs(s8[1]), Math.abs(a5[1]))), e10.setZ(Math.max(Math.abs(s8[2]), Math.abs(a5[2]))), i9.normalized) {
                const t8 = yc(nc[i9.componentType]);
                e10.multiplyScalar(t8);
              }
              t7.max(e10);
            } else
              console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
        r6.expandByVector(t7);
      }
      t6.boundingBox = r6;
      const a4 = new ct();
      r6.getCenter(a4.center), a4.radius = r6.min.distanceTo(r6.max) / 2, t6.boundingSphere = a4;
    }(t5, e8, n8), Promise.all(r5).then(function() {
      return e8.targets !== void 0 ? function(t6, e9, n9) {
        let i7 = false, r6 = false, s7 = false;
        for (let t7 = 0, n10 = e9.length; t7 < n10; t7++) {
          const n11 = e9[t7];
          if (n11.POSITION !== void 0 && (i7 = true), n11.NORMAL !== void 0 && (r6 = true), n11.COLOR_0 !== void 0 && (s7 = true), i7 && r6 && s7)
            break;
        }
        if (!i7 && !r6 && !s7)
          return Promise.resolve(t6);
        const a4 = [], o7 = [], l6 = [];
        for (let h4 = 0, c3 = e9.length; h4 < c3; h4++) {
          const c4 = e9[h4];
          if (i7) {
            const e10 = c4.POSITION !== void 0 ? n9.getDependency("accessor", c4.POSITION) : t6.attributes.position;
            a4.push(e10);
          }
          if (r6) {
            const e10 = c4.NORMAL !== void 0 ? n9.getDependency("accessor", c4.NORMAL) : t6.attributes.normal;
            o7.push(e10);
          }
          if (s7) {
            const e10 = c4.COLOR_0 !== void 0 ? n9.getDependency("accessor", c4.COLOR_0) : t6.attributes.color;
            l6.push(e10);
          }
        }
        return Promise.all([Promise.all(a4), Promise.all(o7), Promise.all(l6)]).then(function(e10) {
          const n10 = e10[0], a5 = e10[1], o8 = e10[2];
          return i7 && (t6.morphAttributes.position = n10), r6 && (t6.morphAttributes.normal = a5), s7 && (t6.morphAttributes.color = o8), t6.morphTargetsRelative = true, t6;
        });
      }(t5, e8.targets, n8) : t5;
    });
  }
  function wc(t5, e8) {
    let n8 = t5.getIndex();
    if (n8 === null) {
      const e9 = [], i7 = t5.getAttribute("position");
      if (i7 === void 0)
        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t5;
      for (let t6 = 0; t6 < i7.count; t6++)
        e9.push(t6);
      t5.setIndex(e9), n8 = t5.getIndex();
    }
    const i6 = n8.count - 2, r5 = [];
    if (e8 === 2)
      for (let t6 = 1; t6 <= i6; t6++)
        r5.push(n8.getX(0)), r5.push(n8.getX(t6)), r5.push(n8.getX(t6 + 1));
    else
      for (let t6 = 0; t6 < i6; t6++)
        t6 % 2 == 0 ? (r5.push(n8.getX(t6)), r5.push(n8.getX(t6 + 1)), r5.push(n8.getX(t6 + 2))) : (r5.push(n8.getX(t6 + 2)), r5.push(n8.getX(t6 + 1)), r5.push(n8.getX(t6)));
    r5.length / 3 !== i6 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s6 = t5.clone();
    return s6.setIndex(r5), s6;
  }
  var Mc = class {
    constructor(t5 = 4) {
      this.pool = t5, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }
    _initWorker(t5) {
      if (!this.workers[t5]) {
        const e8 = this.workerCreator();
        e8.addEventListener("message", this._onMessage.bind(this, t5)), this.workers[t5] = e8;
      }
    }
    _getIdleWorker() {
      for (let t5 = 0; t5 < this.pool; t5++)
        if (!(this.workerStatus & 1 << t5))
          return t5;
      return -1;
    }
    _onMessage(t5, e8) {
      const n8 = this.workersResolve[t5];
      if (n8 && n8(e8), this.queue.length) {
        const { resolve: e9, msg: n9, transfer: i6 } = this.queue.shift();
        this.workersResolve[t5] = e9, this.workers[t5].postMessage(n9, i6);
      } else
        this.workerStatus ^= 1 << t5;
    }
    setWorkerCreator(t5) {
      this.workerCreator = t5;
    }
    setWorkerLimit(t5) {
      this.pool = t5;
    }
    postMessage(t5, e8) {
      return new Promise((n8) => {
        const i6 = this._getIdleWorker();
        i6 !== -1 ? (this._initWorker(i6), this.workerStatus |= 1 << i6, this.workersResolve[i6] = n8, this.workers[i6].postMessage(t5, e8)) : this.queue.push({ resolve: n8, msg: t5, transfer: e8 });
      });
    }
    dispose() {
      this.workers.forEach((t5) => t5.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }
  };
  var Sc = /* @__PURE__ */ new WeakMap();
  var Tc = 0;
  var Ec = class extends lo {
    constructor(t5) {
      super(t5), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Mc(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER != "undefined" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
    setTranscoderPath(t5) {
      return this.transcoderPath = t5, this;
    }
    setWorkerLimit(t5) {
      return this.workerPool.setWorkerLimit(t5), this;
    }
    detectSupport(t5) {
      return this.workerConfig = { astcSupported: t5.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: t5.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: t5.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: t5.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: t5.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: t5.extensions.has("WEBGL_compressed_texture_pvrtc") || t5.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, t5.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false), this;
    }
    init() {
      if (!this.transcoderPending) {
        const t5 = new co(this.manager);
        t5.setPath(this.transcoderPath), t5.setWithCredentials(this.withCredentials);
        const e8 = t5.loadAsync("basis_transcoder.js"), n8 = new co(this.manager);
        n8.setPath(this.transcoderPath), n8.setResponseType("arraybuffer"), n8.setWithCredentials(this.withCredentials);
        const i6 = n8.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([e8, i6]).then(([t6, e9]) => {
          const n9 = Ec.BasisWorker.toString(), i7 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Ec.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Ec.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Ec.BasisFormat), "/* basis_transcoder.js */", t6, "/* worker */", n9.substring(n9.indexOf("{") + 1, n9.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([i7])), this.transcoderBinary = e9, this.workerPool.setWorkerCreator(() => {
            const t7 = new Worker(this.workerSourceURL), e10 = this.transcoderBinary.slice(0);
            return t7.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: e10 }, [e10]), t7;
          });
        }), Tc > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Tc++;
      }
      return this.transcoderPending;
    }
    load(t5, e8, n8, i6) {
      if (this.workerConfig === null)
        throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const r5 = new co(this.manager);
      r5.setResponseType("arraybuffer"), r5.setWithCredentials(this.withCredentials);
      const s6 = new Os();
      return r5.load(t5, (t6) => {
        if (Sc.has(t6)) {
          return Sc.get(t6).promise.then(e8).catch(i6);
        }
        this._createTexture([t6]).then(function(t7) {
          s6.copy(t7), s6.needsUpdate = true, e8 && e8(s6);
        }).catch(i6);
      }, n8, i6), s6;
    }
    _createTextureFrom(t5) {
      const { mipmaps: e8, width: n8, height: i6, format: r5, type: s6, error: a4, dfdTransferFn: o7, dfdFlags: l6 } = t5;
      if (s6 === "error")
        return Promise.reject(a4);
      const h4 = new Os(e8, n8, i6, r5, 1009);
      return h4.minFilter = e8.length === 1 ? 1006 : 1008, h4.magFilter = 1006, h4.generateMipmaps = false, h4.needsUpdate = true, h4.encoding = o7 === 2 ? 3001 : 3e3, h4.premultiplyAlpha = !!(1 & l6), h4;
    }
    _createTexture(t5, e8 = {}) {
      const n8 = e8, i6 = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffers: t5, taskConfig: n8 }, t5)).then((t6) => this._createTextureFrom(t6.data));
      return Sc.set(t5[0], { promise: i6 }), i6;
    }
    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Tc--, this;
    }
  };
  var Ac;
  var Rc;
  Ec.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, Ec.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, Ec.EngineFormat = { RGBAFormat: 1023, RGBA_ASTC_4x4_Format: 37808, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776 }, Ec.BasisWorker = function() {
    let t5, e8, n8;
    const i6 = _EngineFormat, r5 = _TranscoderFormat, s6 = _BasisFormat;
    self.addEventListener("message", function(a5) {
      const c3 = a5.data;
      switch (c3.type) {
        case "init":
          t5 = c3.config, u3 = c3.transcoderBinary, e8 = new Promise((t6) => {
            n8 = { wasmBinary: u3, onRuntimeInitialized: t6 }, BASIS(n8);
          }).then(() => {
            n8.initializeBasis(), n8.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
          break;
        case "transcode":
          e8.then(() => {
            try {
              const { width: e9, height: a6, hasAlpha: u4, mipmaps: d3, format: p3, dfdTransferFn: m3, dfdFlags: f3 } = function(e10) {
                const a7 = new n8.KTX2File(new Uint8Array(e10));
                function c4() {
                  a7.close(), a7.delete();
                }
                if (!a7.isValid())
                  throw c4(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                const u5 = a7.isUASTC() ? s6.UASTC_4x4 : s6.ETC1S, d4 = a7.getWidth(), p4 = a7.getHeight(), m4 = a7.getLevels(), f4 = a7.getHasAlpha(), g4 = a7.getDFDTransferFunc(), v3 = a7.getDFDFlags(), { transcoderFormat: y3, engineFormat: x3 } = function(e11, n9, a8, c5) {
                  let u6, d5;
                  const p5 = e11 === s6.ETC1S ? o7 : l6;
                  for (let i7 = 0; i7 < p5.length; i7++) {
                    const r6 = p5[i7];
                    if (t5[r6.if] && (r6.basisFormat.includes(e11) && !(c5 && r6.transcoderFormat.length < 2) && (!r6.needsPowerOfTwo || h4(n9) && h4(a8))))
                      return u6 = r6.transcoderFormat[c5 ? 1 : 0], d5 = r6.engineFormat[c5 ? 1 : 0], { transcoderFormat: u6, engineFormat: d5 };
                  }
                  return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u6 = r5.RGBA32, d5 = i6.RGBAFormat, { transcoderFormat: u6, engineFormat: d5 };
                }(u5, d4, p4, f4);
                if (!d4 || !p4 || !m4)
                  throw c4(), new Error("THREE.KTX2Loader:	Invalid texture");
                if (!a7.startTranscoding())
                  throw c4(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                const b3 = [];
                for (let t6 = 0; t6 < m4; t6++) {
                  const e11 = a7.getImageLevelInfo(t6, 0, 0), n9 = e11.origWidth, i7 = e11.origHeight, r6 = new Uint8Array(a7.getImageTranscodedSizeInBytes(t6, 0, 0, y3));
                  if (!a7.transcodeImage(r6, t6, 0, 0, y3, 0, -1, -1))
                    throw c4(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                  b3.push({ data: r6, width: n9, height: i7 });
                }
                return c4(), { width: d4, height: p4, hasAlpha: f4, mipmaps: b3, format: x3, dfdTransferFn: g4, dfdFlags: v3 };
              }(c3.buffers[0]), g3 = [];
              for (let t6 = 0; t6 < d3.length; ++t6)
                g3.push(d3[t6].data.buffer);
              self.postMessage({ type: "transcode", id: c3.id, width: e9, height: a6, hasAlpha: u4, mipmaps: d3, format: p3, dfdTransferFn: m3, dfdFlags: f3 }, g3);
            } catch (t6) {
              console.error(t6), self.postMessage({ type: "error", id: c3.id, error: t6.message });
            }
          });
      }
      var u3;
    });
    const a4 = [{ if: "astcSupported", basisFormat: [s6.UASTC_4x4], transcoderFormat: [r5.ASTC_4x4, r5.ASTC_4x4], engineFormat: [i6.RGBA_ASTC_4x4_Format, i6.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: false }, { if: "bptcSupported", basisFormat: [s6.ETC1S, s6.UASTC_4x4], transcoderFormat: [r5.BC7_M5, r5.BC7_M5], engineFormat: [i6.RGBA_BPTC_Format, i6.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false }, { if: "dxtSupported", basisFormat: [s6.ETC1S, s6.UASTC_4x4], transcoderFormat: [r5.BC1, r5.BC3], engineFormat: [i6.RGB_S3TC_DXT1_Format, i6.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false }, { if: "etc2Supported", basisFormat: [s6.ETC1S, s6.UASTC_4x4], transcoderFormat: [r5.ETC1, r5.ETC2], engineFormat: [i6.RGB_ETC2_Format, i6.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false }, { if: "etc1Supported", basisFormat: [s6.ETC1S, s6.UASTC_4x4], transcoderFormat: [r5.ETC1], engineFormat: [i6.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false }, { if: "pvrtcSupported", basisFormat: [s6.ETC1S, s6.UASTC_4x4], transcoderFormat: [r5.PVRTC1_4_RGB, r5.PVRTC1_4_RGBA], engineFormat: [i6.RGB_PVRTC_4BPPV1_Format, i6.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true }], o7 = a4.sort(function(t6, e9) {
      return t6.priorityETC1S - e9.priorityETC1S;
    }), l6 = a4.sort(function(t6, e9) {
      return t6.priorityUASTC - e9.priorityUASTC;
    });
    function h4(t6) {
      return t6 <= 2 || (t6 & t6 - 1) == 0 && t6 !== 0;
    }
  };
  var Cc = Symbol("retainerCount");
  var Lc = Symbol("recentlyUsed");
  var Pc = Symbol("evict");
  var Dc = Symbol("evictionThreshold");
  var Ic = Symbol("cache");
  var Oc = class {
    constructor(t5, e8 = 5) {
      this[Ac] = /* @__PURE__ */ new Map(), this[Rc] = [], this[Ic] = t5, this[Dc] = e8;
    }
    set evictionThreshold(t5) {
      this[Dc] = t5, this[Pc]();
    }
    get evictionThreshold() {
      return this[Dc];
    }
    get cache() {
      return this[Ic];
    }
    retainerCount(t5) {
      return this[Cc].get(t5) || 0;
    }
    reset() {
      this[Cc].clear(), this[Lc] = [];
    }
    retain(t5) {
      this[Cc].has(t5) || this[Cc].set(t5, 0), this[Cc].set(t5, this[Cc].get(t5) + 1);
      const e8 = this[Lc].indexOf(t5);
      e8 !== -1 && this[Lc].splice(e8, 1), this[Lc].unshift(t5), this[Pc]();
    }
    release(t5) {
      this[Cc].has(t5) && this[Cc].set(t5, Math.max(this[Cc].get(t5) - 1, 0)), this[Pc]();
    }
    [(Ac = Cc, Rc = Lc, Pc)]() {
      if (!(this[Lc].length < this[Dc]))
        for (let t5 = this[Lc].length - 1; t5 >= this[Dc]; --t5) {
          const e8 = this[Lc][t5];
          this[Cc].get(e8) === 0 && (this[Ic].delete(e8), this[Lc].splice(t5, 1));
        }
    }
  };
  var Nc = (t5) => {
    const e8 = /* @__PURE__ */ new Map();
    for (const n8 of t5.mappings)
      for (const t6 of n8.variants)
        e8.set(t6, { material: null, gltfMaterialIndex: n8.material });
    return e8;
  };
  var Fc = class {
    constructor(t5) {
      this.parser = t5, this.name = "KHR_materials_variants";
    }
    afterRoot(t5) {
      const e8 = this.parser, n8 = e8.json;
      if (n8.extensions === void 0 || n8.extensions[this.name] === void 0)
        return null;
      const i6 = ((t6) => {
        const e9 = [], n9 = /* @__PURE__ */ new Set();
        for (const i7 of t6) {
          let t7 = i7, r5 = 0;
          for (; n9.has(t7); )
            t7 = i7 + "." + ++r5;
          n9.add(t7), e9.push(t7);
        }
        return e9;
      })((n8.extensions[this.name].variants || []).map((t6) => t6.name));
      for (const i7 of t5.scenes)
        i7.traverse((t6) => {
          const i8 = t6;
          if (!i8.isMesh)
            return;
          const r5 = e8.associations.get(i8);
          if (r5 == null || r5.meshes == null || r5.primitives == null)
            return;
          const s6 = n8.meshes[r5.meshes].primitives[r5.primitives].extensions;
          s6 && s6[this.name] && (i8.userData.variantMaterials = Nc(s6[this.name]));
        });
      return t5.userData.variants = i6, Promise.resolve();
    }
  };
  var Uc;
  var kc;
  var Bc = /* @__PURE__ */ new Map();
  var zc = /* @__PURE__ */ new Map();
  var Hc;
  var Vc = new class extends lo {
    constructor(t5) {
      super(t5), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
    }
    setDecoderPath(t5) {
      return this.decoderPath = t5, this;
    }
    setDecoderConfig(t5) {
      return this.decoderConfig = t5, this;
    }
    setWorkerLimit(t5) {
      return this.workerLimit = t5, this;
    }
    load(t5, e8, n8, i6) {
      const r5 = new co(this.manager);
      r5.setPath(this.path), r5.setResponseType("arraybuffer"), r5.setRequestHeader(this.requestHeader), r5.setWithCredentials(this.withCredentials), r5.load(t5, (t6) => {
        const n9 = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: false };
        this.decodeGeometry(t6, n9).then(e8).catch(i6);
      }, n8, i6);
    }
    decodeDracoFile(t5, e8, n8, i6) {
      const r5 = { attributeIDs: n8 || this.defaultAttributeIDs, attributeTypes: i6 || this.defaultAttributeTypes, useUniqueIDs: !!n8 };
      this.decodeGeometry(t5, r5).then(e8);
    }
    decodeGeometry(t5, e8) {
      for (const t6 in e8.attributeTypes) {
        const n9 = e8.attributeTypes[t6];
        n9.BYTES_PER_ELEMENT !== void 0 && (e8.attributeTypes[t6] = n9.name);
      }
      const n8 = JSON.stringify(e8);
      if (_h.has(t5)) {
        const e9 = _h.get(t5);
        if (e9.key === n8)
          return e9.promise;
        if (t5.byteLength === 0)
          throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
      let i6;
      const r5 = this.workerNextTaskID++, s6 = t5.byteLength, a4 = this._getWorker(r5, s6).then((n9) => (i6 = n9, new Promise((n10, s7) => {
        i6._callbacks[r5] = { resolve: n10, reject: s7 }, i6.postMessage({ type: "decode", id: r5, taskConfig: e8, buffer: t5 }, [t5]);
      }))).then((t6) => this._createGeometry(t6.geometry));
      return a4.catch(() => true).then(() => {
        i6 && r5 && this._releaseTask(i6, r5);
      }), _h.set(t5, { key: n8, promise: a4 }), a4;
    }
    _createGeometry(t5) {
      const e8 = new ye();
      t5.index && e8.setIndex(new oe(t5.index.array, 1));
      for (let n8 = 0; n8 < t5.attributes.length; n8++) {
        const i6 = t5.attributes[n8], r5 = i6.name, s6 = i6.array, a4 = i6.itemSize;
        e8.setAttribute(r5, new oe(s6, a4));
      }
      return e8;
    }
    _loadLibrary(t5, e8) {
      const n8 = new co(this.manager);
      return n8.setPath(this.decoderPath), n8.setResponseType(e8), n8.setWithCredentials(this.withCredentials), new Promise((e9, i6) => {
        n8.load(t5, e9, void 0, i6);
      });
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending)
        return this.decoderPending;
      const t5 = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e8 = [];
      return t5 ? e8.push(this._loadLibrary("draco_decoder.js", "text")) : (e8.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e8.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e8).then((e9) => {
        const n8 = e9[0];
        t5 || (this.decoderConfig.wasmBinary = e9[1]);
        const i6 = wh.toString(), r5 = ["/* draco decoder */", n8, "", "/* worker */", i6.substring(i6.indexOf("{") + 1, i6.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([r5]));
      }), this.decoderPending;
    }
    _getWorker(t5, e8) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const t6 = new Worker(this.workerSourceURL);
          t6._callbacks = {}, t6._taskCosts = {}, t6._taskLoad = 0, t6.postMessage({ type: "init", decoderConfig: this.decoderConfig }), t6.onmessage = function(e9) {
            const n9 = e9.data;
            switch (n9.type) {
              case "decode":
                t6._callbacks[n9.id].resolve(n9);
                break;
              case "error":
                t6._callbacks[n9.id].reject(n9);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + n9.type + '"');
            }
          }, this.workerPool.push(t6);
        } else
          this.workerPool.sort(function(t6, e9) {
            return t6._taskLoad > e9._taskLoad ? -1 : 1;
          });
        const n8 = this.workerPool[this.workerPool.length - 1];
        return n8._taskCosts[t5] = e8, n8._taskLoad += e8, n8;
      });
    }
    _releaseTask(t5, e8) {
      t5._taskLoad -= t5._taskCosts[e8], delete t5._callbacks[e8], delete t5._taskCosts[e8];
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((t5) => t5._taskLoad));
    }
    dispose() {
      for (let t5 = 0; t5 < this.workerPool.length; ++t5)
        this.workerPool[t5].terminate();
      return this.workerPool.length = 0, this;
    }
  }();
  var Gc;
  var Wc = new Ec();
  var jc;
  var qc;
  var Xc = Symbol("loader");
  var $c = Symbol("evictionPolicy");
  var Yc = Symbol("GLTFInstance");
  var Jc = class extends i5 {
    constructor(t5) {
      super(), this[kc] = new Mh().register((t6) => new Fc(t6)), this[Yc] = t5, this[Xc].setDRACOLoader(Vc), this[Xc].setKTX2Loader(Wc);
    }
    static setDRACODecoderLocation(t5) {
      Hc = t5, Vc.setDecoderPath(t5);
    }
    static getDRACODecoderLocation() {
      return Hc;
    }
    static setKTX2TranscoderLocation(t5) {
      Gc = t5, Wc.setTranscoderPath(t5);
    }
    static getKTX2TranscoderLocation() {
      return Gc;
    }
    static setMeshoptDecoderLocation(t5) {
      var e8;
      jc !== t5 && (jc = t5, qc = (e8 = t5, new Promise((t6, n8) => {
        const i6 = document.createElement("script");
        document.body.appendChild(i6), i6.onload = t6, i6.onerror = n8, i6.async = true, i6.src = e8;
      })).then(() => MeshoptDecoder.ready).then(() => MeshoptDecoder));
    }
    static getMeshoptDecoderLocation() {
      return jc;
    }
    static initializeKTX2Loader(t5) {
      Wc.detectSupport(t5);
    }
    static get cache() {
      return Bc;
    }
    static clearCache() {
      Bc.forEach((t5, e8) => {
        this.delete(e8);
      }), this[$c].reset();
    }
    static has(t5) {
      return Bc.has(t5);
    }
    static async delete(t5) {
      if (!this.has(t5))
        return;
      const e8 = Bc.get(t5);
      zc.delete(t5), Bc.delete(t5);
      (await e8).dispose();
    }
    static hasFinishedLoading(t5) {
      return !!zc.get(t5);
    }
    get [(Uc = $c, kc = Xc, $c)]() {
      return this.constructor[$c];
    }
    async preload(t5, e8, n8 = () => {
    }) {
      if (this[Xc].setWithCredentials(Jc.withCredentials), this.dispatchEvent({ type: "preload", element: e8, src: t5 }), !Bc.has(t5)) {
        qc != null && this[Xc].setMeshoptDecoder(await qc);
        const e9 = ((t6, e10, n9 = () => {
        }) => {
          const i7 = (t7) => {
            const e11 = t7.loaded / t7.total;
            n9(Math.max(0, Math.min(1, isFinite(e11) ? e11 : 1)));
          };
          return new Promise((n10, r6) => {
            e10.load(t6, n10, i7, r6);
          });
        })(t5, this[Xc], (t6) => {
          n8(0.8 * t6);
        }), i6 = this[Yc], r5 = e9.then((t6) => i6.prepare(t6)).then((t6) => (n8(0.9), new i6(t6))).catch((t6) => (console.error(t6), new i6()));
        Bc.set(t5, r5);
      }
      await Bc.get(t5), zc.set(t5, true), n8 && n8(1);
    }
    async load(t5, e8, n8 = () => {
    }) {
      await this.preload(t5, e8, n8);
      const i6 = await Bc.get(t5), r5 = await i6.clone();
      return this[$c].retain(t5), r5.dispose = () => {
        this[$c].release(t5);
      }, r5;
    }
  };
  Jc[Uc] = new Oc(Jc);
  var Kc = class extends Wt {
    constructor(t5 = document.createElement("div")) {
      super(), this.element = t5, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.addEventListener("removed", function() {
        this.traverse(function(t6) {
          t6.element instanceof Element && t6.element.parentNode !== null && t6.element.parentNode.removeChild(t6.element);
        });
      });
    }
    copy(t5, e8) {
      return super.copy(t5, e8), this.element = t5.element.cloneNode(true), this;
    }
  };
  Kc.prototype.isCSS2DObject = true;
  var Zc = new V2();
  var Qc = new xt();
  var tu = new xt();
  var eu = new V2();
  var nu = new V2();
  var iu = class {
    constructor(t5 = {}) {
      const e8 = this;
      let n8, i6, r5, s6;
      const a4 = { objects: /* @__PURE__ */ new WeakMap() }, o7 = t5.element !== void 0 ? t5.element : document.createElement("div");
      function l6(t6, n9, i7) {
        if (t6.isCSS2DObject) {
          Zc.setFromMatrixPosition(t6.matrixWorld), Zc.applyMatrix4(tu);
          const l7 = t6.visible === true && Zc.z >= -1 && Zc.z <= 1 && t6.layers.test(i7.layers) === true;
          if (t6.element.style.display = l7 === true ? "" : "none", l7 === true) {
            t6.onBeforeRender(e8, n9, i7);
            const a5 = t6.element;
            /apple/i.test(navigator.vendor) ? a5.style.transform = "translate(-50%,-50%) translate(" + Math.round(Zc.x * r5 + r5) + "px," + Math.round(-Zc.y * s6 + s6) + "px)" : a5.style.transform = "translate(-50%,-50%) translate(" + (Zc.x * r5 + r5) + "px," + (-Zc.y * s6 + s6) + "px)", a5.parentNode !== o7 && o7.appendChild(a5), t6.onAfterRender(e8, n9, i7);
          }
          const c3 = { distanceToCameraSquared: h4(i7, t6) };
          a4.objects.set(t6, c3);
        }
        for (let e9 = 0, r6 = t6.children.length; e9 < r6; e9++)
          l6(t6.children[e9], n9, i7);
      }
      function h4(t6, e9) {
        return eu.setFromMatrixPosition(t6.matrixWorld), nu.setFromMatrixPosition(e9.matrixWorld), eu.distanceToSquared(nu);
      }
      o7.style.overflow = "hidden", this.domElement = o7, this.getSize = function() {
        return { width: n8, height: i6 };
      }, this.render = function(t6, e9) {
        t6.autoUpdate === true && t6.updateMatrixWorld(), e9.parent === null && e9.updateMatrixWorld(), Qc.copy(e9.matrixWorldInverse), tu.multiplyMatrices(e9.projectionMatrix, Qc), l6(t6, t6, e9), function(t7) {
          const e10 = function(t8) {
            const e11 = [];
            return t8.traverse(function(t9) {
              t9.isCSS2DObject && e11.push(t9);
            }), e11;
          }(t7).sort(function(t8, e11) {
            if (t8.renderOrder !== e11.renderOrder)
              return e11.renderOrder - t8.renderOrder;
            return a4.objects.get(t8).distanceToCameraSquared - a4.objects.get(e11).distanceToCameraSquared;
          }), n9 = e10.length;
          for (let t8 = 0, i7 = e10.length; t8 < i7; t8++)
            e10[t8].element.style.zIndex = n9 - t8;
        }(t6);
      }, this.setSize = function(t6, e9) {
        n8 = t6, i6 = e9, r5 = n8 / 2, s6 = i6 / 2, o7.style.width = t6 + "px", o7.style.height = e9 + "px";
      };
    }
  };
  var ru = (t5) => t5 && t5 !== "null" ? au(t5) : null;
  var su = () => {
    if (ph)
      return;
    const t5 = [];
    throw hh || t5.push("WebXR Device API"), ch || t5.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${t5.join(", ")}`);
  };
  var au = (t5) => new URL(t5, window.location.toString()).toString();
  var ou = (t5, e8) => {
    let n8 = null;
    return (...i6) => {
      n8 != null && self.clearTimeout(n8), n8 = self.setTimeout(() => {
        n8 = null, t5(...i6);
      }, e8);
    };
  };
  var lu = (t5, e8, n8) => Math.max(e8, Math.min(n8, t5));
  var hu = (() => {
    const t5 = (() => {
      var t6;
      if ((t6 = document.documentElement.getAttribute("itemtype")) === null || t6 === void 0 ? void 0 : t6.includes("schema.org/SearchResultsPage"))
        return true;
      const e8 = document.head != null ? Array.from(document.head.querySelectorAll("meta")) : [];
      for (const t7 of e8)
        if (t7.name === "viewport")
          return true;
      return false;
    })();
    return t5 || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), () => t5 ? window.devicePixelRatio : 1;
  })();
  var cu = (() => {
    const t5 = new RegExp("[?&]model-viewer-debug-mode(&|$)");
    return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t5);
  })();
  var uu = (t5 = 0) => new Promise((e8) => setTimeout(e8, t5));
  var du = class {
    constructor(t5 = 50) {
      this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(t5);
    }
    setDecayTime(t5) {
      this.naturalFrequency = 1 / Math.max(1e-3, t5);
    }
    update(t5, e8, n8, i6) {
      const r5 = 2e-4 * this.naturalFrequency;
      if (t5 == null || i6 === 0)
        return e8;
      if (t5 === e8 && this.velocity === 0)
        return e8;
      if (n8 < 0)
        return t5;
      const s6 = t5 - e8, a4 = this.velocity + this.naturalFrequency * s6, o7 = s6 + n8 * a4, l6 = Math.exp(-this.naturalFrequency * n8), h4 = (a4 - this.naturalFrequency * o7) * l6, c3 = -this.naturalFrequency * (h4 + a4 * l6);
      return Math.abs(h4) < r5 * Math.abs(i6) && c3 * s6 >= 0 ? (this.velocity = 0, e8) : (this.velocity = h4, e8 + o7 * l6);
    }
  };
  var pu = (t5, e8) => ({ type: "number", number: t5, unit: e8 });
  var mu = (() => {
    const t5 = {};
    return (e8) => {
      const n8 = e8;
      if (n8 in t5)
        return t5[n8];
      const i6 = [];
      let r5 = 0;
      for (; e8; ) {
        if (++r5 > 1e3) {
          e8 = "";
          break;
        }
        const t6 = fu(e8), n9 = t6.nodes[0];
        if (n9 == null || n9.terms.length === 0)
          break;
        i6.push(n9), e8 = t6.remainingInput;
      }
      return t5[n8] = i6;
    };
  })();
  var fu = (() => {
    const t5 = /^(\-\-|[a-z\u0240-\uffff])/i, e8 = /^([\*\+\/]|[\-]\s)/i, n8 = /^[\),]/;
    return (i6) => {
      const r5 = [];
      for (; i6.length && (i6 = i6.trim(), !n8.test(i6)); )
        if (i6[0] === "(") {
          const { nodes: t6, remainingInput: e9 } = xu(i6);
          i6 = e9, r5.push({ type: "function", name: { type: "ident", value: "calc" }, arguments: t6 });
        } else if (t5.test(i6)) {
          const t6 = gu(i6), e9 = t6.nodes[0];
          if ((i6 = t6.remainingInput)[0] === "(") {
            const { nodes: t7, remainingInput: n9 } = xu(i6);
            r5.push({ type: "function", name: e9, arguments: t7 }), i6 = n9;
          } else
            r5.push(e9);
        } else if (e8.test(i6))
          r5.push({ type: "operator", value: i6[0] }), i6 = i6.slice(1);
        else {
          const { nodes: t6, remainingInput: e9 } = i6[0] === "#" ? yu(i6) : vu(i6);
          if (t6.length === 0)
            break;
          r5.push(t6[0]), i6 = e9;
        }
      return { nodes: [{ type: "expression", terms: r5 }], remainingInput: i6 };
    };
  })();
  var gu = (() => {
    const t5 = /[^a-z0-9_\-\u0240-\uffff]/i;
    return (e8) => {
      const n8 = e8.match(t5);
      return { nodes: [{ type: "ident", value: n8 == null ? e8 : e8.substr(0, n8.index) }], remainingInput: n8 == null ? "" : e8.substr(n8.index) };
    };
  })();
  var vu = (() => {
    const t5 = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/, e8 = /^[a-z%]+/i, n8 = /^(m|mm|cm|rad|deg|[%])$/;
    return (i6) => {
      const r5 = i6.match(t5), s6 = r5 == null ? "0" : r5[0], a4 = (i6 = s6 == null ? i6 : i6.slice(s6.length)).match(e8);
      let o7 = a4 != null && a4[0] !== "" ? a4[0] : null;
      const l6 = a4 == null ? i6 : i6.slice(o7.length);
      return o7 == null || n8.test(o7) || (o7 = null), { nodes: [{ type: "number", number: parseFloat(s6) || 0, unit: o7 }], remainingInput: l6 };
    };
  })();
  var yu = (() => {
    const t5 = /^[a-f0-9]*/i;
    return (e8) => {
      const n8 = (e8 = e8.slice(1).trim()).match(t5);
      return { nodes: n8 == null ? [] : [{ type: "hex", value: n8[0] }], remainingInput: n8 == null ? e8 : e8.slice(n8[0].length) };
    };
  })();
  var xu = (t5) => {
    const e8 = [];
    for (t5 = t5.slice(1).trim(); t5.length; ) {
      const n8 = fu(t5);
      if (e8.push(n8.nodes[0]), (t5 = n8.remainingInput.trim())[0] === ",")
        t5 = t5.slice(1).trim();
      else if (t5[0] === ")") {
        t5 = t5.slice(1);
        break;
      }
    }
    return { nodes: e8, remainingInput: t5 };
  };
  var bu = Symbol("visitedTypes");
  var _u = class {
    constructor(t5) {
      this[bu] = t5;
    }
    walk(t5, e8) {
      const n8 = t5.slice();
      for (; n8.length; ) {
        const t6 = n8.shift();
        switch (this[bu].indexOf(t6.type) > -1 && e8(t6), t6.type) {
          case "expression":
            n8.unshift(...t6.terms);
            break;
          case "function":
            n8.unshift(t6.name, ...t6.arguments);
        }
      }
    }
  };
  var wu = Object.freeze({ type: "number", number: 0, unit: null });
  var Mu = (t5, e8 = 0) => {
    let { number: n8, unit: i6 } = t5;
    if (isFinite(n8)) {
      if (t5.unit === "rad" || t5.unit == null)
        return t5;
    } else
      n8 = e8, i6 = "rad";
    return { type: "number", number: (i6 === "deg" && n8 != null ? n8 : 0) * Math.PI / 180, unit: "rad" };
  };
  var Su = (t5, e8 = 0) => {
    let n8, { number: i6, unit: r5 } = t5;
    if (isFinite(i6)) {
      if (t5.unit === "m")
        return t5;
    } else
      i6 = e8, r5 = "m";
    switch (r5) {
      default:
        n8 = 1;
        break;
      case "cm":
        n8 = 0.01;
        break;
      case "mm":
        n8 = 1e-3;
    }
    return { type: "number", number: n8 * i6, unit: "m" };
  };
  var Tu = (() => {
    const t5 = (t6) => t6, e8 = { rad: t5, deg: Mu, m: t5, mm: Su, cm: Su };
    return (t6, n8 = wu) => {
      isFinite(t6.number) || (t6.number = n8.number, t6.unit = n8.unit);
      const { unit: i6 } = t6;
      if (i6 == null)
        return t6;
      const r5 = e8[i6];
      return r5 == null ? n8 : r5(t6);
    };
  })();
  var Eu = class extends Kc {
    constructor(t5) {
      super(document.createElement("div")), this.normal = new V2(0, 1, 0), this.initialized = false, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = t5.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(t5.position), this.updateNormal(t5.normal);
    }
    get facingCamera() {
      return !this.element.classList.contains("hide");
    }
    show() {
      this.facingCamera && this.initialized || this.updateVisibility(true);
    }
    hide() {
      !this.facingCamera && this.initialized || this.updateVisibility(false);
    }
    increment() {
      this.referenceCount++;
    }
    decrement() {
      return this.referenceCount > 0 && --this.referenceCount, this.referenceCount === 0;
    }
    updatePosition(t5) {
      if (t5 == null)
        return;
      const e8 = mu(t5)[0].terms;
      for (let t6 = 0; t6 < 3; ++t6)
        this.position.setComponent(t6, Tu(e8[t6]).number);
      this.updateMatrixWorld();
    }
    updateNormal(t5) {
      if (t5 == null)
        return;
      const e8 = mu(t5)[0].terms;
      for (let t6 = 0; t6 < 3; ++t6)
        this.normal.setComponent(t6, Tu(e8[t6]).number);
    }
    orient(t5) {
      this.pivot.style.transform = `rotate(${t5}rad)`;
    }
    updateVisibility(t5) {
      t5 ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach((e8) => {
        if (e8.nodeType !== Node.ELEMENT_NODE)
          return;
        const n8 = e8, i6 = n8.dataset.visibilityAttribute;
        if (i6 != null) {
          const e9 = `data-${i6}`;
          t5 ? n8.setAttribute(e9, "") : n8.removeAttribute(e9);
        }
        n8.dispatchEvent(new CustomEvent("hotspot-visibility", { detail: { visible: t5 } }));
      }), this.initialized = true;
    }
  };
  var Au = (t5, e8, n8) => {
    let i6 = n8;
    const r5 = new V2();
    return t5.traverseVisible((t6) => {
      let n9, s6;
      t6.updateWorldMatrix(false, false);
      const a4 = t6.geometry;
      if (a4 !== void 0) {
        if (a4.isGeometry) {
          const o7 = a4.vertices;
          for (n9 = 0, s6 = o7.length; n9 < s6; n9++)
            r5.copy(o7[n9]), t6.isSkinnedMesh ? t6.boneTransform(n9, r5) : r5.applyMatrix4(t6.matrixWorld), i6 = e8(i6, r5);
        } else if (a4.isBufferGeometry) {
          const { position: o7 } = a4.attributes;
          if (o7 !== void 0) {
            const a5 = ((t7) => {
              if (!t7.normalized)
                return 1;
              const e9 = t7.array;
              return e9 instanceof Int8Array ? 1 / 127 : e9 instanceof Uint8Array ? 1 / 255 : e9 instanceof Int16Array ? 1 / 32767 : e9 instanceof Uint16Array ? 1 / 65535 : 1;
            })(o7);
            for (n9 = 0, s6 = o7.count; n9 < s6; n9++)
              r5.fromBufferAttribute(o7, n9), r5.multiplyScalar(a5), t6.isSkinnedMesh ? t6.boneTransform(n9, r5) : r5.applyMatrix4(t6.matrixWorld), i6 = e8(i6, r5);
          }
        }
      }
    }), i6;
  };
  var Ru = { uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float h;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" };
  var Cu = { uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float v;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" };
  var Lu = [];
  for (let t5 = 0; t5 < 256; t5++)
    Lu[t5] = (t5 < 16 ? "0" : "") + t5.toString(16);
  function Pu(t5, e8, n8) {
    return (1 - n8) * t5 + n8 * e8;
  }
  var Du = class extends Wt {
    constructor(t5, e8, n8) {
      super(), this.camera = new mn(), this.renderTarget = null, this.renderTargetBlur = null, this.depthMaterial = new _r(), this.horizontalBlurMaterial = new Ve(Ru), this.verticalBlurMaterial = new Ve(Cu), this.intensity = 0, this.softness = 1, this.boundingBox = new j(), this.size = new V2(), this.maxDimension = 0, this.isAnimated = false, this.needsUpdate = false;
      const { camera: i6 } = this;
      i6.rotation.x = Math.PI / 2, i6.left = -0.5, i6.right = 0.5, i6.bottom = -0.5, i6.top = 0.5, this.add(i6);
      const r5 = new rn(), s6 = new re({ opacity: 1, transparent: true, side: 1 });
      this.floor = new Fe(r5, s6), this.floor.userData.shadow = true, i6.add(this.floor), this.blurPlane = new Fe(r5), this.blurPlane.visible = false, i6.add(this.blurPlane), t5.target.add(this), this.depthMaterial.onBeforeCompile = function(t6) {
        t6.fragmentShader = t6.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );");
      }, this.horizontalBlurMaterial.depthTest = false, this.verticalBlurMaterial.depthTest = false, this.setScene(t5, e8, n8);
    }
    setScene(t5, e8, n8) {
      const { boundingBox: i6, size: r5, rotation: s6, position: a4 } = this;
      if (this.isAnimated = t5.animationNames.length > 0, this.boundingBox.copy(t5.boundingBox), this.size.copy(t5.size), this.maxDimension = Math.max(r5.x, r5.y, r5.z) * (this.isAnimated ? 2 : 1), this.boundingBox.getCenter(a4), n8 === "back") {
        const { min: t6, max: e9 } = i6;
        [t6.y, t6.z] = [t6.z, t6.y], [e9.y, e9.z] = [e9.z, e9.y], [r5.y, r5.z] = [r5.z, r5.y], s6.x = Math.PI / 2, s6.y = Math.PI;
      } else
        s6.x = 0, s6.y = 0;
      if (this.isAnimated) {
        const t6 = i6.min.y, e9 = i6.max.y;
        r5.y = this.maxDimension, i6.expandByVector(r5.subScalar(this.maxDimension).multiplyScalar(-0.5)), i6.min.y = t6, i6.max.y = e9, r5.set(this.maxDimension, e9 - t6, this.maxDimension);
      }
      n8 === "bottom" ? a4.y = i6.min.y : a4.z = i6.min.y, this.setSoftness(e8);
    }
    setSoftness(t5) {
      this.softness = t5;
      const { size: e8, camera: n8 } = this, i6 = this.isAnimated ? 2 : 1, r5 = i6 * Math.pow(2, 9 - 3 * t5);
      this.setMapSize(r5);
      const s6 = e8.y / 2, a4 = e8.y * i6;
      n8.near = 0, n8.far = Pu(a4, s6, t5), this.depthMaterial.opacity = 1 / t5, n8.updateProjectionMatrix(), this.setIntensity(this.intensity), this.setOffset(0);
    }
    setMapSize(t5) {
      const { size: e8 } = this;
      this.isAnimated && (t5 *= 2);
      const n8 = Math.floor(e8.x > e8.z ? t5 : t5 * e8.x / e8.z), i6 = Math.floor(e8.x > e8.z ? t5 * e8.z / e8.x : t5), r5 = 10 + n8, s6 = 10 + i6;
      if (this.renderTarget == null || this.renderTarget.width === r5 && this.renderTarget.height === s6 || (this.renderTarget.dispose(), this.renderTarget = null, this.renderTargetBlur.dispose(), this.renderTargetBlur = null), this.renderTarget == null) {
        const t6 = { format: 1023 };
        this.renderTarget = new k2(r5, s6, t6), this.renderTargetBlur = new k2(r5, s6, t6), this.floor.material.map = this.renderTarget.texture;
      }
      this.camera.scale.set(e8.x * (1 + 10 / n8), e8.z * (1 + 10 / i6), 1), this.needsUpdate = true;
    }
    setIntensity(t5) {
      this.intensity = t5, t5 > 0 ? (this.visible = true, this.floor.visible = true, this.floor.material.opacity = t5 * Pu(0.3, 1, this.softness * this.softness)) : (this.visible = false, this.floor.visible = false);
    }
    getIntensity() {
      return this.intensity;
    }
    setOffset(t5) {
      this.floor.position.z = -t5 + 1e-3 * this.maxDimension;
    }
    render(t5, e8) {
      e8.overrideMaterial = this.depthMaterial;
      const n8 = t5.getClearAlpha();
      t5.setClearAlpha(0), this.floor.visible = false;
      const i6 = t5.xr.enabled;
      t5.xr.enabled = false;
      const r5 = t5.getRenderTarget();
      t5.setRenderTarget(this.renderTarget), t5.render(e8, this.camera), e8.overrideMaterial = null, this.floor.visible = true, this.blurShadow(t5), t5.xr.enabled = i6, t5.setRenderTarget(r5), t5.setClearAlpha(n8);
    }
    blurShadow(t5) {
      const { camera: e8, horizontalBlurMaterial: n8, verticalBlurMaterial: i6, renderTarget: r5, renderTargetBlur: s6, blurPlane: a4 } = this;
      a4.visible = true, a4.material = n8, n8.uniforms.h.value = 1 / this.renderTarget.width, n8.uniforms.tDiffuse.value = this.renderTarget.texture, t5.setRenderTarget(s6), t5.render(a4, e8), a4.material = i6, i6.uniforms.v.value = 1 / this.renderTarget.height, i6.uniforms.tDiffuse.value = this.renderTargetBlur.texture, t5.setRenderTarget(r5), t5.render(a4, e8), a4.visible = false;
    }
  };
  var Iu = new V2();
  var Ou = new V2();
  var Nu = new V2();
  var Fu = new class {
    constructor(t5, e8, n8 = 0, i6 = 1 / 0) {
      this.ray = new yt(t5, e8), this.near = n8, this.far = i6, this.camera = null, this.layers = new Lt(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    }
    set(t5, e8) {
      this.ray.set(t5, e8);
    }
    setFromCamera(t5, e8) {
      e8.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e8.matrixWorld), this.ray.direction.set(t5.x, t5.y, 0.5).unproject(e8).sub(this.ray.origin).normalize(), this.camera = e8) : e8.isOrthographicCamera ? (this.ray.origin.set(t5.x, t5.y, (e8.near + e8.far) / (e8.near - e8.far)).unproject(e8), this.ray.direction.set(0, 0, -1).transformDirection(e8.matrixWorld), this.camera = e8) : console.error("THREE.Raycaster: Unsupported camera type: " + e8.type);
    }
    intersectObject(t5, e8 = true, n8 = []) {
      return Jo(t5, this, n8, e8), n8.sort(Yo), n8;
    }
    intersectObjects(t5, e8 = true, n8 = []) {
      for (let i6 = 0, r5 = t5.length; i6 < r5; i6++)
        Jo(t5[i6], this, n8, e8);
      return n8.sort(Yo), n8;
    }
  }();
  var Uu = new V2();
  var ku = new g2();
  var Bu = class extends Nr {
    constructor({ canvas: t5, element: e8, width: n8, height: i6 }) {
      super(), this.context = null, this.annotationRenderer = new iu(), this.schemaElement = document.createElement("script"), this.width = 1, this.height = 1, this.aspect = 1, this.renderCount = 0, this.externalRenderer = null, this.camera = new We(45, 1, 0.1, 100), this.xrCamera = null, this.url = null, this.target = new Wt(), this.modelContainer = new Wt(), this.animationNames = [], this.boundingBox = new j(), this.boundingSphere = new ct(), this.size = new V2(), this.idealAspect = 0, this.framedFoVDeg = 0, this.shadow = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.bakedShadows = /* @__PURE__ */ new Set(), this.exposure = 1, this.canScale = true, this.tightBounds = false, this.isDirty = false, this.goalTarget = new V2(), this.targetDamperX = new du(), this.targetDamperY = new du(), this.targetDamperZ = new du(), this._currentGLTF = null, this.cancelPendingSourceChange = null, this.animationsByName = /* @__PURE__ */ new Map(), this.currentAnimationAction = null, this.name = "ModelScene", this.element = e8, this.canvas = t5, this.camera = new We(45, 1, 0.1, 100), this.camera.name = "MainCamera", this.add(this.target), this.setSize(n8, i6), this.target.name = "Target", this.modelContainer.name = "ModelContainer", this.target.add(this.modelContainer), this.mixer = new $o(this.modelContainer);
      const { domElement: r5 } = this.annotationRenderer, { style: s6 } = r5;
      s6.display = "none", s6.pointerEvents = "none", s6.position = "absolute", s6.top = "0", this.element.shadowRoot.querySelector(".default").appendChild(r5), this.schemaElement.setAttribute("type", "application/ld+json");
    }
    createContext() {
      this.context = this.canvas.getContext("2d");
    }
    getCamera() {
      return this.xrCamera != null ? this.xrCamera : this.camera;
    }
    queueRender() {
      this.isDirty = true;
    }
    shouldRender() {
      return this.isDirty;
    }
    hasRendered() {
      this.isDirty = false;
    }
    async setObject(t5) {
      this.reset(), this.modelContainer.add(t5), await this.setupScene();
    }
    async setSource(t5, e8 = () => {
    }) {
      if (!t5 || t5 === this.url)
        return void e8(1);
      if (this.reset(), this.url = t5, this.externalRenderer != null) {
        const t6 = await this.externalRenderer.load(e8);
        return this.boundingSphere.radius = t6.framedRadius, this.idealAspect = t6.fieldOfViewAspect, void this.dispatchEvent({ type: "model-load", url: this.url });
      }
      let n8;
      this.cancelPendingSourceChange != null && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
      try {
        n8 = await new Promise(async (n9, i7) => {
          this.cancelPendingSourceChange = () => i7();
          try {
            n9(await this.element[Ep].loader.load(t5, this.element, e8));
          } catch (t6) {
            i7(t6);
          }
        });
      } catch (t6) {
        if (t6 == null)
          return;
        throw t6;
      }
      this.reset(), this.url = t5, this._currentGLTF = n8, n8 != null && this.modelContainer.add(n8.scene);
      const { animations: i6 } = n8, r5 = /* @__PURE__ */ new Map(), s6 = [];
      for (const t6 of i6)
        r5.set(t6.name, t6), s6.push(t6.name);
      this.animations = i6, this.animationsByName = r5, this.animationNames = s6, await this.setupScene();
    }
    async setupScene() {
      this.updateBoundingBox(), await this.updateFraming(), this.updateShadow(), this.setShadowIntensity(this.shadowIntensity), this.dispatchEvent({ type: "model-load", url: this.url });
    }
    reset() {
      this.url = null, this.queueRender(), this.shadow != null && this.shadow.setIntensity(0), this.bakedShadows.clear();
      const t5 = this._currentGLTF;
      if (t5 != null) {
        for (const t6 of this.modelContainer.children)
          this.modelContainer.remove(t6);
        t5.dispose(), this._currentGLTF = null;
      }
      this.currentAnimationAction != null && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
    }
    get currentGLTF() {
      return this._currentGLTF;
    }
    setSize(t5, e8) {
      if (this.width !== t5 || this.height !== e8) {
        if (this.width = Math.max(t5, 1), this.height = Math.max(e8, 1), this.annotationRenderer.setSize(t5, e8), this.aspect = this.width / this.height, this.externalRenderer != null) {
          const n8 = hu();
          this.externalRenderer.resize(t5 * n8, e8 * n8);
        }
        this.queueRender();
      }
    }
    markBakedShadow(t5) {
      t5.userData.shadow = true, this.bakedShadows.add(t5);
    }
    unmarkBakedShadow(t5) {
      t5.userData.shadow = false, t5.visible = true, this.bakedShadows.delete(t5), this.boundingBox.expandByObject(t5);
    }
    findBakedShadows(t5) {
      const e8 = new j();
      t5.traverse((t6) => {
        const n8 = t6;
        if (!n8.isMesh)
          return;
        if (!n8.material.transparent)
          return;
        e8.setFromObject(n8);
        const i6 = e8.getSize(Uu), r5 = Math.min(i6.x, i6.y, i6.z);
        Math.max(i6.x, i6.y, i6.z) < 100 * r5 || this.markBakedShadow(n8);
      });
    }
    checkBakedShadows() {
      const { min: t5, max: e8 } = this.boundingBox, n8 = new j();
      this.boundingBox.getSize(this.size);
      for (const i6 of this.bakedShadows)
        n8.setFromObject(i6), n8.min.y < t5.y + this.size.y / 100 && n8.min.x <= t5.x && n8.max.x >= e8.x && n8.min.z <= t5.z && n8.max.z >= e8.z || n8.min.z < t5.z + this.size.z / 100 && n8.min.x <= t5.x && n8.max.x >= e8.x && n8.min.y <= t5.y && n8.max.y >= e8.y || this.unmarkBakedShadow(i6);
    }
    updateBoundingBox() {
      if (this.target.remove(this.modelContainer), this.findBakedShadows(this.modelContainer), this.tightBounds === true) {
        const t5 = (t6, e8) => t6.expandByPoint(e8);
        this.setBakedShadowVisibility(false), this.boundingBox = Au(this.modelContainer, t5, new j()), this.boundingBox.isEmpty() && (this.setBakedShadowVisibility(true), this.bakedShadows.forEach((t6) => this.unmarkBakedShadow(t6)), this.boundingBox = Au(this.modelContainer, t5, new j())), this.checkBakedShadows(), this.setBakedShadowVisibility();
      } else
        this.boundingBox.setFromObject(this.modelContainer);
      this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
    }
    async updateFraming() {
      this.target.remove(this.modelContainer), this.setBakedShadowVisibility(false);
      const { center: t5 } = this.boundingSphere;
      this.tightBounds === true ? (this.element.requestUpdate("cameraTarget"), await this.element.updateComplete, t5.copy(this.getTarget())) : this.boundingBox.getCenter(t5);
      this.boundingSphere.radius = Math.sqrt(Au(this.modelContainer, (e8, n8) => Math.max(e8, t5.distanceToSquared(n8)), 0));
      this.idealAspect = Au(this.modelContainer, (e8, n8) => {
        n8.sub(t5);
        const i6 = Math.sqrt(n8.x * n8.x + n8.z * n8.z);
        return Math.max(e8, i6 / (this.idealCameraDistance() - Math.abs(n8.y)));
      }, 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180), this.setBakedShadowVisibility(), this.target.add(this.modelContainer);
    }
    setBakedShadowVisibility(t5 = this.shadowIntensity <= 0) {
      for (const e8 of this.bakedShadows)
        e8.visible = t5;
    }
    idealCameraDistance() {
      const t5 = this.framedFoVDeg / 2 * Math.PI / 180;
      return this.boundingSphere.radius / Math.sin(t5);
    }
    adjustedFoV(t5) {
      const e8 = Math.tan(t5 / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
      return 2 * Math.atan(e8) * 180 / Math.PI;
    }
    getNDC(t5, e8) {
      if (this.xrCamera != null)
        ku.set(t5 / window.screen.width, e8 / window.screen.height);
      else {
        const n8 = this.element.getBoundingClientRect();
        ku.set((t5 - n8.x) / this.width, (e8 - n8.y) / this.height);
      }
      return ku.multiplyScalar(2).subScalar(1), ku.y *= -1, ku;
    }
    getSize() {
      return { width: this.width, height: this.height };
    }
    setTarget(t5, e8, n8) {
      this.goalTarget.set(-t5, -e8, -n8);
    }
    setTargetDamperDecayTime(t5) {
      this.targetDamperX.setDecayTime(t5), this.targetDamperY.setDecayTime(t5), this.targetDamperZ.setDecayTime(t5);
    }
    getTarget() {
      return Uu.copy(this.goalTarget).multiplyScalar(-1);
    }
    jumpToGoal() {
      this.updateTarget(1e4);
    }
    updateTarget(t5) {
      const e8 = this.goalTarget, n8 = this.target.position;
      if (e8.equals(n8))
        return false;
      {
        const i6 = this.boundingSphere.radius / 10;
        let { x: r5, y: s6, z: a4 } = n8;
        return r5 = this.targetDamperX.update(r5, e8.x, t5, i6), s6 = this.targetDamperY.update(s6, e8.y, t5, i6), a4 = this.targetDamperZ.update(a4, e8.z, t5, i6), this.target.position.set(r5, s6, a4), this.target.updateMatrixWorld(), this.queueRender(), true;
      }
    }
    pointTowards(t5, e8) {
      const { x: n8, z: i6 } = this.position;
      this.yaw = Math.atan2(t5 - n8, e8 - i6);
    }
    set yaw(t5) {
      this.rotation.y = t5, this.queueRender();
    }
    get yaw() {
      return this.rotation.y;
    }
    set animationTime(t5) {
      this.mixer.setTime(t5), this.queueShadowRender();
    }
    get animationTime() {
      if (this.currentAnimationAction != null) {
        const t5 = Math.max(this.currentAnimationAction._loopCount, 0);
        return this.currentAnimationAction.loop === 2202 && (1 & t5) == 1 ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time;
      }
      return 0;
    }
    set animationTimeScale(t5) {
      this.mixer.timeScale = t5;
    }
    get animationTimeScale() {
      return this.mixer.timeScale;
    }
    get duration() {
      return this.currentAnimationAction != null && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
    }
    get hasActiveAnimation() {
      return this.currentAnimationAction != null;
    }
    playAnimation(t5 = null, e8 = 0, n8 = 2201, i6 = 1 / 0) {
      if (this._currentGLTF == null)
        return;
      const { animations: r5 } = this;
      if (r5 == null || r5.length === 0)
        return void console.warn("Cannot play animation (model does not have any animations)");
      let s6 = null;
      if (t5 != null && (s6 = this.animationsByName.get(t5), s6 == null)) {
        const e9 = parseInt(t5);
        !isNaN(e9) && e9 >= 0 && e9 < r5.length && (s6 = r5[e9]);
      }
      s6 == null && (s6 = r5[0]);
      try {
        const { currentAnimationAction: t6 } = this, r6 = this.mixer.clipAction(s6, this);
        this.currentAnimationAction = r6, this.element.paused ? this.mixer.stopAllAction() : (r6.paused = false, t6 != null && r6 !== t6 ? r6.crossFadeFrom(t6, e8, false) : this.animationTimeScale > 0 && this.animationTime == this.duration && (this.animationTime = 0)), r6.setLoop(n8, i6), r6.enabled = true, r6.clampWhenFinished = true, r6.play();
      } catch (t6) {
        console.error(t6);
      }
    }
    stopAnimation() {
      this.currentAnimationAction = null, this.mixer.stopAllAction();
    }
    updateAnimation(t5) {
      this.mixer.update(t5), this.queueShadowRender();
    }
    subscribeMixerEvent(t5, e8) {
      this.mixer.addEventListener(t5, e8);
    }
    updateShadow() {
      const t5 = this.shadow;
      if (t5 != null) {
        const e8 = this.element.arPlacement === "wall" ? "back" : "bottom";
        t5.setScene(this, this.shadowSoftness, e8), t5.needsUpdate = true;
      }
    }
    renderShadow(t5) {
      const e8 = this.shadow;
      e8 != null && e8.needsUpdate == 1 && (e8.render(t5, this), e8.needsUpdate = false);
    }
    queueShadowRender() {
      this.shadow != null && (this.shadow.needsUpdate = true);
    }
    setShadowIntensity(t5) {
      if (this.shadowIntensity = t5, this._currentGLTF != null && (this.setBakedShadowVisibility(), !(t5 <= 0 && this.shadow == null))) {
        if (this.shadow == null) {
          const t6 = this.element.arPlacement === "wall" ? "back" : "bottom";
          this.shadow = new Du(this, this.shadowSoftness, t6);
        }
        this.shadow.setIntensity(t5);
      }
    }
    setShadowSoftness(t5) {
      this.shadowSoftness = t5;
      const e8 = this.shadow;
      e8 != null && e8.setSoftness(t5);
    }
    setShadowOffset(t5) {
      const e8 = this.shadow;
      e8 != null && e8.setOffset(t5);
    }
    get raycaster() {
      return Fu;
    }
    positionAndNormalFromPoint(t5, e8 = this) {
      this.raycaster.setFromCamera(t5, this.getCamera());
      const n8 = this.raycaster.intersectObject(e8, true).find((t6) => !t6.object.userData.shadow);
      return n8 == null || n8.face == null ? null : n8.uv == null ? { position: n8.point, normal: n8.face.normal, uv: null } : (n8.face.normal.applyNormalMatrix(new v2().getNormalMatrix(n8.object.matrixWorld)), { position: n8.point, normal: n8.face.normal, uv: n8.uv });
    }
    addHotspot(t5) {
      this.target.add(t5), this.annotationRenderer.domElement.appendChild(t5.element);
    }
    removeHotspot(t5) {
      this.target.remove(t5);
    }
    forHotspots(t5) {
      const { children: e8 } = this.target;
      for (let n8 = 0, i6 = e8.length; n8 < i6; n8++) {
        const i7 = e8[n8];
        i7 instanceof Eu && t5(i7);
      }
    }
    updateHotspots(t5) {
      this.forHotspots((e8) => {
        Iu.copy(t5), Ou.setFromMatrixPosition(e8.matrixWorld), Iu.sub(Ou), Nu.copy(e8.normal).transformDirection(this.target.matrixWorld), Iu.dot(Nu) < 0 ? e8.hide() : e8.show();
      });
    }
    orientHotspots(t5) {
      this.forHotspots((e8) => {
        e8.orient(t5);
      });
    }
    setHotspotsVisibility(t5) {
      this.forHotspots((e8) => {
        e8.visible = t5;
      });
    }
    updateSchema(t5) {
      var e8;
      const { schemaElement: n8, element: i6 } = this, { alt: r5, poster: s6, iosSrc: a4 } = i6;
      if (t5 != null) {
        const i7 = [{ "@type": "MediaObject", contentUrl: t5, encodingFormat: ((e8 = t5.split(".").pop()) === null || e8 === void 0 ? void 0 : e8.toLowerCase()) === "gltf" ? "model/gltf+json" : "model/gltf-binary" }];
        a4 && i7.push({ "@type": "MediaObject", contentUrl: a4, encodingFormat: "model/vnd.usdz+zip" });
        const o7 = { "@context": "http://schema.org/", "@type": "3DModel", image: s6 != null ? s6 : void 0, name: r5 != null ? r5 : void 0, encoding: i7 };
        n8.textContent = JSON.stringify(o7), document.head.appendChild(n8);
      } else
        n8.parentElement != null && n8.parentElement.removeChild(n8);
    }
  };
  var zu = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var Hu = Symbol("currentEnvironmentMap");
  var Vu = Symbol("applyEnvironmentMap");
  var Gu = Symbol("updateEnvironment");
  var Wu = Symbol("cancelEnvironmentUpdate");
  var ju = Symbol("onPreload");
  var qu = class {
    constructor(t5, e8, n8, i6, r5) {
      this.xrLight = t5, this.renderer = e8, this.lightProbe = n8, this.xrWebGLBinding = null, this.estimationStartCallback = r5, this.frameCallback = this.onXRFrame.bind(this);
      const s6 = e8.xr.getSession();
      if (i6 && "XRWebGLBinding" in window) {
        const n9 = new Xe(16);
        t5.environment = n9.texture;
        const i7 = e8.getContext();
        switch (s6.preferredReflectionFormat) {
          case "srgba8":
            i7.getExtension("EXT_sRGB");
            break;
          case "rgba16f":
            i7.getExtension("OES_texture_half_float");
        }
        this.xrWebGLBinding = new XRWebGLBinding(s6, i7), this.lightProbe.addEventListener("reflectionchange", () => {
          this.updateReflection();
        });
      }
      s6.requestAnimationFrame(this.frameCallback);
    }
    updateReflection() {
      const t5 = this.renderer.properties.get(this.xrLight.environment);
      if (t5) {
        const e8 = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
        e8 && (t5.__webglTexture = e8, this.xrLight.environment.needsPMREMUpdate = true);
      }
    }
    onXRFrame(t5, e8) {
      if (!this.xrLight)
        return;
      e8.session.requestAnimationFrame(this.frameCallback);
      const n8 = e8.getLightEstimate(this.lightProbe);
      if (n8) {
        this.xrLight.lightProbe.sh.fromArray(n8.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
        const t6 = Math.max(1, Math.max(n8.primaryLightIntensity.x, Math.max(n8.primaryLightIntensity.y, n8.primaryLightIntensity.z)));
        this.xrLight.directionalLight.color.setRGB(n8.primaryLightIntensity.x / t6, n8.primaryLightIntensity.y / t6, n8.primaryLightIntensity.z / t6), this.xrLight.directionalLight.intensity = t6, this.xrLight.directionalLight.position.copy(n8.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null);
      }
    }
    dispose() {
      this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null;
    }
  };
  var Xu = class extends Rr {
    constructor(t5, e8 = true) {
      super(), this.lightProbe = new Po(), this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new Co(), this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
      let n8 = null, i6 = false;
      t5.xr.addEventListener("sessionstart", () => {
        const r5 = t5.xr.getSession();
        "requestLightProbe" in r5 && r5.requestLightProbe({ reflectionFormat: r5.preferredReflectionFormat }).then((r6) => {
          n8 = new qu(this, t5, r6, e8, () => {
            i6 = true, this.dispatchEvent({ type: "estimationstart" });
          });
        });
      }), t5.xr.addEventListener("sessionend", () => {
        n8 && (n8.dispose(), n8 = null), i6 && this.dispatchEvent({ type: "estimationend" });
      }), this.dispose = () => {
        n8 && (n8.dispose(), n8 = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null;
      };
    }
  };
  var $u = Math.PI / 24;
  var Yu = new g2();
  var Ju = (t5, e8, n8) => {
    let i6 = e8 > 0 ? n8 > 0 ? 0 : -Math.PI / 2 : n8 > 0 ? Math.PI / 2 : Math.PI;
    for (let r5 = 0; r5 <= 12; ++r5)
      t5.push(e8 + 0.17 * Math.cos(i6), n8 + 0.17 * Math.sin(i6), 0, e8 + 0.2 * Math.cos(i6), n8 + 0.2 * Math.sin(i6), 0), i6 += $u;
  };
  var Ku = class extends Fe {
    constructor(t5, e8) {
      const n8 = new ye(), i6 = [], r5 = [], { size: s6, boundingBox: a4 } = t5, o7 = s6.x / 2, l6 = (e8 === "back" ? s6.y : s6.z) / 2;
      Ju(r5, o7, l6), Ju(r5, -o7, l6), Ju(r5, -o7, -l6), Ju(r5, o7, -l6);
      const h4 = r5.length / 3;
      for (let t6 = 0; t6 < h4 - 2; t6 += 2)
        i6.push(t6, t6 + 1, t6 + 3, t6, t6 + 3, t6 + 2);
      const c3 = h4 - 2;
      i6.push(c3, c3 + 1, 1, c3, 1, 0), n8.setAttribute("position", new ce(r5, 3)), n8.setIndex(i6), super(n8), this.side = e8;
      const u3 = this.material;
      switch (u3.side = 0, u3.transparent = true, u3.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new du(), this.hitPlane = new Fe(new rn(2 * (o7 + 0.2), 2 * (l6 + 0.2))), this.hitPlane.visible = false, this.add(this.hitPlane), a4.getCenter(this.position), e8) {
        case "bottom":
          this.rotateX(-Math.PI / 2), this.shadowHeight = a4.min.y, this.position.y = this.shadowHeight;
          break;
        case "back":
          this.shadowHeight = a4.min.z, this.position.z = this.shadowHeight;
      }
      t5.target.add(this), this.offsetHeight = 0;
    }
    getHit(t5, e8, n8) {
      Yu.set(e8, -n8), this.hitPlane.visible = true;
      const i6 = t5.positionAndNormalFromPoint(Yu, this.hitPlane);
      return this.hitPlane.visible = false, i6 == null ? null : i6.position;
    }
    getExpandedHit(t5, e8, n8) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const i6 = this.getHit(t5, e8, n8);
      return this.hitPlane.scale.set(1, 1, 1), i6;
    }
    set offsetHeight(t5) {
      t5 -= 1e-3, this.side === "back" ? this.position.z = this.shadowHeight + t5 : this.position.y = this.shadowHeight + t5;
    }
    get offsetHeight() {
      return this.side === "back" ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }
    set show(t5) {
      this.goalOpacity = t5 ? 0.75 : 0;
    }
    updateOpacity(t5) {
      const e8 = this.material;
      e8.opacity = this.opacityDamper.update(e8.opacity, this.goalOpacity, t5, 1), this.visible = e8.opacity > 0;
    }
    dispose() {
      var t5;
      const { geometry: e8, material: n8 } = this.hitPlane;
      e8.dispose(), n8.dispose(), this.geometry.dispose(), this.material.dispose(), (t5 = this.parent) === null || t5 === void 0 || t5.remove(this);
    }
  };
  var Zu = "not-presenting";
  var Qu = "session-started";
  var td = "object-placed";
  var ed = "failed";
  var nd = "tracking";
  var id = "not-tracking";
  var rd = new V2();
  var sd = new xt();
  var ad = new V2();
  var od = new We(45, 1, 0.1, 100);
  var ld = class extends i5 {
    constructor(t5) {
      super(), this.renderer = t5, this.currentSession = null, this.placeOnWall = false, this.placementBox = null, this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this.oldEnvironment = null, this.frame = null, this.initialHitSource = null, this.transientHitTestSource = null, this.inputSource = null, this._presentedScene = null, this.resolveCleanup = null, this.exitWebXRButtonContainer = null, this.overlay = null, this.xrLight = null, this.tracking = true, this.frames = 0, this.initialized = false, this.oldTarget = new V2(), this.placementComplete = false, this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.lastDragPosition = new V2(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new V2(), this.goalYaw = 0, this.goalScale = 1, this.xDamper = new du(), this.yDamper = new du(), this.zDamper = new du(), this.yawDamper = new du(), this.scaleDamper = new du(), this.onExitWebXRButtonContainerClick = () => this.stopPresenting(), this.onUpdateScene = () => {
        this.placementBox != null && this.isPresenting && (this.placementBox.dispose(), this.placementBox = new Ku(this.presentedScene, this.placeOnWall ? "back" : "bottom"));
      }, this.onSelectStart = (t6) => {
        const e8 = this.transientHitTestSource;
        if (e8 == null)
          return;
        const n8 = this.frame.getHitTestResultsForTransientInput(e8), i6 = this.presentedScene, r5 = this.placementBox;
        if (n8.length === 1) {
          this.inputSource = t6.inputSource;
          const { axes: e9 } = this.inputSource.gamepad, n9 = r5.getHit(this.presentedScene, e9[0], e9[1]);
          r5.show = true, n9 != null ? (this.isTranslating = true, this.lastDragPosition.copy(n9)) : this.placeOnWall === false && (this.isRotating = true, this.lastAngle = 1.5 * e9[0]);
        } else if (n8.length === 2) {
          r5.show = true, this.isTwoFingering = true;
          const { separation: t7 } = this.fingerPolar(n8);
          this.firstRatio = t7 / i6.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = false;
      }, this.threeRenderer = t5.threeRenderer, this.threeRenderer.xr.enabled = true;
    }
    async resolveARSession() {
      su();
      const t5 = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay", "light-estimation"], domOverlay: { root: this.overlay } });
      return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(t5), this.threeRenderer.xr.cameraAutoUpdate = false, t5;
    }
    get presentedScene() {
      return this._presentedScene;
    }
    async supportsPresentation() {
      try {
        return su(), await navigator.xr.isSessionSupported("immersive-ar");
      } catch (t5) {
        return console.warn("Request to present in WebXR denied:"), console.warn(t5), console.warn("Falling back to next ar-mode"), false;
      }
    }
    async present(t5, e8 = false) {
      this.isPresenting && console.warn("Cannot present while a model is already presenting");
      let n8 = new Promise((t6, e9) => {
        requestAnimationFrame(() => t6());
      });
      t5.setHotspotsVisibility(false), t5.queueRender(), await n8, this._presentedScene = t5, this.overlay = t5.element.shadowRoot.querySelector("div.default"), e8 === true && (this.xrLight = new Xu(this.threeRenderer), this.xrLight.addEventListener("estimationstart", () => {
        if (!this.isPresenting || this.xrLight == null)
          return;
        const t6 = this.presentedScene;
        t6.add(this.xrLight), this.oldEnvironment = t6.environment, t6.environment = this.xrLight.environment;
      }));
      const i6 = await this.resolveARSession();
      i6.addEventListener("end", () => {
        this.postSessionCleanup();
      }, { once: true });
      const r5 = t5.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
      r5.classList.add("enabled"), r5.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = r5;
      const s6 = await i6.requestReferenceSpace("viewer");
      this.tracking = true, this.frames = 0, this.initialized = false, this.turntableRotation = t5.yaw, this.goalYaw = t5.yaw, this.goalScale = 1, this.oldBackground = t5.background, t5.background = null, this.oldShadowIntensity = t5.shadowIntensity, t5.setShadowIntensity(0.01), this.oldTarget.copy(t5.getTarget()), t5.addEventListener("model-load", this.onUpdateScene);
      const a4 = 20 * Math.PI / 180, o7 = this.placeOnWall === true ? void 0 : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(a4), z: -Math.cos(a4) });
      i6.requestHitTestSource({ space: s6, offsetRay: o7 }).then((t6) => {
        this.initialHitSource = t6;
      }), this.currentSession = i6, this.placementBox = new Ku(t5, this.placeOnWall ? "back" : "bottom"), this.placementComplete = false, this.lastTick = performance.now(), this.dispatchEvent({ type: "status", status: Qu });
    }
    async stopPresenting() {
      if (!this.isPresenting)
        return;
      const t5 = new Promise((t6) => {
        this.resolveCleanup = t6;
      });
      try {
        await this.currentSession.end(), await t5;
      } catch (t6) {
        console.warn("Error while trying to end WebXR AR session"), console.warn(t6), this.postSessionCleanup();
      }
    }
    get isPresenting() {
      return this.presentedScene != null;
    }
    get target() {
      return this.oldTarget;
    }
    updateTarget() {
      const t5 = this.presentedScene;
      if (t5 != null) {
        const e8 = t5.getTarget();
        this.oldTarget.copy(e8), this.placeOnWall ? e8.z = t5.boundingBox.min.z : e8.y = t5.boundingBox.min.y, t5.setTarget(e8.x, e8.y, e8.z);
      }
    }
    postSessionCleanup() {
      const t5 = this.currentSession;
      t5 != null && (t5.removeEventListener("selectstart", this.onSelectStart), t5.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
      const e8 = this.presentedScene;
      if (e8 != null) {
        const { element: t6 } = e8;
        this.xrLight != null && (e8.remove(this.xrLight), this.oldEnvironment != null && (e8.environment = this.oldEnvironment, this.oldEnvironment = null), this.xrLight.dispose(), this.xrLight = null), e8.position.set(0, 0, 0), e8.scale.set(1, 1, 1), e8.setShadowOffset(0);
        const n9 = this.turntableRotation;
        n9 != null && (e8.yaw = n9);
        const i7 = this.oldShadowIntensity;
        i7 != null && e8.setShadowIntensity(i7);
        const r6 = this.oldBackground;
        r6 != null && (e8.background = r6);
        const s6 = this.oldTarget;
        e8.setTarget(s6.x, s6.y, s6.z), e8.xrCamera = null, e8.removeEventListener("model-load", this.onUpdateScene), e8.orientHotspots(0), t6.requestUpdate("cameraTarget"), t6.requestUpdate("maxCameraOrbit"), t6[Tp](t6.getBoundingClientRect());
      }
      this.renderer.height = 0;
      const n8 = this.exitWebXRButtonContainer;
      n8 != null && (n8.classList.remove("enabled"), n8.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
      const i6 = this.transientHitTestSource;
      i6 != null && (i6.cancel(), this.transientHitTestSource = null);
      const r5 = this.initialHitSource;
      r5 != null && (r5.cancel(), this.initialHitSource = null), this.placementBox != null && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this._presentedScene = null, this.frame = null, this.inputSource = null, this.overlay = null, this.resolveCleanup != null && this.resolveCleanup(), this.dispatchEvent({ type: "status", status: Zu });
    }
    updateView(t5) {
      const e8 = this.presentedScene, n8 = this.threeRenderer.xr;
      n8.updateCamera(od), e8.xrCamera = n8.getCamera();
      const { elements: i6 } = e8.getCamera().matrixWorld;
      if (e8.orientHotspots(Math.atan2(i6[1], i6[5])), this.initialized || (this.placeInitially(), this.initialized = true), t5.requestViewportScale && t5.recommendedViewportScale) {
        const e9 = t5.recommendedViewportScale;
        t5.requestViewportScale(Math.max(e9, 0.25));
      }
      const r5 = this.currentSession.renderState.baseLayer.getViewport(t5);
      this.threeRenderer.setViewport(r5.x, r5.y, r5.width, r5.height);
    }
    placeInitially() {
      const t5 = this.presentedScene, { position: e8, element: n8 } = t5, i6 = t5.getCamera(), { width: r5, height: s6 } = this.overlay.getBoundingClientRect();
      t5.setSize(r5, s6), i6.projectionMatrixInverse.copy(i6.projectionMatrix).invert();
      const { theta: a4, radius: o7 } = n8.getCameraOrbit(), l6 = i6.getWorldDirection(rd);
      t5.yaw = Math.atan2(-l6.x, -l6.z) - a4, this.goalYaw = t5.yaw, e8.copy(i6.position).add(l6.multiplyScalar(o7)), this.updateTarget();
      const h4 = t5.getTarget();
      e8.add(h4).sub(this.oldTarget), this.goalPosition.copy(e8), t5.setHotspotsVisibility(true);
      const { session: c3 } = this.frame;
      c3.addEventListener("selectstart", this.onSelectStart), c3.addEventListener("selectend", this.onSelectEnd), c3.requestHitTestSourceForTransientInput({ profile: "generic-touchscreen" }).then((t6) => {
        this.transientHitTestSource = t6;
      });
    }
    getTouchLocation() {
      const { axes: t5 } = this.inputSource.gamepad;
      let e8 = this.placementBox.getExpandedHit(this.presentedScene, t5[0], t5[1]);
      return e8 != null && (rd.copy(e8).sub(this.presentedScene.getCamera().position), rd.length() > 10) ? null : e8;
    }
    getHitPoint(t5) {
      const e8 = this.threeRenderer.xr.getReferenceSpace(), n8 = t5.getPose(e8);
      if (n8 == null)
        return null;
      const i6 = sd.fromArray(n8.transform.matrix);
      return this.placeOnWall === true && (this.goalYaw = Math.atan2(i6.elements[4], i6.elements[6])), i6.elements[5] > 0.75 !== this.placeOnWall ? ad.setFromMatrixPosition(i6) : null;
    }
    moveToFloor(t5) {
      const e8 = this.initialHitSource;
      if (e8 == null)
        return;
      const n8 = t5.getHitTestResults(e8);
      if (n8.length == 0)
        return;
      const i6 = n8[0], r5 = this.getHitPoint(i6);
      r5 != null && (this.placementBox.show = true, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(r5) : this.goalPosition.y = r5.y), e8.cancel(), this.initialHitSource = null, this.dispatchEvent({ type: "status", status: td }));
    }
    fingerPolar(t5) {
      const e8 = t5[0].inputSource.gamepad.axes, n8 = t5[1].inputSource.gamepad.axes, i6 = n8[0] - e8[0], r5 = n8[1] - e8[1], s6 = Math.atan2(r5, i6);
      let a4 = this.lastAngle - s6;
      return a4 > Math.PI ? a4 -= 2 * Math.PI : a4 < -Math.PI && (a4 += 2 * Math.PI), this.lastAngle = s6, { separation: Math.sqrt(i6 * i6 + r5 * r5), deltaYaw: a4 };
    }
    processInput(t5) {
      const e8 = this.transientHitTestSource;
      if (e8 == null)
        return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
        return;
      const n8 = t5.getHitTestResultsForTransientInput(e8), i6 = this.presentedScene, r5 = i6.scale.x;
      if (this.isTwoFingering)
        if (n8.length < 2)
          this.isTwoFingering = false;
        else {
          const { separation: t6, deltaYaw: e9 } = this.fingerPolar(n8);
          if (this.placeOnWall === false && (this.goalYaw += e9), i6.canScale) {
            const e10 = t6 / this.firstRatio;
            this.goalScale = e10 < 1.3 && e10 > 0.7692307692307692 ? 1 : e10;
          }
        }
      else if (n8.length !== 2)
        if (this.isRotating) {
          const t6 = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += t6 - this.lastAngle, this.lastAngle = t6;
        } else
          this.isTranslating && n8.forEach((t6) => {
            if (t6.inputSource !== this.inputSource)
              return;
            let e9 = null;
            if (t6.results.length > 0 && (e9 = this.getHitPoint(t6.results[0])), e9 == null && (e9 = this.getTouchLocation()), e9 != null) {
              if (this.goalPosition.sub(this.lastDragPosition), this.placeOnWall === false) {
                const t7 = e9.y - this.lastDragPosition.y;
                if (t7 < 0) {
                  this.placementBox.offsetHeight = t7 / r5, this.presentedScene.setShadowOffset(t7);
                  const n9 = rd.copy(i6.getCamera().position), s6 = -t7 / (n9.y - e9.y);
                  n9.multiplyScalar(s6), e9.multiplyScalar(1 - s6).add(n9);
                }
              }
              this.goalPosition.add(e9), this.lastDragPosition.copy(e9);
            }
          });
      else {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = true;
        const { separation: t6 } = this.fingerPolar(n8);
        this.firstRatio = t6 / r5;
      }
    }
    moveScene(t5) {
      const e8 = this.presentedScene, { position: n8, yaw: i6 } = e8, r5 = e8.boundingSphere.radius, s6 = this.goalPosition, a4 = e8.scale.x, o7 = this.placementBox;
      if (!s6.equals(n8) || this.goalScale !== a4) {
        let { x: i7, y: l6, z: h4 } = n8;
        i7 = this.xDamper.update(i7, s6.x, t5, r5), l6 = this.yDamper.update(l6, s6.y, t5, r5), h4 = this.zDamper.update(h4, s6.z, t5, r5), n8.set(i7, l6, h4);
        const c3 = this.scaleDamper.update(a4, this.goalScale, t5, 1);
        if (e8.scale.set(c3, c3, c3), !this.isTranslating) {
          const t6 = s6.y - l6;
          this.placementComplete && this.placeOnWall === false ? (o7.offsetHeight = t6 / c3, e8.setShadowOffset(t6)) : t6 === 0 && (this.placementComplete = true, o7.show = false, e8.setShadowIntensity(0.8));
        }
      }
      o7.updateOpacity(t5), e8.updateTarget(t5), e8.yaw = this.yawDamper.update(i6, this.goalYaw, t5, Math.PI);
    }
    onWebXRFrame(t5, e8) {
      this.frame = e8, ++this.frames;
      const n8 = this.threeRenderer.xr.getReferenceSpace(), i6 = e8.getViewerPose(n8);
      i6 == null && this.tracking === true && this.frames > 30 && (this.tracking = false, this.dispatchEvent({ type: "tracking", status: id }));
      const r5 = this.presentedScene;
      if (i6 == null || r5 == null || !r5.element[Pp]())
        return void this.threeRenderer.clear();
      this.tracking === false && (this.tracking = true, this.dispatchEvent({ type: "tracking", status: nd }));
      let s6 = true;
      for (const n9 of i6.views) {
        if (this.updateView(n9), s6) {
          this.moveToFloor(e8), this.processInput(e8);
          const n10 = t5 - this.lastTick;
          this.moveScene(n10), this.renderer.preRender(r5, t5, n10), this.lastTick = t5, r5.renderShadow(this.threeRenderer);
        }
        this.threeRenderer.render(r5, r5.getCamera()), s6 = false;
      }
    }
  };
  var hd = class {
    constructor(t5) {
      t5.threeRenderer.debug = { checkShaderErrors: true }, Promise.resolve().then(() => {
        self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", { detail: { renderer: t5, THREE: { ShaderMaterial: Ve, Texture: F, Mesh: Fe, Scene: Nr, PlaneBufferGeometry: rn, OrthographicCamera: mn, WebGLRenderTarget: k2 } } }));
      });
    }
    addScene(t5) {
      self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", { detail: { scene: t5 } }));
    }
    removeScene(t5) {
      self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", { detail: { scene: t5 } }));
    }
  };
  function cd(t5) {
    const e8 = /* @__PURE__ */ new Map(), n8 = /* @__PURE__ */ new Map(), i6 = t5.clone();
    return ud(t5, i6, function(t6, i7) {
      e8.set(i7, t6), n8.set(t6, i7);
    }), i6.traverse(function(t6) {
      if (!t6.isSkinnedMesh)
        return;
      const i7 = t6, r5 = e8.get(t6), s6 = r5.skeleton.bones;
      i7.skeleton = r5.skeleton.clone(), i7.bindMatrix.copy(r5.bindMatrix), i7.skeleton.bones = s6.map(function(t7) {
        return n8.get(t7);
      }), i7.bind(i7.skeleton, i7.bindMatrix);
    }), i6;
  }
  function ud(t5, e8, n8) {
    n8(t5, e8);
    for (let i6 = 0; i6 < t5.children.length; i6++)
      ud(t5.children[i6], e8.children[i6], n8);
  }
  var dd = Symbol("prepared");
  var pd = Symbol("prepare");
  var md = Symbol("preparedGLTF");
  var fd = Symbol("clone");
  var gd = class {
    constructor(t5) {
      this[md] = t5;
    }
    static prepare(t5) {
      if (t5.scene == null)
        throw new Error("Model does not have a scene");
      if (t5[dd])
        return t5;
      const e8 = this[pd](t5);
      return e8[dd] = true, e8;
    }
    static [pd](t5) {
      const { scene: e8 } = t5, n8 = [e8];
      return Object.assign(Object.assign({}, t5), { scene: e8, scenes: n8 });
    }
    get parser() {
      return this[md].parser;
    }
    get animations() {
      return this[md].animations;
    }
    get scene() {
      return this[md].scene;
    }
    get scenes() {
      return this[md].scenes;
    }
    get cameras() {
      return this[md].cameras;
    }
    get asset() {
      return this[md].asset;
    }
    get userData() {
      return this[md].userData;
    }
    clone() {
      return new (0, this.constructor)(this[fd]());
    }
    dispose() {
      this.scenes.forEach((t5) => {
        t5.traverse((t6) => {
          if (!t6.isMesh)
            return;
          const e8 = t6;
          (Array.isArray(e8.material) ? e8.material : [e8.material]).forEach((t7) => {
            for (const e9 in t7) {
              const n8 = t7[e9];
              if (n8 instanceof F) {
                const t8 = n8.source.data;
                t8 instanceof ImageBitmap && t8.close(), n8.dispose();
              }
            }
            t7.dispose();
          }), e8.geometry.dispose();
        });
      });
    }
    [fd]() {
      const t5 = this[md], e8 = cd(this.scene);
      vd(e8, this.scene);
      const n8 = [e8], i6 = t5.userData ? Object.assign({}, t5.userData) : {};
      return Object.assign(Object.assign({}, t5), { scene: e8, scenes: n8, userData: i6 });
    }
  };
  var vd = (t5, e8) => {
    yd(t5, e8, (t6, e9) => {
      e9.userData.variantMaterials !== void 0 && (t6.userData.variantMaterials = new Map(e9.userData.variantMaterials)), e9.userData.variantData !== void 0 && (t6.userData.variantData = e9.userData.variantData), e9.userData.originalMaterial !== void 0 && (t6.userData.originalMaterial = e9.userData.originalMaterial);
    });
  };
  var yd = (t5, e8, n8) => {
    n8(t5, e8);
    for (let i6 = 0; i6 < t5.children.length; i6++)
      yd(t5.children[i6], e8.children[i6], n8);
  };
  var xd = Symbol("threeGLTF");
  var bd = Symbol("gltf");
  var _d = Symbol("gltfElementMap");
  var wd = Symbol("threeObjectMap");
  var Md = Symbol("parallelTraverseThreeScene");
  var Sd = Symbol("correlateOriginalThreeGLTF");
  var Td = Symbol("correlateCloneThreeGLTF");
  var Ed = class {
    constructor(t5, e8, n8, i6) {
      this[xd] = t5, this[bd] = e8, this[_d] = i6, this[wd] = n8;
    }
    static from(t5, e8) {
      return e8 != null ? this[Td](t5, e8) : this[Sd](t5);
    }
    static [Sd](t5) {
      const e8 = t5.parser.json, n8 = t5.parser.associations, i6 = /* @__PURE__ */ new Map(), r5 = { name: "Default" }, s6 = { type: "materials", index: -1 };
      for (const t6 of n8.keys())
        t6 instanceof ie && n8.get(t6) == null && (s6.index < 0 && (e8.materials == null && (e8.materials = []), s6.index = e8.materials.length, e8.materials.push(r5)), t6.name = r5.name, n8.set(t6, { materials: s6.index }));
      for (const [t6, r6] of n8) {
        if (r6) {
          const e9 = t6;
          e9.userData = e9.userData || {}, e9.userData.associations = r6;
        }
        for (const n9 in r6)
          if (n9 != null && n9 !== "primitives") {
            const s7 = n9, a4 = (e8[s7] || [])[r6[s7]];
            if (a4 == null)
              continue;
            let o7 = i6.get(a4);
            o7 == null && (o7 = /* @__PURE__ */ new Set(), i6.set(a4, o7)), o7.add(t6);
          }
      }
      return new Ed(t5, e8, n8, i6);
    }
    static [Td](t5, e8) {
      const n8 = e8.threeGLTF, i6 = e8.gltf, r5 = JSON.parse(JSON.stringify(i6)), s6 = /* @__PURE__ */ new Map(), a4 = /* @__PURE__ */ new Map();
      for (let i7 = 0; i7 < n8.scenes.length; i7++)
        this[Md](n8.scenes[i7], t5.scenes[i7], (t6, n9) => {
          const i8 = e8.threeObjectMap.get(t6);
          if (i8 != null) {
            for (const t7 in i8)
              if (t7 != null && t7 !== "primitives") {
                const e9 = t7, o7 = i8[e9], l6 = r5[e9][o7], h4 = s6.get(n9) || {};
                h4[e9] = o7, s6.set(n9, h4);
                const c3 = a4.get(l6) || /* @__PURE__ */ new Set();
                c3.add(n9), a4.set(l6, c3);
              }
          }
        });
      return new Ed(t5, r5, s6, a4);
    }
    static [Md](t5, e8, n8) {
      const i6 = (t6, e9) => {
        if (n8(t6, e9), t6.isObject3D) {
          if (t6.isMesh)
            if (Array.isArray(t6.material))
              for (let n9 = 0; n9 < t6.material.length; ++n9)
                i6(t6.material[n9], e9.material[n9]);
            else
              i6(t6.material, e9.material);
          for (let n9 = 0; n9 < t6.children.length; ++n9)
            i6(t6.children[n9], e9.children[n9]);
        }
      };
      i6(t5, e8);
    }
    get threeGLTF() {
      return this[xd];
    }
    get gltf() {
      return this[bd];
    }
    get gltfElementMap() {
      return this[_d];
    }
    get threeObjectMap() {
      return this[wd];
    }
  };
  var Ad = Symbol("correlatedSceneGraph");
  var Rd = class extends gd {
    static [pd](t5) {
      const e8 = super[pd](t5);
      e8[Ad] == null && (e8[Ad] = Ed.from(e8));
      const { scene: n8 } = e8, i6 = new ct(void 0, 1 / 0);
      return n8.traverse((t6) => {
        t6.renderOrder = 1e3, t6.frustumCulled = false, t6.name || (t6.name = t6.uuid);
        const n9 = t6;
        if (n9.isMesh) {
          const { geometry: t7 } = n9;
          n9.castShadow = true, n9.isSkinnedMesh && (t7.boundingSphere = i6, t7.boundingBox = null);
          const r5 = n9.material;
          if (r5.isMeshBasicMaterial === true && (r5.toneMapped = false), r5.shadowSide = 0, r5.aoMap) {
            const { gltf: n10, threeObjectMap: i7 } = e8[Ad], s6 = i7.get(r5);
            if (n10.materials != null && s6 != null && s6.materials != null) {
              const e9 = n10.materials[s6.materials];
              e9.occlusionTexture && e9.occlusionTexture.texCoord === 0 && t7.attributes.uv != null && t7.setAttribute("uv2", t7.attributes.uv);
            }
          }
        }
      }), e8;
    }
    get correlatedSceneGraph() {
      return this[md][Ad];
    }
    [fd]() {
      const t5 = super[fd](), e8 = /* @__PURE__ */ new Map();
      return t5.scene.traverse((t6) => {
        if (t6.isMesh) {
          const n8 = t6, i6 = n8.material;
          if (i6 != null) {
            if (e8.has(i6.uuid))
              return void (n8.material = e8.get(i6.uuid));
            n8.material = i6.clone(), e8.set(i6.uuid, n8.material);
          }
        }
      }), t5[Ad] = Ed.from(t5, this.correlatedSceneGraph), t5;
    }
  };
  var Cd = class extends Nr {
    constructor() {
      super(), this.position.y = -3.5;
      const t5 = new ke();
      t5.deleteAttribute("uv");
      const e8 = new Fa({ metalness: 0, side: 1 }), n8 = new Fa({ metalness: 0 }), i6 = new Ao(16777215, 500, 28, 2);
      i6.position.set(0.418, 16.199, 0.3), this.add(i6);
      const r5 = new Fe(t5, e8);
      r5.position.set(-0.757, 13.219, 0.717), r5.scale.set(31.713, 28.305, 28.591), this.add(r5);
      const s6 = new Fe(t5, n8);
      s6.position.set(-10.906, 2.009, 1.846), s6.rotation.set(0, -0.195, 0), s6.scale.set(2.328, 7.905, 4.651), this.add(s6);
      const a4 = new Fe(t5, n8);
      a4.position.set(-5.607, -0.754, -0.758), a4.rotation.set(0, 0.994, 0), a4.scale.set(1.97, 1.534, 3.955), this.add(a4);
      const o7 = new Fe(t5, n8);
      o7.position.set(6.167, 0.857, 7.803), o7.rotation.set(0, 0.561, 0), o7.scale.set(3.927, 6.285, 3.687), this.add(o7);
      const l6 = new Fe(t5, n8);
      l6.position.set(-2.017, 0.018, 6.124), l6.rotation.set(0, 0.333, 0), l6.scale.set(2.002, 4.566, 2.064), this.add(l6);
      const h4 = new Fe(t5, n8);
      h4.position.set(2.291, -0.756, -2.621), h4.rotation.set(0, -0.286, 0), h4.scale.set(1.546, 1.552, 1.496), this.add(h4);
      const c3 = new Fe(t5, n8);
      c3.position.set(-2.193, -0.369, -5.547), c3.rotation.set(0, 0.516, 0), c3.scale.set(3.875, 3.487, 2.986), this.add(c3);
      const u3 = new Fe(t5, this.createAreaLightMaterial(50));
      u3.position.set(-16.116, 14.37, 8.208), u3.scale.set(0.1, 2.428, 2.739), this.add(u3);
      const d3 = new Fe(t5, this.createAreaLightMaterial(50));
      d3.position.set(-16.109, 18.021, -8.207), d3.scale.set(0.1, 2.425, 2.751), this.add(d3);
      const p3 = new Fe(t5, this.createAreaLightMaterial(17));
      p3.position.set(14.904, 12.198, -1.832), p3.scale.set(0.15, 4.265, 6.331), this.add(p3);
      const m3 = new Fe(t5, this.createAreaLightMaterial(43));
      m3.position.set(-0.462, 8.89, 14.52), m3.scale.set(4.38, 5.441, 0.088), this.add(m3);
      const f3 = new Fe(t5, this.createAreaLightMaterial(20));
      f3.position.set(3.235, 11.486, -12.541), f3.scale.set(2.5, 2, 0.1), this.add(f3);
      const g3 = new Fe(t5, this.createAreaLightMaterial(100));
      g3.position.set(0, 20, 0), g3.scale.set(1, 0.1, 1), this.add(g3);
    }
    createAreaLightMaterial(t5) {
      const e8 = new re();
      return e8.color.setScalar(t5), e8;
    }
  };
  var Ld = class extends Nr {
    constructor() {
      super(), this.position.y = -3.5;
      const t5 = new ke();
      t5.deleteAttribute("uv");
      const e8 = new Fa({ metalness: 0, side: 1 }), n8 = new Fa({ metalness: 0 }), i6 = new Ao(16777215, 400, 28, 2);
      i6.position.set(0.5, 14, 0.5), this.add(i6);
      const r5 = new Fe(t5, e8);
      r5.position.set(0, 13.2, 0), r5.scale.set(31.5, 28.5, 31.5), this.add(r5);
      const s6 = new Fe(t5, n8);
      s6.position.set(-10.906, -1, 1.846), s6.rotation.set(0, -0.195, 0), s6.scale.set(2.328, 7.905, 4.651), this.add(s6);
      const a4 = new Fe(t5, n8);
      a4.position.set(-5.607, -0.754, -0.758), a4.rotation.set(0, 0.994, 0), a4.scale.set(1.97, 1.534, 3.955), this.add(a4);
      const o7 = new Fe(t5, n8);
      o7.position.set(6.167, -0.16, 7.803), o7.rotation.set(0, 0.561, 0), o7.scale.set(3.927, 6.285, 3.687), this.add(o7);
      const l6 = new Fe(t5, n8);
      l6.position.set(-2.017, 0.018, 6.124), l6.rotation.set(0, 0.333, 0), l6.scale.set(2.002, 4.566, 2.064), this.add(l6);
      const h4 = new Fe(t5, n8);
      h4.position.set(2.291, -0.756, -2.621), h4.rotation.set(0, -0.286, 0), h4.scale.set(1.546, 1.552, 1.496), this.add(h4);
      const c3 = new Fe(t5, n8);
      c3.position.set(-2.193, -0.369, -5.547), c3.rotation.set(0, 0.516, 0), c3.scale.set(3.875, 3.487, 2.986), this.add(c3);
      const u3 = new Fe(t5, this.createAreaLightMaterial(80));
      u3.position.set(-14, 10, 8), u3.scale.set(0.1, 2.5, 2.5), this.add(u3);
      const d3 = new Fe(t5, this.createAreaLightMaterial(80));
      d3.position.set(-14, 14, -4), d3.scale.set(0.1, 2.5, 2.5), this.add(d3);
      const p3 = new Fe(t5, this.createAreaLightMaterial(23));
      p3.position.set(14, 12, 0), p3.scale.set(0.1, 5, 5), this.add(p3);
      const m3 = new Fe(t5, this.createAreaLightMaterial(16));
      m3.position.set(0, 9, 14), m3.scale.set(5, 5, 0.1), this.add(m3);
      const f3 = new Fe(t5, this.createAreaLightMaterial(80));
      f3.position.set(7, 8, -14), f3.scale.set(2.5, 2.5, 0.1), this.add(f3);
      const g3 = new Fe(t5, this.createAreaLightMaterial(80));
      g3.position.set(-7, 16, -14), g3.scale.set(2.5, 2.5, 0.1), this.add(g3);
      const v3 = new Fe(t5, this.createAreaLightMaterial(1));
      v3.position.set(0, 20, 0), v3.scale.set(0.1, 0.1, 0.1), this.add(v3);
    }
    createAreaLightMaterial(t5) {
      const e8 = new re();
      return e8.color.setScalar(t5), e8;
    }
  };
  var Pd = /\.hdr(\.js)?$/;
  var Dd = new fo();
  var Id = new class extends mo {
    constructor(t5) {
      super(t5), this.type = 1016;
    }
    parse(t5) {
      const e8 = function(t6, e9) {
        switch (t6) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (e9 || ""));
            break;
          case 2:
            console.error("THREE.RGBELoader Write Error: " + (e9 || ""));
            break;
          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (e9 || ""));
            break;
          default:
            console.error("THREE.RGBELoader: Error: " + (e9 || ""));
        }
        return -1;
      }, n8 = function(t6, e9, n9) {
        e9 = e9 || 1024;
        let i7 = t6.pos, r6 = -1, s7 = 0, a5 = "", o7 = String.fromCharCode.apply(null, new Uint16Array(t6.subarray(i7, i7 + 128)));
        for (; 0 > (r6 = o7.indexOf("\n")) && s7 < e9 && i7 < t6.byteLength; )
          a5 += o7, s7 += o7.length, i7 += 128, o7 += String.fromCharCode.apply(null, new Uint16Array(t6.subarray(i7, i7 + 128)));
        return -1 < r6 && (n9 !== false && (t6.pos += s7 + r6 + 1), a5 + o7.slice(0, r6));
      }, i6 = function(t6, e9, n9, i7) {
        const r6 = t6[e9 + 3], s7 = Math.pow(2, r6 - 128) / 255;
        n9[i7 + 0] = t6[e9 + 0] * s7, n9[i7 + 1] = t6[e9 + 1] * s7, n9[i7 + 2] = t6[e9 + 2] * s7, n9[i7 + 3] = 1;
      }, r5 = function(t6, e9, n9, i7) {
        const r6 = t6[e9 + 3], s7 = Math.pow(2, r6 - 128) / 255;
        n9[i7 + 0] = nl.toHalfFloat(Math.min(t6[e9 + 0] * s7, 65504)), n9[i7 + 1] = nl.toHalfFloat(Math.min(t6[e9 + 1] * s7, 65504)), n9[i7 + 2] = nl.toHalfFloat(Math.min(t6[e9 + 2] * s7, 65504)), n9[i7 + 3] = nl.toHalfFloat(1);
      }, s6 = new Uint8Array(t5);
      s6.pos = 0;
      const a4 = function(t6) {
        const i7 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r6 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s7 = /^\s*FORMAT=(\S+)\s*$/, a5 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, o7 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
        let l6, h4;
        if (t6.pos >= t6.byteLength || !(l6 = n8(t6)))
          return e8(1, "no header found");
        if (!(h4 = l6.match(/^#\?(\S+)/)))
          return e8(3, "bad initial token");
        for (o7.valid |= 1, o7.programtype = h4[1], o7.string += l6 + "\n"; l6 = n8(t6), l6 !== false; )
          if (o7.string += l6 + "\n", l6.charAt(0) !== "#") {
            if ((h4 = l6.match(i7)) && (o7.gamma = parseFloat(h4[1])), (h4 = l6.match(r6)) && (o7.exposure = parseFloat(h4[1])), (h4 = l6.match(s7)) && (o7.valid |= 2, o7.format = h4[1]), (h4 = l6.match(a5)) && (o7.valid |= 4, o7.height = parseInt(h4[1], 10), o7.width = parseInt(h4[2], 10)), 2 & o7.valid && 4 & o7.valid)
              break;
          } else
            o7.comments += l6 + "\n";
        return 2 & o7.valid ? 4 & o7.valid ? o7 : e8(3, "missing image size specifier") : e8(3, "missing format specifier");
      }(s6);
      if (a4 !== -1) {
        const t6 = a4.width, n9 = a4.height, o7 = function(t7, n10, i7) {
          const r6 = n10;
          if (r6 < 8 || r6 > 32767 || t7[0] !== 2 || t7[1] !== 2 || 128 & t7[2])
            return new Uint8Array(t7);
          if (r6 !== (t7[2] << 8 | t7[3]))
            return e8(3, "wrong scanline width");
          const s7 = new Uint8Array(4 * n10 * i7);
          if (!s7.length)
            return e8(4, "unable to allocate buffer space");
          let a5 = 0, o8 = 0;
          const l6 = 4 * r6, h4 = new Uint8Array(4), c3 = new Uint8Array(l6);
          let u3 = i7;
          for (; u3 > 0 && o8 < t7.byteLength; ) {
            if (o8 + 4 > t7.byteLength)
              return e8(1);
            if (h4[0] = t7[o8++], h4[1] = t7[o8++], h4[2] = t7[o8++], h4[3] = t7[o8++], h4[0] != 2 || h4[1] != 2 || (h4[2] << 8 | h4[3]) != r6)
              return e8(3, "bad rgbe scanline format");
            let n11, i8 = 0;
            for (; i8 < l6 && o8 < t7.byteLength; ) {
              n11 = t7[o8++];
              const r7 = n11 > 128;
              if (r7 && (n11 -= 128), n11 === 0 || i8 + n11 > l6)
                return e8(3, "bad scanline data");
              if (r7) {
                const e9 = t7[o8++];
                for (let t8 = 0; t8 < n11; t8++)
                  c3[i8++] = e9;
              } else
                c3.set(t7.subarray(o8, o8 + n11), i8), i8 += n11, o8 += n11;
            }
            const d3 = r6;
            for (let t8 = 0; t8 < d3; t8++) {
              let e9 = 0;
              s7[a5] = c3[t8 + e9], e9 += r6, s7[a5 + 1] = c3[t8 + e9], e9 += r6, s7[a5 + 2] = c3[t8 + e9], e9 += r6, s7[a5 + 3] = c3[t8 + e9], a5 += 4;
            }
            u3--;
          }
          return s7;
        }(s6.subarray(s6.pos), t6, n9);
        if (o7 !== -1) {
          let e9, s7, l6, h4;
          switch (this.type) {
            case 1015:
              h4 = o7.length / 4;
              const t7 = new Float32Array(4 * h4);
              for (let e10 = 0; e10 < h4; e10++)
                i6(o7, 4 * e10, t7, 4 * e10);
              e9 = t7, l6 = 1015;
              break;
            case 1016:
              h4 = o7.length / 4;
              const n10 = new Uint16Array(4 * h4);
              for (let t8 = 0; t8 < h4; t8++)
                r5(o7, 4 * t8, n10, 4 * t8);
              e9 = n10, l6 = 1016;
              break;
            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }
          return { width: t6, height: n9, data: e9, header: a4.string, gamma: a4.gamma, exposure: a4.exposure, format: s7, type: l6 };
        }
      }
      return null;
    }
    setDataType(t5) {
      return this.type = t5, this;
    }
    load(t5, e8, n8, i6) {
      return super.load(t5, function(t6, n9) {
        switch (t6.type) {
          case 1015:
          case 1016:
            t6.encoding = 3e3, t6.minFilter = 1006, t6.magFilter = 1006, t6.generateMipmaps = false, t6.flipY = true;
        }
        e8 && e8(t6, n9);
      }, n8, i6);
    }
  }();
  Id.setDataType(1016);
  var Od = class extends i5 {
    constructor(t5) {
      super(), this.threeRenderer = t5, this.generatedEnvironmentMap = null, this.generatedEnvironmentMapAlt = null, this.skyboxCache = /* @__PURE__ */ new Map(), this.blurMaterial = null, this.blurScene = null;
    }
    async load(t5, e8 = () => {
    }) {
      try {
        const n8 = Pd.test(t5), i6 = n8 ? Id : Dd, r5 = await new Promise((n9, r6) => i6.load(t5, n9, (t6) => {
          e8(t6.loaded / t6.total * 0.9);
        }, r6));
        return e8(1), r5.name = t5, r5.mapping = 303, n8 || (r5.encoding = 3001), r5;
      } finally {
        e8 && e8(1);
      }
    }
    async generateEnvironmentMapAndSkybox(t5 = null, e8 = null, n8 = {}) {
      const { progressTracker: i6 } = n8, r5 = e8 === "neutral";
      r5 === true && (e8 = null), e8 = ru(e8);
      let s6, a4 = Promise.resolve(null);
      t5 && (a4 = this.loadEquirectFromUrl(t5, i6)), s6 = e8 ? this.loadEquirectFromUrl(e8, i6) : t5 ? this.loadEquirectFromUrl(t5, i6) : r5 === true ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
      let [o7, l6] = await Promise.all([s6, a4]);
      if (o7 == null)
        throw new Error("Failed to load environment map.");
      return { environmentMap: o7, skybox: l6 };
    }
    async loadEquirectFromUrl(t5, e8) {
      if (!this.skyboxCache.has(t5)) {
        const n8 = e8 ? e8.beginActivity() : () => {
        }, i6 = this.load(t5, n8);
        this.skyboxCache.set(t5, i6);
      }
      return this.skyboxCache.get(t5);
    }
    async GenerateEnvironmentMap(t5, e8) {
      await uu();
      const n8 = this.threeRenderer, i6 = new Xe(256, { generateMipmaps: false, type: 1016, format: 1023, encoding: 3e3, depthBuffer: true }), r5 = new je(0.1, 100, i6), s6 = r5.renderTarget.texture;
      s6.name = e8;
      const a4 = n8.outputEncoding, o7 = n8.toneMapping;
      return n8.toneMapping = 0, n8.outputEncoding = 3e3, r5.update(n8, t5), this.blurCubemap(i6, 0.04), n8.toneMapping = o7, n8.outputEncoding = a4, s6;
    }
    async loadGeneratedEnvironmentMap() {
      return this.generatedEnvironmentMap == null && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new Cd(), "default")), this.generatedEnvironmentMap;
    }
    async loadGeneratedEnvironmentMapAlt() {
      return this.generatedEnvironmentMapAlt == null && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new Ld(), "neutral")), this.generatedEnvironmentMapAlt;
    }
    blurCubemap(t5, e8) {
      if (this.blurMaterial == null) {
        this.blurMaterial = this.getBlurShader(20);
        const t6 = new ke(), e9 = new Fe(t6, this.blurMaterial);
        this.blurScene = new Nr(), this.blurScene.add(e9);
      }
      const n8 = t5.clone();
      this.halfblur(t5, n8, e8, "latitudinal"), this.halfblur(n8, t5, e8, "longitudinal");
    }
    halfblur(t5, e8, n8, i6) {
      const r5 = t5.width, s6 = isFinite(n8) ? Math.PI / (2 * r5) : 2 * Math.PI / 39, a4 = n8 / s6, o7 = isFinite(n8) ? 1 + Math.floor(3 * a4) : 20;
      o7 > 20 && console.warn(`sigmaRadians, ${n8}, is too large and will clip, as it requested ${o7} samples when the maximum is set to 20`);
      const l6 = [];
      let h4 = 0;
      for (let t6 = 0; t6 < 20; ++t6) {
        const e9 = t6 / a4, n9 = Math.exp(-e9 * e9 / 2);
        l6.push(n9), t6 == 0 ? h4 += n9 : t6 < o7 && (h4 += 2 * n9);
      }
      for (let t6 = 0; t6 < l6.length; t6++)
        l6[t6] = l6[t6] / h4;
      const c3 = this.blurMaterial.uniforms;
      c3.envMap.value = t5.texture, c3.samples.value = o7, c3.weights.value = l6, c3.latitudinal.value = i6 === "latitudinal", c3.dTheta.value = s6;
      new je(0.1, 100, e8).update(this.threeRenderer, this.blurScene);
    }
    getBlurShader(t5) {
      const e8 = new Float32Array(t5), n8 = new V2(0, 1, 0);
      return new Ve({ name: "SphericalGaussianBlur", defines: { n: t5 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e8 }, latitudinal: { value: false }, dTheta: { value: 0 }, poleAxis: { value: n8 } }, vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ", fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ", blending: 0, depthTest: false, depthWrite: false, side: 1 });
    }
    async dispose() {
      for (const [, t5] of this.skyboxCache) {
        (await t5).dispose();
      }
      this.generatedEnvironmentMap != null && ((await this.generatedEnvironmentMap).dispose(), this.generatedEnvironmentMap = null), this.generatedEnvironmentMapAlt != null && ((await this.generatedEnvironmentMapAlt).dispose(), this.generatedEnvironmentMapAlt = null), this.blurMaterial != null && this.blurMaterial.dispose();
    }
  };
  var Nd = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];
  var Fd = class extends i5 {
    constructor(t5) {
      super(), this.loader = new Jc(Rd), this.width = 0, this.height = 0, this.dpr = 1, this.debugger = null, this.scenes = /* @__PURE__ */ new Set(), this.multipleScenesVisible = false, this.scaleStep = 0, this.lastStep = 3, this.avgFrameDuration = 22, this.onWebGLContextLost = (t6) => {
        this.dispatchEvent({ type: "contextlost", sourceEvent: t6 });
      }, this.onWebGLContextRestored = () => {
        var t6;
        (t6 = this.textureUtils) === null || t6 === void 0 || t6.dispose(), this.textureUtils = new Od(this.threeRenderer);
        for (const t7 of this.scenes)
          t7.element[Gu]();
      }, this.dpr = hu(), this.canvas3D = document.createElement("canvas"), this.canvas3D.id = "webgl-canvas";
      try {
        this.threeRenderer = new Or({ canvas: this.canvas3D, alpha: true, antialias: true, powerPreference: t5.powerPreference, preserveDrawingBuffer: true }), this.threeRenderer.autoClear = true, this.threeRenderer.outputEncoding = 3001, this.threeRenderer.physicallyCorrectLights = true, this.threeRenderer.setPixelRatio(1), this.debugger = t5.debug ? new hd(this) : null, this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }, this.threeRenderer.toneMapping = 4;
      } catch (t6) {
        console.warn(t6);
      }
      this.arRenderer = new ld(this), this.textureUtils = this.canRender ? new Od(this.threeRenderer) : null, Jc.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize(), this.lastTick = performance.now(), this.avgFrameDuration = 0;
    }
    static get singleton() {
      return this._singleton;
    }
    static resetSingleton() {
      const t5 = this._singleton.dispose();
      for (const e8 of t5)
        e8.disconnectedCallback();
      this._singleton = new Fd({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: cu() });
      for (const e8 of t5)
        e8.connectedCallback();
    }
    get canRender() {
      return this.threeRenderer != null;
    }
    get scaleFactor() {
      return Nd[this.scaleStep];
    }
    set minScale(t5) {
      let e8 = 1;
      for (; e8 < Nd.length && !(Nd[e8] < t5); )
        ++e8;
      this.lastStep = e8 - 1;
    }
    updateRendererSize() {
      const t5 = hu();
      if (t5 !== this.dpr)
        for (const t6 of this.scenes) {
          const { element: e9 } = t6;
          e9[op](e9.getBoundingClientRect());
        }
      let e8 = 0, n8 = 0;
      for (const t6 of this.scenes)
        e8 = Math.max(e8, t6.width), n8 = Math.max(n8, t6.height);
      if (e8 === this.width && n8 === this.height && t5 === this.dpr)
        return;
      this.width = e8, this.height = n8, this.dpr = t5, this.canRender && this.threeRenderer.setSize(e8 * t5, n8 * t5, false);
      const i6 = this.scaleFactor, r5 = e8 / i6, s6 = n8 / i6;
      this.canvas3D.style.width = `${r5}px`, this.canvas3D.style.height = `${s6}px`;
      for (const i7 of this.scenes) {
        const { canvas: a4 } = i7;
        a4.width = Math.round(e8 * t5), a4.height = Math.round(n8 * t5), a4.style.width = `${r5}px`, a4.style.height = `${s6}px`, i7.queueRender();
      }
    }
    updateRendererScale() {
      const t5 = this.scaleStep;
      if (this.avgFrameDuration > 26 ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), t5 == this.scaleStep)
        return;
      const e8 = this.scaleFactor;
      this.avgFrameDuration = 22;
      const n8 = this.width / e8, i6 = this.height / e8;
      this.canvas3D.style.width = `${n8}px`, this.canvas3D.style.height = `${i6}px`;
      for (const t6 of this.scenes) {
        const { style: e9 } = t6.canvas;
        e9.width = `${n8}px`, e9.height = `${i6}px`, t6.queueRender(), this.dispatchRenderScale(t6);
      }
    }
    dispatchRenderScale(t5) {
      const e8 = this.scaleFactor, n8 = this.dpr * e8, i6 = e8 < 1 ? "GPU throttling" : this.dpr !== window.devicePixelRatio ? "No meta viewport tag" : "";
      t5.element.dispatchEvent(new CustomEvent("render-scale", { detail: { reportedDpr: window.devicePixelRatio, renderedDpr: n8, minimumDpr: this.dpr * Nd[this.lastStep], pixelWidth: Math.ceil(t5.width * n8), pixelHeight: Math.ceil(t5.height * n8), reason: i6 } }));
    }
    registerScene(t5) {
      this.scenes.add(t5);
      const { canvas: e8 } = t5, n8 = this.scaleFactor;
      e8.width = Math.round(this.width * this.dpr), e8.height = Math.round(this.height * this.dpr), e8.style.width = this.width / n8 + "px", e8.style.height = this.height / n8 + "px", this.multipleScenesVisible && e8.classList.add("show"), t5.queueRender(), this.dispatchRenderScale(t5), this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((t6, e9) => this.render(t6, e9)), this.debugger != null && this.debugger.addScene(t5);
    }
    unregisterScene(t5) {
      this.scenes.delete(t5), this.canRender && this.scenes.size === 0 && this.threeRenderer.setAnimationLoop(null), this.debugger != null && this.debugger.removeScene(t5);
    }
    displayCanvas(t5) {
      return this.multipleScenesVisible ? t5.element[bp] : this.canvas3D;
    }
    selectCanvas() {
      let t5 = 0, e8 = null;
      for (const n9 of this.scenes) {
        const { element: i7 } = n9;
        i7.modelIsVisible && n9.externalRenderer == null && (++t5, e8 = n9.canvas);
      }
      if (e8 == null)
        return;
      const n8 = t5 > 1, { canvas3D: i6 } = this;
      if (n8 !== this.multipleScenesVisible || !n8 && i6.parentElement !== e8.parentElement) {
        this.multipleScenesVisible = n8, n8 && i6.classList.remove("show");
        for (const t6 of this.scenes) {
          if (t6.externalRenderer != null)
            continue;
          const r5 = t6.element[bp];
          n8 ? (r5.classList.add("show"), t6.queueRender()) : t6.canvas === e8 && (t6.canvas.parentElement.appendChild(i6), i6.classList.add("show"), r5.classList.remove("show"), t6.queueRender());
        }
      }
    }
    orderedScenes() {
      const t5 = [];
      for (const e8 of [false, true])
        for (const n8 of this.scenes)
          n8.element.modelIsVisible === e8 && t5.push(n8);
      return t5;
    }
    get isPresenting() {
      return this.arRenderer.isPresenting;
    }
    preRender(t5, e8, n8) {
      const { element: i6, exposure: r5 } = t5;
      i6[Mp](e8, n8);
      const s6 = typeof r5 == "number" && !self.isNaN(r5);
      this.threeRenderer.toneMappingExposure = s6 ? r5 : 1;
    }
    render(t5, e8) {
      if (e8 != null)
        return void this.arRenderer.onWebXRFrame(t5, e8);
      const n8 = t5 - this.lastTick;
      if (this.lastTick = t5, !this.canRender || this.isPresenting)
        return;
      this.avgFrameDuration += lu(0.2 * (n8 - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
      const { dpr: i6, scaleFactor: r5 } = this;
      for (const e9 of this.orderedScenes()) {
        const { element: s6 } = e9;
        if (!s6.modelIsVisible && e9.renderCount > 0)
          continue;
        if (this.preRender(e9, t5, n8), !e9.shouldRender())
          continue;
        if (e9.externalRenderer != null) {
          const t6 = e9.getCamera();
          t6.updateMatrix();
          const { matrix: n9, projectionMatrix: i7 } = t6, r6 = n9.elements.slice(), s7 = e9.getTarget();
          r6[12] += s7.x, r6[13] += s7.y, r6[14] += s7.z, e9.externalRenderer.render({ viewMatrix: r6, projectionMatrix: i7.elements });
          continue;
        }
        if (!s6.modelIsVisible && !this.multipleScenesVisible)
          for (const t6 of this.scenes)
            t6.element.modelIsVisible && t6.queueRender();
        const a4 = Math.min(Math.ceil(e9.width * r5 * i6), this.canvas3D.width), o7 = Math.min(Math.ceil(e9.height * r5 * i6), this.canvas3D.height);
        if (e9.renderShadow(this.threeRenderer), this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * i6) - o7, a4, o7), this.threeRenderer.render(e9, e9.camera), this.multipleScenesVisible) {
          e9.context == null && e9.createContext();
          const t6 = e9.context;
          t6.clearRect(0, 0, a4, o7), t6.drawImage(this.canvas3D, 0, 0, a4, o7, 0, 0, a4, o7);
        }
        e9.hasRendered(), s6.loaded && ++e9.renderCount;
      }
    }
    dispose() {
      this.textureUtils != null && this.textureUtils.dispose(), this.threeRenderer != null && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
      const t5 = [];
      for (const e8 of this.scenes)
        t5.push(e8.element);
      return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), t5;
    }
  };
  Fd._singleton = new Fd({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: cu() });
  var Ud = class extends EventTarget {
    constructor() {
      super(...arguments), this.ongoingActivities = /* @__PURE__ */ new Set(), this.totalProgress = 0;
    }
    get ongoingActivityCount() {
      return this.ongoingActivities.size;
    }
    beginActivity() {
      const t5 = { progress: 0, completed: false };
      return this.ongoingActivities.add(t5), this.ongoingActivityCount === 1 && this.announceTotalProgress(t5, 0), (e8) => {
        let n8;
        return n8 = Math.max(lu(e8, 0, 1), t5.progress), n8 !== t5.progress && this.announceTotalProgress(t5, n8), t5.progress;
      };
    }
    announceTotalProgress(t5, e8) {
      let n8 = 0, i6 = 0;
      e8 == 1 && (t5.completed = true);
      for (const t6 of this.ongoingActivities) {
        const { progress: e9 } = t6;
        n8 += 1 - e9, t6.completed === true && i6++;
      }
      const r5 = t5.progress;
      t5.progress = e8, this.totalProgress += (e8 - r5) * (1 - this.totalProgress) / n8;
      const s6 = i6 === this.ongoingActivityCount ? 1 : this.totalProgress;
      this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: s6 } })), i6 === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear());
    }
  };
  var kd;
  var Bd;
  var zd;
  var Hd;
  var Vd;
  var Gd;
  var Wd;
  var jd;
  var qd;
  var Xd;
  var $d;
  var Yd;
  var Jd = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var Kd = document.createElement("canvas");
  var Zd = Symbol("fallbackResizeHandler");
  var Qd = Symbol("defaultAriaLabel");
  var tp = Symbol("resizeObserver");
  var ep = Symbol("clearModelTimeout");
  var np = Symbol("onContextLost");
  var ip = Symbol("loaded");
  var rp = Symbol("status");
  var sp = Symbol("onFocus");
  var ap = Symbol("onBlur");
  var op = Symbol("updateSize");
  var lp = Symbol("intersectionObserver");
  var hp = Symbol("isElementInViewport");
  var cp = Symbol("announceModelVisibility");
  var up = Symbol("ariaLabel");
  var dp = Symbol("altDefaulted");
  var pp = Symbol("statusElement");
  var mp = Symbol("updateStatus");
  var fp = Symbol("loadedTime");
  var gp = Symbol("updateSource");
  var vp = Symbol("markLoaded");
  var yp = Symbol("container");
  var xp = Symbol("input");
  var bp = Symbol("canvas");
  var _p = Symbol("scene");
  var wp = Symbol("needsRender");
  var Mp = Symbol("tick");
  var Sp = Symbol("onModelLoad");
  var Tp = Symbol("onResize");
  var Ep = Symbol("renderer");
  var Ap = Symbol("progressTracker");
  var Rp = Symbol("getLoaded");
  var Cp = Symbol("getModelIsVisible");
  var Lp = Symbol("shouldAttemptPreload");
  var Pp = Symbol("sceneIsReady");
  var Dp = Symbol("hasTransitioned");
  var Ip = (t5) => ({ x: t5.x, y: t5.y, z: t5.z, toString() {
    return `${this.x}m ${this.y}m ${this.z}m`;
  } });
  var Op = (t5) => ({ u: t5.x, v: t5.y, toString() {
    return `${this.u} ${this.v}`;
  } });
  var Np = class extends Ml {
    constructor() {
      super(), this.alt = null, this.src = null, this.withCredentials = false, this[kd] = false, this[Bd] = false, this[zd] = 0, this[Hd] = null, this[Vd] = ou(() => {
        const t6 = this.getBoundingClientRect();
        this[op](t6);
      }, 50), this[Gd] = ou((t6) => {
        const e9 = this.modelIsVisible;
        e9 !== t6 && this.dispatchEvent(new CustomEvent("model-visibility", { detail: { visible: e9 } }));
      }, 0), this[Wd] = null, this[jd] = null, this[qd] = new Ud(), this[Xd] = () => {
        this[pp].textContent = this[rp];
      }, this[$d] = () => {
        this[pp].textContent = "";
      }, this[Yd] = (t6) => {
        this.dispatchEvent(new CustomEvent("error", { detail: { type: "webglcontextlost", sourceError: t6.sourceEvent } }));
      }, this.attachShadow({ mode: "open" });
      const t5 = this.shadowRoot;
      let e8, n8;
      if (((t6) => {
        jl(bh, t6);
      })(t5), this[yp] = t5.querySelector(".container"), this[xp] = t5.querySelector(".userInput"), this[bp] = t5.querySelector("canvas"), this[pp] = t5.querySelector("#status"), this[Qd] = this[xp].getAttribute("aria-label"), this.isConnected) {
        const t6 = this.getBoundingClientRect();
        e8 = t6.width, n8 = t6.height;
      } else
        e8 = 300, n8 = 150;
      this[_p] = new Bu({ canvas: this[bp], element: this, width: e8, height: n8 }), this[_p].addEventListener("model-load", async (t6) => {
        this[vp](), this[Sp](), await uu(), this.dispatchEvent(new CustomEvent("load", { detail: { url: t6.url } }));
      }), Promise.resolve().then(() => {
        this[op](this.getBoundingClientRect());
      }), uh && (this[tp] = new ResizeObserver((t6) => {
        if (!this[Ep].isPresenting)
          for (let e9 of t6)
            e9.target === this && this[op](e9.contentRect);
      })), dh ? this[lp] = new IntersectionObserver((t6) => {
        for (let e9 of t6)
          if (e9.target === this) {
            const t7 = this.modelIsVisible;
            this[hp] = e9.isIntersecting, this[cp](t7), this[hp] && !this[Pp]() && this[gp]();
          }
      }, { root: null, rootMargin: "0px", threshold: 0 }) : this[hp] = true;
    }
    static get is() {
      return "model-viewer";
    }
    static set modelCacheSize(t5) {
      Jc[$c].evictionThreshold = t5;
    }
    static get modelCacheSize() {
      return Jc[$c].evictionThreshold;
    }
    static set minimumRenderScale(t5) {
      t5 > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), t5 <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), Fd.singleton.minScale = t5;
    }
    static get minimumRenderScale() {
      return Fd.singleton.minScale;
    }
    get loaded() {
      return this[Rp]();
    }
    get [(kd = hp, Bd = ip, zd = fp, Hd = ep, Vd = Zd, Gd = cp, Wd = tp, jd = lp, qd = Ap, Ep)]() {
      return Fd.singleton;
    }
    get modelIsVisible() {
      return this[Cp]();
    }
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), uh ? this[tp].observe(this) : self.addEventListener("resize", this[Zd]), dh && this[lp].observe(this), this.addEventListener("focus", this[sp]), this.addEventListener("blur", this[ap]);
      const t5 = this[Ep];
      t5.addEventListener("contextlost", this[np]), t5.registerScene(this[_p]), this[ep] != null && (self.clearTimeout(this[ep]), this[ep] = null, this.requestUpdate("src", null));
    }
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback(), uh ? this[tp].unobserve(this) : self.removeEventListener("resize", this[Zd]), dh && this[lp].unobserve(this), this.removeEventListener("focus", this[sp]), this.removeEventListener("blur", this[ap]);
      const t5 = this[Ep];
      t5.removeEventListener("contextlost", this[np]), t5.unregisterScene(this[_p]), this[ep] = self.setTimeout(() => {
        this[_p].reset();
      }, 1e3);
    }
    updated(t5) {
      super.updated(t5), t5.has("src") && (this.src == null ? (this[ip] = false, this[fp] = 0, this[_p].reset()) : this.src !== this[_p].url && (this[ip] = false, this[fp] = 0, this[gp]())), t5.has("alt") && this[xp].setAttribute("aria-label", this[up]), t5.has("withCredentials") && (Jc.withCredentials = this.withCredentials);
    }
    toDataURL(t5, e8) {
      return this[Ep].displayCanvas(this[_p]).toDataURL(t5, e8);
    }
    async toBlob(t5) {
      const e8 = t5 ? t5.mimeType : void 0, n8 = t5 ? t5.qualityArgument : void 0, i6 = t5 ? t5.idealAspect : void 0, { width: r5, height: s6, idealAspect: a4, aspect: o7 } = this[_p], { dpr: l6, scaleFactor: h4 } = this[Ep];
      let c3 = r5 * h4 * l6, u3 = s6 * h4 * l6, d3 = 0, p3 = 0;
      if (i6 === true)
        if (a4 > o7) {
          const t6 = u3;
          u3 = Math.round(c3 / a4), p3 = (t6 - u3) / 2;
        } else {
          const t6 = c3;
          c3 = Math.round(u3 * a4), d3 = (t6 - c3) / 2;
        }
      Kd.width = c3, Kd.height = u3;
      try {
        return new Promise(async (t6, i7) => (Kd.getContext("2d").drawImage(this[Ep].displayCanvas(this[_p]), d3, p3, c3, u3, 0, 0, c3, u3), !Kd.msToBlob || e8 && e8 !== "image/png" ? Kd.toBlob ? void Kd.toBlob((e9) => {
          if (!e9)
            return i7(new Error("Unable to retrieve canvas blob"));
          t6(e9);
        }, e8, n8) : t6(await (async (t7) => new Promise((e9, n9) => {
          const i8 = t7.match(/data:(.*);/);
          if (!i8)
            return n9(new Error(`${t7} is not a valid data Url`));
          const r6 = i8[1], s7 = t7.replace(/data:image\/\w+;base64,/, ""), a5 = atob(s7), o8 = [];
          for (let t8 = 0; t8 < a5.length; t8 += 512) {
            const e10 = a5.slice(t8, t8 + 512), n10 = new Array(e10.length);
            for (let t9 = 0; t9 < e10.length; t9++)
              n10[t9] = e10.charCodeAt(t9);
            const i9 = new Uint8Array(n10);
            o8.push(i9);
          }
          e9(new Blob(o8, { type: r6 }));
        }))(Kd.toDataURL(e8, n8))) : t6(Kd.msToBlob())));
      } finally {
        this[op]({ width: r5, height: s6 });
      }
    }
    registerRenderer(t5) {
      this[_p].externalRenderer = t5;
    }
    unregisterRenderer() {
      this[_p].externalRenderer = null;
    }
    get [up]() {
      return this[dp];
    }
    get [dp]() {
      return this.alt == null || this.alt === "null" ? this[Qd] : this.alt;
    }
    [Rp]() {
      return this[ip];
    }
    [Cp]() {
      return this.loaded && this[hp];
    }
    [Dp]() {
      return this.modelIsVisible;
    }
    [Lp]() {
      return !!this.src && this[hp];
    }
    [Pp]() {
      return this[ip];
    }
    [op]({ width: t5, height: e8 }) {
      this[yp].style.width = `${t5}px`, this[yp].style.height = `${e8}px`, this[Tp]({ width: parseFloat(t5), height: parseFloat(e8) });
    }
    [Mp](t5, e8) {
    }
    [vp]() {
      this[ip] || (this[ip] = true, this[fp] = performance.now());
    }
    [wp]() {
      this[_p].queueRender();
    }
    [Sp]() {
    }
    [mp](t5) {
      this[rp] = t5;
      const e8 = this.getRootNode();
      e8 != null && e8.activeElement === this && this[pp].textContent != t5 && (this[pp].textContent = t5);
    }
    [(Xd = sp, $d = ap, Tp)](t5) {
      this[_p].setSize(t5.width, t5.height);
    }
    async [(Yd = np, gp)]() {
      if (this.loaded || !this[Lp]())
        return;
      const t5 = this[Ap].beginActivity(), e8 = this.src;
      try {
        await this[_p].setSource(e8, (e9) => t5(0.95 * e9));
        const n8 = { url: e8 };
        this.dispatchEvent(new CustomEvent("preload", { detail: n8 }));
      } catch (t6) {
        this.dispatchEvent(new CustomEvent("error", { detail: t6 }));
      } finally {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            t5(1);
          });
        });
      }
    }
  };
  Jd([e7({ type: String })], Np.prototype, "alt", void 0), Jd([e7({ type: String })], Np.prototype, "src", void 0), Jd([e7({ type: Boolean, attribute: "with-credentials" })], Np.prototype, "withCredentials", void 0);
  var Fp = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var Up = Symbol("changeAnimation");
  var kp = Symbol("paused");
  var Bp = { repetitions: 1 / 0, pingpong: false };
  var zp = Symbol("hotspotMap");
  var Hp = Symbol("mutationCallback");
  var Vp = Symbol("observer");
  var Gp = Symbol("addHotspot");
  var Wp = Symbol("removeHotspot");
  var jp = new xt();
  var qp = new v2();
  var Xp = function(t5) {
    return URL.createObjectURL(new Blob([t5], { type: "text/javascript" }));
  };
  try {
    URL.revokeObjectURL(Xp(""));
  } catch (Al2) {
    Xp = function(t5) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(t5);
    };
  }
  var $p = Uint8Array;
  var Yp = Uint16Array;
  var Jp = Uint32Array;
  var Kp = new $p([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  var Zp = new $p([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  var Qp = new $p([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var tm = function(t5, e8) {
    for (var n8 = new Yp(31), i6 = 0; i6 < 31; ++i6)
      n8[i6] = e8 += 1 << t5[i6 - 1];
    var r5 = new Jp(n8[30]);
    for (i6 = 1; i6 < 30; ++i6)
      for (var s6 = n8[i6]; s6 < n8[i6 + 1]; ++s6)
        r5[s6] = s6 - n8[i6] << 5 | i6;
    return [n8, r5];
  };
  var em = tm(Kp, 2);
  var nm = em[0];
  var im = em[1];
  nm[28] = 258, im[258] = 28;
  for (rm = tm(Zp, 0)[1], sm = new Yp(32768), am = 0; am < 32768; ++am) {
    om = (43690 & am) >>> 1 | (21845 & am) << 1;
    om = (61680 & (om = (52428 & om) >>> 2 | (13107 & om) << 2)) >>> 4 | (3855 & om) << 4, sm[am] = ((65280 & om) >>> 8 | (255 & om) << 8) >>> 1;
  }
  var om;
  var rm;
  var sm;
  var am;
  var lm = function(t5, e8, n8) {
    for (var i6 = t5.length, r5 = 0, s6 = new Yp(e8); r5 < i6; ++r5)
      ++s6[t5[r5] - 1];
    var a4, o7 = new Yp(e8);
    for (r5 = 0; r5 < e8; ++r5)
      o7[r5] = o7[r5 - 1] + s6[r5 - 1] << 1;
    if (n8) {
      a4 = new Yp(1 << e8);
      var l6 = 15 - e8;
      for (r5 = 0; r5 < i6; ++r5)
        if (t5[r5])
          for (var h4 = r5 << 4 | t5[r5], c3 = e8 - t5[r5], u3 = o7[t5[r5] - 1]++ << c3, d3 = u3 | (1 << c3) - 1; u3 <= d3; ++u3)
            a4[sm[u3] >>> l6] = h4;
    } else
      for (a4 = new Yp(i6), r5 = 0; r5 < i6; ++r5)
        t5[r5] && (a4[r5] = sm[o7[t5[r5] - 1]++] >>> 15 - t5[r5]);
    return a4;
  };
  var hm = new $p(288);
  for (am = 0; am < 144; ++am)
    hm[am] = 8;
  for (am = 144; am < 256; ++am)
    hm[am] = 9;
  for (am = 256; am < 280; ++am)
    hm[am] = 7;
  for (am = 280; am < 288; ++am)
    hm[am] = 8;
  var cm = new $p(32);
  for (am = 0; am < 32; ++am)
    cm[am] = 5;
  var um = lm(hm, 9, 0);
  var dm = lm(cm, 5, 0);
  var pm = function(t5) {
    return (t5 / 8 | 0) + (7 & t5 && 1);
  };
  var mm = function(t5, e8, n8) {
    (e8 == null || e8 < 0) && (e8 = 0), (n8 == null || n8 > t5.length) && (n8 = t5.length);
    var i6 = new (t5 instanceof Yp ? Yp : t5 instanceof Jp ? Jp : $p)(n8 - e8);
    return i6.set(t5.subarray(e8, n8)), i6;
  };
  var fm = function(t5, e8, n8) {
    n8 <<= 7 & e8;
    var i6 = e8 / 8 | 0;
    t5[i6] |= n8, t5[i6 + 1] |= n8 >>> 8;
  };
  var gm = function(t5, e8, n8) {
    n8 <<= 7 & e8;
    var i6 = e8 / 8 | 0;
    t5[i6] |= n8, t5[i6 + 1] |= n8 >>> 8, t5[i6 + 2] |= n8 >>> 16;
  };
  var vm = function(t5, e8) {
    for (var n8 = [], i6 = 0; i6 < t5.length; ++i6)
      t5[i6] && n8.push({ s: i6, f: t5[i6] });
    var r5 = n8.length, s6 = n8.slice();
    if (!r5)
      return [Sm, 0];
    if (r5 == 1) {
      var a4 = new $p(n8[0].s + 1);
      return a4[n8[0].s] = 1, [a4, 1];
    }
    n8.sort(function(t6, e9) {
      return t6.f - e9.f;
    }), n8.push({ s: -1, f: 25001 });
    var o7 = n8[0], l6 = n8[1], h4 = 0, c3 = 1, u3 = 2;
    for (n8[0] = { s: -1, f: o7.f + l6.f, l: o7, r: l6 }; c3 != r5 - 1; )
      o7 = n8[n8[h4].f < n8[u3].f ? h4++ : u3++], l6 = n8[h4 != c3 && n8[h4].f < n8[u3].f ? h4++ : u3++], n8[c3++] = { s: -1, f: o7.f + l6.f, l: o7, r: l6 };
    var d3 = s6[0].s;
    for (i6 = 1; i6 < r5; ++i6)
      s6[i6].s > d3 && (d3 = s6[i6].s);
    var p3 = new Yp(d3 + 1), m3 = ym(n8[c3 - 1], p3, 0);
    if (m3 > e8) {
      i6 = 0;
      var f3 = 0, g3 = m3 - e8, v3 = 1 << g3;
      for (s6.sort(function(t6, e9) {
        return p3[e9.s] - p3[t6.s] || t6.f - e9.f;
      }); i6 < r5; ++i6) {
        var y3 = s6[i6].s;
        if (!(p3[y3] > e8))
          break;
        f3 += v3 - (1 << m3 - p3[y3]), p3[y3] = e8;
      }
      for (f3 >>>= g3; f3 > 0; ) {
        var x3 = s6[i6].s;
        p3[x3] < e8 ? f3 -= 1 << e8 - p3[x3]++ - 1 : ++i6;
      }
      for (; i6 >= 0 && f3; --i6) {
        var b3 = s6[i6].s;
        p3[b3] == e8 && (--p3[b3], ++f3);
      }
      m3 = e8;
    }
    return [new $p(p3), m3];
  };
  var ym = function(t5, e8, n8) {
    return t5.s == -1 ? Math.max(ym(t5.l, e8, n8 + 1), ym(t5.r, e8, n8 + 1)) : e8[t5.s] = n8;
  };
  var xm = function(t5) {
    for (var e8 = t5.length; e8 && !t5[--e8]; )
      ;
    for (var n8 = new Yp(++e8), i6 = 0, r5 = t5[0], s6 = 1, a4 = function(t6) {
      n8[i6++] = t6;
    }, o7 = 1; o7 <= e8; ++o7)
      if (t5[o7] == r5 && o7 != e8)
        ++s6;
      else {
        if (!r5 && s6 > 2) {
          for (; s6 > 138; s6 -= 138)
            a4(32754);
          s6 > 2 && (a4(s6 > 10 ? s6 - 11 << 5 | 28690 : s6 - 3 << 5 | 12305), s6 = 0);
        } else if (s6 > 3) {
          for (a4(r5), --s6; s6 > 6; s6 -= 6)
            a4(8304);
          s6 > 2 && (a4(s6 - 3 << 5 | 8208), s6 = 0);
        }
        for (; s6--; )
          a4(r5);
        s6 = 1, r5 = t5[o7];
      }
    return [n8.subarray(0, i6), e8];
  };
  var bm = function(t5, e8) {
    for (var n8 = 0, i6 = 0; i6 < e8.length; ++i6)
      n8 += t5[i6] * e8[i6];
    return n8;
  };
  var _m = function(t5, e8, n8) {
    var i6 = n8.length, r5 = pm(e8 + 2);
    t5[r5] = 255 & i6, t5[r5 + 1] = i6 >>> 8, t5[r5 + 2] = 255 ^ t5[r5], t5[r5 + 3] = 255 ^ t5[r5 + 1];
    for (var s6 = 0; s6 < i6; ++s6)
      t5[r5 + s6 + 4] = n8[s6];
    return 8 * (r5 + 4 + i6);
  };
  var wm = function(t5, e8, n8, i6, r5, s6, a4, o7, l6, h4, c3) {
    fm(e8, c3++, n8), ++r5[256];
    for (var u3 = vm(r5, 15), d3 = u3[0], p3 = u3[1], m3 = vm(s6, 15), f3 = m3[0], g3 = m3[1], v3 = xm(d3), y3 = v3[0], x3 = v3[1], b3 = xm(f3), _3 = b3[0], w3 = b3[1], M3 = new Yp(19), S4 = 0; S4 < y3.length; ++S4)
      M3[31 & y3[S4]]++;
    for (S4 = 0; S4 < _3.length; ++S4)
      M3[31 & _3[S4]]++;
    for (var T3 = vm(M3, 7), E3 = T3[0], A3 = T3[1], R2 = 19; R2 > 4 && !E3[Qp[R2 - 1]]; --R2)
      ;
    var C3, L3, P3, D2, I3 = h4 + 5 << 3, O2 = bm(r5, hm) + bm(s6, cm) + a4, N3 = bm(r5, d3) + bm(s6, f3) + a4 + 14 + 3 * R2 + bm(M3, E3) + (2 * M3[16] + 3 * M3[17] + 7 * M3[18]);
    if (I3 <= O2 && I3 <= N3)
      return _m(e8, c3, t5.subarray(l6, l6 + h4));
    if (fm(e8, c3, 1 + (N3 < O2)), c3 += 2, N3 < O2) {
      C3 = lm(d3, p3, 0), L3 = d3, P3 = lm(f3, g3, 0), D2 = f3;
      var F2 = lm(E3, A3, 0);
      fm(e8, c3, x3 - 257), fm(e8, c3 + 5, w3 - 1), fm(e8, c3 + 10, R2 - 4), c3 += 14;
      for (S4 = 0; S4 < R2; ++S4)
        fm(e8, c3 + 3 * S4, E3[Qp[S4]]);
      c3 += 3 * R2;
      for (var U2 = [y3, _3], k3 = 0; k3 < 2; ++k3) {
        var B2 = U2[k3];
        for (S4 = 0; S4 < B2.length; ++S4) {
          var z3 = 31 & B2[S4];
          fm(e8, c3, F2[z3]), c3 += E3[z3], z3 > 15 && (fm(e8, c3, B2[S4] >>> 5 & 127), c3 += B2[S4] >>> 12);
        }
      }
    } else
      C3 = um, L3 = hm, P3 = dm, D2 = cm;
    for (S4 = 0; S4 < o7; ++S4)
      if (i6[S4] > 255) {
        z3 = i6[S4] >>> 18 & 31;
        gm(e8, c3, C3[z3 + 257]), c3 += L3[z3 + 257], z3 > 7 && (fm(e8, c3, i6[S4] >>> 23 & 31), c3 += Kp[z3]);
        var H3 = 31 & i6[S4];
        gm(e8, c3, P3[H3]), c3 += D2[H3], H3 > 3 && (gm(e8, c3, i6[S4] >>> 5 & 8191), c3 += Zp[H3]);
      } else
        gm(e8, c3, C3[i6[S4]]), c3 += L3[i6[S4]];
    return gm(e8, c3, C3[256]), c3 + L3[256];
  };
  var Mm = new Jp([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var Sm = new $p(0);
  var Tm = function() {
    for (var t5 = new Jp(256), e8 = 0; e8 < 256; ++e8) {
      for (var n8 = e8, i6 = 9; --i6; )
        n8 = (1 & n8 && 3988292384) ^ n8 >>> 1;
      t5[e8] = n8;
    }
    return t5;
  }();
  var Em = function() {
    var t5 = -1;
    return { p: function(e8) {
      for (var n8 = t5, i6 = 0; i6 < e8.length; ++i6)
        n8 = Tm[255 & n8 ^ e8[i6]] ^ n8 >>> 8;
      t5 = n8;
    }, d: function() {
      return ~t5;
    } };
  };
  var Am = function(t5, e8, n8, i6, r5) {
    return function(t6, e9, n9, i7, r6, s6) {
      var a4 = t6.length, o7 = new $p(i7 + a4 + 5 * (1 + Math.ceil(a4 / 7e3)) + r6), l6 = o7.subarray(i7, o7.length - r6), h4 = 0;
      if (!e9 || a4 < 8)
        for (var c3 = 0; c3 <= a4; c3 += 65535) {
          var u3 = c3 + 65535;
          u3 < a4 ? h4 = _m(l6, h4, t6.subarray(c3, u3)) : (l6[c3] = s6, h4 = _m(l6, h4, t6.subarray(c3, a4)));
        }
      else {
        for (var d3 = Mm[e9 - 1], p3 = d3 >>> 13, m3 = 8191 & d3, f3 = (1 << n9) - 1, g3 = new Yp(32768), v3 = new Yp(f3 + 1), y3 = Math.ceil(n9 / 3), x3 = 2 * y3, b3 = function(e10) {
          return (t6[e10] ^ t6[e10 + 1] << y3 ^ t6[e10 + 2] << x3) & f3;
        }, _3 = new Jp(25e3), w3 = new Yp(288), M3 = new Yp(32), S4 = 0, T3 = 0, E3 = (c3 = 0, 0), A3 = 0, R2 = 0; c3 < a4; ++c3) {
          var C3 = b3(c3), L3 = 32767 & c3, P3 = v3[C3];
          if (g3[L3] = P3, v3[C3] = L3, A3 <= c3) {
            var D2 = a4 - c3;
            if ((S4 > 7e3 || E3 > 24576) && D2 > 423) {
              h4 = wm(t6, l6, 0, _3, w3, M3, T3, E3, R2, c3 - R2, h4), E3 = S4 = T3 = 0, R2 = c3;
              for (var I3 = 0; I3 < 286; ++I3)
                w3[I3] = 0;
              for (I3 = 0; I3 < 30; ++I3)
                M3[I3] = 0;
            }
            var O2 = 2, N3 = 0, F2 = m3, U2 = L3 - P3 & 32767;
            if (D2 > 2 && C3 == b3(c3 - U2))
              for (var k3 = Math.min(p3, D2) - 1, B2 = Math.min(32767, c3), z3 = Math.min(258, D2); U2 <= B2 && --F2 && L3 != P3; ) {
                if (t6[c3 + O2] == t6[c3 + O2 - U2]) {
                  for (var H3 = 0; H3 < z3 && t6[c3 + H3] == t6[c3 + H3 - U2]; ++H3)
                    ;
                  if (H3 > O2) {
                    if (O2 = H3, N3 = U2, H3 > k3)
                      break;
                    var V3 = Math.min(U2, H3 - 2), G2 = 0;
                    for (I3 = 0; I3 < V3; ++I3) {
                      var W2 = c3 - U2 + I3 + 32768 & 32767, j2 = W2 - g3[W2] + 32768 & 32767;
                      j2 > G2 && (G2 = j2, P3 = W2);
                    }
                  }
                }
                U2 += (L3 = P3) - (P3 = g3[L3]) + 32768 & 32767;
              }
            if (N3) {
              _3[E3++] = 268435456 | im[O2] << 18 | rm[N3];
              var q2 = 31 & im[O2], X2 = 31 & rm[N3];
              T3 += Kp[q2] + Zp[X2], ++w3[257 + q2], ++M3[X2], A3 = c3 + O2, ++S4;
            } else
              _3[E3++] = t6[c3], ++w3[t6[c3]];
          }
        }
        h4 = wm(t6, l6, s6, _3, w3, M3, T3, E3, R2, c3 - R2, h4), !s6 && 7 & h4 && (h4 = _m(l6, h4 + 1, Sm));
      }
      return mm(o7, 0, i7 + pm(h4) + r6);
    }(t5, e8.level == null ? 6 : e8.level, e8.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t5.length)))) : 12 + e8.mem, n8, i6, !r5);
  };
  var Rm = function(t5, e8) {
    var n8 = {};
    for (var i6 in t5)
      n8[i6] = t5[i6];
    for (var i6 in e8)
      n8[i6] = e8[i6];
    return n8;
  };
  var Cm = function(t5, e8, n8) {
    for (; n8; ++e8)
      t5[e8] = n8, n8 >>>= 8;
  };
  function Lm(t5, e8) {
    return Am(t5, e8 || {}, 0, 0);
  }
  var Pm = function(t5, e8, n8, i6) {
    for (var r5 in t5) {
      var s6 = t5[r5], a4 = e8 + r5;
      s6 instanceof $p ? n8[a4] = [s6, i6] : Array.isArray(s6) ? n8[a4] = [s6[0], Rm(i6, s6[1])] : Pm(s6, a4 + "/", n8, i6);
    }
  };
  var Dm = typeof TextEncoder != "undefined" && new TextEncoder();
  var Im = typeof TextDecoder != "undefined" && new TextDecoder();
  try {
    Im.decode(Sm, { stream: true }), 1;
  } catch (Al2) {
  }
  function Om(t5, e8) {
    if (e8) {
      for (var n8 = new $p(t5.length), i6 = 0; i6 < t5.length; ++i6)
        n8[i6] = t5.charCodeAt(i6);
      return n8;
    }
    if (Dm)
      return Dm.encode(t5);
    var r5 = t5.length, s6 = new $p(t5.length + (t5.length >> 1)), a4 = 0, o7 = function(t6) {
      s6[a4++] = t6;
    };
    for (i6 = 0; i6 < r5; ++i6) {
      if (a4 + 5 > s6.length) {
        var l6 = new $p(a4 + 8 + (r5 - i6 << 1));
        l6.set(s6), s6 = l6;
      }
      var h4 = t5.charCodeAt(i6);
      h4 < 128 || e8 ? o7(h4) : h4 < 2048 ? (o7(192 | h4 >> 6), o7(128 | 63 & h4)) : h4 > 55295 && h4 < 57344 ? (o7(240 | (h4 = 65536 + (1047552 & h4) | 1023 & t5.charCodeAt(++i6)) >> 18), o7(128 | h4 >> 12 & 63), o7(128 | h4 >> 6 & 63), o7(128 | 63 & h4)) : (o7(224 | h4 >> 12), o7(128 | h4 >> 6 & 63), o7(128 | 63 & h4));
    }
    return mm(s6, 0, a4);
  }
  var Nm = function(t5) {
    var e8 = 0;
    if (t5)
      for (var n8 in t5) {
        var i6 = t5[n8].length;
        if (i6 > 65535)
          throw "extra field too long";
        e8 += i6 + 4;
      }
    return e8;
  };
  var Fm = function(t5, e8, n8, i6, r5, s6, a4, o7) {
    var l6 = i6.length, h4 = n8.extra, c3 = o7 && o7.length, u3 = Nm(h4);
    Cm(t5, e8, a4 != null ? 33639248 : 67324752), e8 += 4, a4 != null && (t5[e8++] = 20, t5[e8++] = n8.os), t5[e8] = 20, e8 += 2, t5[e8++] = n8.flag << 1 | (s6 == null && 8), t5[e8++] = r5 && 8, t5[e8++] = 255 & n8.compression, t5[e8++] = n8.compression >> 8;
    var d3 = new Date(n8.mtime == null ? Date.now() : n8.mtime), p3 = d3.getFullYear() - 1980;
    if (p3 < 0 || p3 > 119)
      throw "date not in range 1980-2099";
    if (Cm(t5, e8, p3 << 25 | d3.getMonth() + 1 << 21 | d3.getDate() << 16 | d3.getHours() << 11 | d3.getMinutes() << 5 | d3.getSeconds() >>> 1), e8 += 4, s6 != null && (Cm(t5, e8, n8.crc), Cm(t5, e8 + 4, s6), Cm(t5, e8 + 8, n8.size)), Cm(t5, e8 + 12, l6), Cm(t5, e8 + 14, u3), e8 += 16, a4 != null && (Cm(t5, e8, c3), Cm(t5, e8 + 6, n8.attrs), Cm(t5, e8 + 10, a4), e8 += 14), t5.set(i6, e8), e8 += l6, u3)
      for (var m3 in h4) {
        var f3 = h4[m3], g3 = f3.length;
        Cm(t5, e8, +m3), Cm(t5, e8 + 2, g3), t5.set(f3, e8 + 4), e8 += 4 + g3;
      }
    return c3 && (t5.set(o7, e8), e8 += c3), e8;
  };
  function Um(t5, e8) {
    e8 || (e8 = {});
    var n8 = {}, i6 = [];
    Pm(t5, "", n8, e8);
    var r5 = 0, s6 = 0;
    for (var a4 in n8) {
      var o7 = n8[a4], l6 = o7[0], h4 = o7[1], c3 = h4.level == 0 ? 0 : 8, u3 = (M3 = Om(a4)).length, d3 = h4.comment, p3 = d3 && Om(d3), m3 = p3 && p3.length, f3 = Nm(h4.extra);
      if (u3 > 65535)
        throw "filename too long";
      var g3 = c3 ? Lm(l6, h4) : l6, v3 = g3.length, y3 = Em();
      y3.p(l6), i6.push(Rm(h4, { size: l6.length, crc: y3.d(), c: g3, f: M3, m: p3, u: u3 != a4.length || p3 && d3.length != m3, o: r5, compression: c3 })), r5 += 30 + u3 + f3 + v3, s6 += 76 + 2 * (u3 + f3) + (m3 || 0) + v3;
    }
    for (var x3 = new $p(s6 + 22), b3 = r5, _3 = s6 - r5, w3 = 0; w3 < i6.length; ++w3) {
      var M3 = i6[w3];
      Fm(x3, M3.o, M3, M3.f, M3.u, M3.c.length);
      var S4 = 30 + M3.f.length + Nm(M3.extra);
      x3.set(M3.c, M3.o + S4), Fm(x3, r5, M3, M3.f, M3.u, M3.c.length, M3.o, M3.m), r5 += 16 + S4 + (M3.m ? M3.m.length : 0);
    }
    return function(t6, e9, n9, i7, r6) {
      Cm(t6, e9, 101010256), Cm(t6, e9 + 8, n9), Cm(t6, e9 + 10, n9), Cm(t6, e9 + 12, i7), Cm(t6, e9 + 16, r6);
    }(x3, r5, i6.length, _3, b3), x3;
  }
  var km = class {
    async parse(t5) {
      const e8 = {};
      e8["model.usda"] = null;
      let n8 = zm();
      const i6 = {}, r5 = {};
      t5.traverseVisible((t6) => {
        if (t6.isMesh)
          if (t6.material.isMeshStandardMaterial) {
            const r6 = t6.geometry, s7 = t6.material, a4 = "geometries/Geometry_" + r6.id + ".usd";
            if (!(a4 in e8)) {
              const t7 = function(t8) {
                return `
def "Geometry"
{
  ${function(t9) {
                  const e9 = "Geometry", n9 = t9.attributes, i7 = n9.position.count;
                  return `
    def Mesh "${e9}"
    {
        int[] faceVertexCounts = [${function(t10) {
                    const e10 = t10.index !== null ? t10.index.count : t10.attributes.position.count;
                    return Array(e10 / 3).fill(3).join(", ");
                  }(t9)}]
        int[] faceVertexIndices = [${function(t10) {
                    const e10 = t10.index, n10 = [];
                    if (e10 !== null)
                      for (let t11 = 0; t11 < e10.count; t11++)
                        n10.push(e10.getX(t11));
                    else {
                      const e11 = t10.attributes.position.count;
                      for (let t11 = 0; t11 < e11; t11++)
                        n10.push(t11);
                    }
                    return n10.join(", ");
                  }(t9)}]
        normal3f[] normals = [${Vm(n9.normal, i7)}] (
            interpolation = "vertex"
        )
        point3f[] points = [${Vm(n9.position, i7)}]
        float2[] primvars:st = [${function(t10, e10) {
                    if (t10 === void 0)
                      return console.warn("USDZExporter: UVs missing."), Array(e10).fill("(0, 0)").join(", ");
                    const n10 = [];
                    for (let e11 = 0; e11 < t10.count; e11++) {
                      const i8 = t10.getX(e11), r7 = t10.getY(e11);
                      n10.push(`(${i8.toPrecision(7)}, ${1 - r7.toPrecision(7)})`);
                    }
                    return n10.join(", ");
                  }(n9.uv, i7)}] (
            interpolation = "vertex"
        )
        uniform token subdivisionScheme = "none"
    }
`;
                }(t8)}
}
`;
              }(r6);
              e8[a4] = function(t8) {
                let e9 = zm();
                return e9 += t8, Om(e9);
              }(t7);
            }
            s7.uuid in i6 || (i6[s7.uuid] = s7), n8 += function(t7, e9, n9) {
              const i7 = "Object_" + t7.id, r7 = function(t8) {
                const e10 = t8.elements;
                return `( ${Hm(e10, 0)}, ${Hm(e10, 4)}, ${Hm(e10, 8)}, ${Hm(e10, 12)} )`;
              }(t7.matrixWorld);
              t7.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t7);
              return `def Xform "${i7}" (
    prepend references = @./geometries/Geometry_${e9.id}.usd@</Geometry>
)
{
    matrix4d xformOp:transform = ${r7}
    uniform token[] xformOpOrder = ["xformOp:transform"]

    rel material:binding = </Materials/Material_${n9.id}>
}

`;
            }(t6, r6, s7);
          } else
            console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", t6);
      }), n8 += function(t6, e9) {
        const n9 = [];
        for (const i7 in t6) {
          const r6 = t6[i7];
          n9.push(Gm(r6, e9));
        }
        return `def "Materials"
{
${n9.join("")}
}

`;
      }(i6, r5), e8["model.usda"] = Om(n8), n8 = null;
      for (const t6 in r5) {
        const n9 = r5[t6], i7 = t6.split("_")[1], s7 = n9.format === 1023, a4 = Bm(n9.image, i7), o7 = await new Promise((t7) => a4.toBlob(t7, s7 ? "image/png" : "image/jpeg", 1));
        e8[`textures/Texture_${t6}.${s7 ? "png" : "jpg"}`] = new Uint8Array(await o7.arrayBuffer());
      }
      let s6 = 0;
      for (const t6 in e8) {
        const n9 = e8[t6];
        s6 += 34 + t6.length;
        const i7 = 63 & s6;
        if (i7 !== 4) {
          const r6 = new Uint8Array(64 - i7);
          e8[t6] = [n9, { extra: { 12345: r6 } }];
        }
        s6 = n9.length;
      }
      return Um(e8, { level: 0 });
    }
  };
  function Bm(t5, e8) {
    if (typeof HTMLImageElement != "undefined" && t5 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t5 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && t5 instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && t5 instanceof ImageBitmap) {
      const n8 = 1024 / Math.max(t5.width, t5.height), i6 = document.createElement("canvas");
      i6.width = t5.width * Math.min(1, n8), i6.height = t5.height * Math.min(1, n8);
      const r5 = i6.getContext("2d");
      if (r5.drawImage(t5, 0, 0, i6.width, i6.height), e8 !== void 0) {
        const t6 = parseInt(e8, 16), n9 = (t6 >> 16 & 255) / 255, s6 = (t6 >> 8 & 255) / 255, a4 = (255 & t6) / 255, o7 = r5.getImageData(0, 0, i6.width, i6.height), l6 = o7.data;
        for (let t7 = 0; t7 < l6.length; t7 += 4)
          l6[t7 + 0] = l6[t7 + 0] * n9, l6[t7 + 1] = l6[t7 + 1] * s6, l6[t7 + 2] = l6[t7 + 2] * a4;
        r5.putImageData(o7, 0, 0);
      }
      return i6;
    }
  }
  function zm() {
    return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
  }
  function Hm(t5, e8) {
    return `(${t5[e8 + 0]}, ${t5[e8 + 1]}, ${t5[e8 + 2]}, ${t5[e8 + 3]})`;
  }
  function Vm(t5, e8) {
    if (t5 === void 0)
      return console.warn("USDZExporter: Normals missing."), Array(e8).fill("(0, 0, 0)").join(", ");
    const n8 = [];
    for (let e9 = 0; e9 < t5.count; e9++) {
      const i6 = t5.getX(e9), r5 = t5.getY(e9), s6 = t5.getZ(e9);
      n8.push(`(${i6.toPrecision(7)}, ${r5.toPrecision(7)}, ${s6.toPrecision(7)})`);
    }
    return n8.join(", ");
  }
  function Gm(t5, e8) {
    const n8 = "            ", i6 = [], r5 = [];
    function s6(n9, i7, r6) {
      const s7 = n9.id + (r6 ? "_" + r6.getHexString() : ""), a4 = n9.format === 1023;
      return e8[s7] = n9, `
        def Shader "Transform2d_${i7}" (
            sdrMetadata = {
                string role = "math"
            }
        )
        {
            uniform token info:id = "UsdTransform2d"
            float2 inputs:in.connect = </Materials/Material_${t5.id}/uvReader_st.outputs:result>
            float2 inputs:scale = ${jm(n9.repeat)}
            float2 inputs:translation = ${jm(n9.offset)}
            float2 outputs:result
        }

        def Shader "Texture_${n9.id}_${i7}"
        {
            uniform token info:id = "UsdUVTexture"
            asset inputs:file = @textures/Texture_${s7}.${a4 ? "png" : "jpg"}@
            float2 inputs:st.connect = </Materials/Material_${t5.id}/Transform2d_${i7}.outputs:result>
            token inputs:wrapS = "repeat"
            token inputs:wrapT = "repeat"
            float outputs:r
            float outputs:g
            float outputs:b
            float3 outputs:rgb
            ${t5.transparent || t5.alphaTest > 0 ? "float outputs:a" : ""}
        }`;
    }
    return t5.map !== null ? (i6.push(`${n8}color3f inputs:diffuseColor.connect = </Materials/Material_${t5.id}/Texture_${t5.map.id}_diffuse.outputs:rgb>`), t5.transparent ? i6.push(`${n8}float inputs:opacity.connect = </Materials/Material_${t5.id}/Texture_${t5.map.id}_diffuse.outputs:a>`) : t5.alphaTest > 0 && (i6.push(`${n8}float inputs:opacity.connect = </Materials/Material_${t5.id}/Texture_${t5.map.id}_diffuse.outputs:a>`), i6.push(`${n8}float inputs:opacityThreshold = ${t5.alphaTest}`)), r5.push(s6(t5.map, "diffuse", t5.color))) : i6.push(`${n8}color3f inputs:diffuseColor = ${Wm(t5.color)}`), t5.emissiveMap !== null ? (i6.push(`${n8}color3f inputs:emissiveColor.connect = </Materials/Material_${t5.id}/Texture_${t5.emissiveMap.id}_emissive.outputs:rgb>`), r5.push(s6(t5.emissiveMap, "emissive"))) : t5.emissive.getHex() > 0 && i6.push(`${n8}color3f inputs:emissiveColor = ${Wm(t5.emissive)}`), t5.normalMap !== null && (i6.push(`${n8}normal3f inputs:normal.connect = </Materials/Material_${t5.id}/Texture_${t5.normalMap.id}_normal.outputs:rgb>`), r5.push(s6(t5.normalMap, "normal"))), t5.aoMap !== null && (i6.push(`${n8}float inputs:occlusion.connect = </Materials/Material_${t5.id}/Texture_${t5.aoMap.id}_occlusion.outputs:r>`), r5.push(s6(t5.aoMap, "occlusion"))), t5.roughnessMap !== null && t5.roughness === 1 ? (i6.push(`${n8}float inputs:roughness.connect = </Materials/Material_${t5.id}/Texture_${t5.roughnessMap.id}_roughness.outputs:g>`), r5.push(s6(t5.roughnessMap, "roughness"))) : i6.push(`${n8}float inputs:roughness = ${t5.roughness}`), t5.metalnessMap !== null && t5.metalness === 1 ? (i6.push(`${n8}float inputs:metallic.connect = </Materials/Material_${t5.id}/Texture_${t5.metalnessMap.id}_metallic.outputs:b>`), r5.push(s6(t5.metalnessMap, "metallic"))) : i6.push(`${n8}float inputs:metallic = ${t5.metalness}`), t5.alphaMap !== null ? (i6.push(`${n8}float inputs:opacity.connect = </Materials/Material_${t5.id}/Texture_${t5.alphaMap.id}_opacity.outputs:r>`), i6.push(`${n8}float inputs:opacityThreshold = 0.0001`), r5.push(s6(t5.alphaMap, "opacity"))) : i6.push(`${n8}float inputs:opacity = ${t5.opacity}`), t5.isMeshPhysicalMaterial && (i6.push(`${n8}float inputs:clearcoat = ${t5.clearcoat}`), i6.push(`${n8}float inputs:clearcoatRoughness = ${t5.clearcoatRoughness}`), i6.push(`${n8}float inputs:ior = ${t5.ior}`)), `
    def Material "Material_${t5.id}"
    {
        def Shader "PreviewSurface"
        {
            uniform token info:id = "UsdPreviewSurface"
${i6.join("\n")}
            int inputs:useSpecularWorkflow = 0
            token outputs:surface
        }

        token outputs:surface.connect = </Materials/Material_${t5.id}/PreviewSurface.outputs:surface>
        token inputs:frame:stPrimvarName = "st"

        def Shader "uvReader_st"
        {
            uniform token info:id = "UsdPrimvarReader_float2"
            token inputs:varname.connect = </Materials/Material_${t5.id}.inputs:frame:stPrimvarName>
            float2 inputs:fallback = (0.0, 0.0)
            float2 outputs:result
        }

${r5.join("\n")}

    }
`;
  }
  function Wm(t5) {
    return `(${t5.r}, ${t5.g}, ${t5.b})`;
  }
  function jm(t5) {
    return `(${t5.x}, ${t5.y})`;
  }
  var qm = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var Xm = false;
  var $m = false;
  var Ym = (Jm = ["quick-look", "scene-viewer", "webxr", "none"], (t5) => {
    try {
      const e8 = mu(t5), n8 = (e8.length ? e8[0].terms : []).filter((t6) => t6 && t6.type === "ident").map((t6) => t6.value).filter((t6) => Jm.indexOf(t6) > -1), i6 = /* @__PURE__ */ new Set();
      for (const t6 of n8)
        i6.add(t6);
      return i6;
    } catch (t6) {
    }
    return /* @__PURE__ */ new Set();
  });
  var Jm;
  var Km = "quick-look";
  var Zm = "scene-viewer";
  var Qm = "webxr";
  var tf = "none";
  var ef = Symbol("arButtonContainer");
  var nf = Symbol("enterARWithWebXR");
  var rf = Symbol("openSceneViewer");
  var sf = Symbol("openIOSARQuickLook");
  var af = Symbol("canActivateAR");
  var of = Symbol("arMode");
  var lf = Symbol("arModes");
  var hf = Symbol("arAnchor");
  var cf = Symbol("preload");
  var uf = Symbol("onARButtonContainerClick");
  var df = Symbol("onARStatus");
  var pf = Symbol("onARTracking");
  var mf = Symbol("onARTap");
  var ff = Symbol("selectARMode");
  var gf = Symbol("triggerLoad");
  var vf;
  var yf;
  var xf;
  var bf = Symbol("evaluate");
  var _f = Symbol("lastValue");
  var wf = class {
    constructor() {
      this[vf] = null;
    }
    static evaluatableFor(t5, e8 = wu) {
      if (t5 instanceof wf)
        return t5;
      if (t5.type === "number")
        return t5.unit === "%" ? new Tf(t5, e8) : t5;
      switch (t5.name.value) {
        case "calc":
          return new Lf(t5, e8);
        case "env":
          return new Af(t5);
      }
      return wu;
    }
    static evaluate(t5) {
      return t5 instanceof wf ? t5.evaluate() : t5;
    }
    static isConstant(t5) {
      return !(t5 instanceof wf) || t5.isConstant;
    }
    static applyIntrinsics(t5, e8) {
      const { basis: n8, keywords: i6 } = e8, { auto: r5 } = i6;
      return n8.map((e9, n9) => {
        const s6 = r5[n9] == null ? e9 : r5[n9];
        let a4 = t5[n9] ? t5[n9] : s6;
        if (a4.type === "ident") {
          const t6 = a4.value;
          t6 in i6 && (a4 = i6[t6][n9]);
        }
        return a4 != null && a4.type !== "ident" || (a4 = s6), a4.unit === "%" ? pu(a4.number / 100 * e9.number, e9.unit) : (a4 = Tu(a4, e9), a4.unit !== e9.unit ? e9 : a4);
      });
    }
    get isConstant() {
      return false;
    }
    evaluate() {
      return this.isConstant && this[_f] != null || (this[_f] = this[bf]()), this[_f];
    }
  };
  vf = _f;
  var Mf = Symbol("percentage");
  var Sf = Symbol("basis");
  var Tf = class extends wf {
    constructor(t5, e8) {
      super(), this[Mf] = t5, this[Sf] = e8;
    }
    get isConstant() {
      return true;
    }
    [bf]() {
      return pu(this[Mf].number / 100 * this[Sf].number, this[Sf].unit);
    }
  };
  var Ef = Symbol("identNode");
  var Af = class extends wf {
    constructor(t5) {
      super(), this[yf] = null;
      const e8 = t5.arguments.length ? t5.arguments[0].terms[0] : null;
      e8 != null && e8.type === "ident" && (this[Ef] = e8);
    }
    get isConstant() {
      return false;
    }
    [(yf = Ef, bf)]() {
      if (this[Ef] != null && this[Ef].value === "window-scroll-y") {
        return { type: "number", number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0, unit: null };
      }
      return wu;
    }
  };
  var Rf = /[\*\/]/;
  var Cf = Symbol("evalutor");
  var Lf = class extends wf {
    constructor(t5, e8 = wu) {
      if (super(), this[xf] = null, t5.arguments.length !== 1)
        return;
      const n8 = t5.arguments[0].terms.slice(), i6 = [];
      for (; n8.length; ) {
        const t6 = n8.shift();
        if (i6.length > 0) {
          const n9 = i6[i6.length - 1];
          if (n9.type === "operator" && Rf.test(n9.value)) {
            const n10 = i6.pop(), r5 = i6.pop();
            if (r5 == null)
              return;
            i6.push(new Of(n10, wf.evaluatableFor(r5, e8), wf.evaluatableFor(t6, e8)));
            continue;
          }
        }
        i6.push(t6.type === "operator" ? t6 : wf.evaluatableFor(t6, e8));
      }
      for (; i6.length > 2; ) {
        const [t6, n9, r5] = i6.splice(0, 3);
        if (n9.type !== "operator")
          return;
        i6.unshift(new Of(n9, wf.evaluatableFor(t6, e8), wf.evaluatableFor(r5, e8)));
      }
      i6.length === 1 && (this[Cf] = i6[0]);
    }
    get isConstant() {
      return this[Cf] == null || wf.isConstant(this[Cf]);
    }
    [(xf = Cf, bf)]() {
      return this[Cf] != null ? wf.evaluate(this[Cf]) : wu;
    }
  };
  var Pf = Symbol("operator");
  var Df = Symbol("left");
  var If = Symbol("right");
  var Of = class extends wf {
    constructor(t5, e8, n8) {
      super(), this[Pf] = t5, this[Df] = e8, this[If] = n8;
    }
    get isConstant() {
      return wf.isConstant(this[Df]) && wf.isConstant(this[If]);
    }
    [bf]() {
      const t5 = Tu(wf.evaluate(this[Df])), e8 = Tu(wf.evaluate(this[If])), { number: n8, unit: i6 } = t5, { number: r5, unit: s6 } = e8;
      if (s6 != null && i6 != null && s6 != i6)
        return wu;
      const a4 = i6 || s6;
      let o7;
      switch (this[Pf].value) {
        case "+":
          o7 = n8 + r5;
          break;
        case "-":
          o7 = n8 - r5;
          break;
        case "/":
          o7 = n8 / r5;
          break;
        case "*":
          o7 = n8 * r5;
          break;
        default:
          return wu;
      }
      return { type: "number", number: o7, unit: a4 };
    }
  };
  var Nf = Symbol("evaluatables");
  var Ff = Symbol("intrinsics");
  var Uf = class extends wf {
    constructor(t5, e8) {
      super(), this[Ff] = e8;
      const n8 = t5[0], i6 = n8 != null ? n8.terms : [];
      this[Nf] = e8.basis.map((t6, e9) => {
        const n9 = i6[e9];
        return n9 == null ? { type: "ident", value: "auto" } : n9.type === "ident" ? n9 : wf.evaluatableFor(n9, t6);
      });
    }
    get isConstant() {
      for (const t5 of this[Nf])
        if (!wf.isConstant(t5))
          return false;
      return true;
    }
    [bf]() {
      const t5 = this[Nf].map((t6) => wf.evaluate(t6));
      return wf.applyIntrinsics(t5, this[Ff]).map((t6) => t6.number);
    }
  };
  var kf;
  var Bf;
  var zf;
  var Hf;
  var Vf = Symbol("instances");
  var Gf = Symbol("activateListener");
  var Wf = Symbol("deactivateListener");
  var jf = Symbol("notifyInstances");
  var qf = Symbol("notify");
  var Xf = Symbol("callback");
  var $f = class {
    constructor(t5) {
      this[Xf] = t5;
    }
    static [jf]() {
      for (const t5 of $f[Vf])
        t5[qf]();
    }
    static [(kf = Vf, Gf)]() {
      window.addEventListener("scroll", this[jf], { passive: true });
    }
    static [Wf]() {
      window.removeEventListener("scroll", this[jf]);
    }
    observe() {
      $f[Vf].size === 0 && $f[Gf](), $f[Vf].add(this);
    }
    disconnect() {
      $f[Vf].delete(this), $f[Vf].size === 0 && $f[Wf]();
    }
    [qf]() {
      this[Xf]();
    }
  };
  $f[kf] = /* @__PURE__ */ new Set();
  var Yf = Symbol("computeStyleCallback");
  var Jf = Symbol("astWalker");
  var Kf = Symbol("dependencies");
  var Zf = Symbol("onScroll");
  var Qf = class {
    constructor(t5) {
      this[Bf] = {}, this[zf] = new _u(["function"]), this[Hf] = () => {
        this[Yf]({ relatedState: "window-scroll" });
      }, this[Yf] = t5;
    }
    observeEffectsFor(t5) {
      const e8 = {}, n8 = this[Kf];
      this[Jf].walk(t5, (t6) => {
        const { name: i6 } = t6, r5 = t6.arguments[0].terms[0];
        if (i6.value === "env" && r5 != null && r5.type === "ident" && r5.value === "window-scroll-y") {
          if (e8["window-scroll"] == null) {
            const t7 = "window-scroll" in n8 ? n8["window-scroll"] : new $f(this[Zf]);
            t7.observe(), delete n8["window-scroll"], e8["window-scroll"] = t7;
          }
        }
      });
      for (const t6 in n8) {
        n8[t6].disconnect();
      }
      this[Kf] = e8;
    }
    dispose() {
      for (const t5 in this[Kf]) {
        this[Kf][t5].disconnect();
      }
    }
  };
  Bf = Kf, zf = Jf, Hf = Zf;
  var tg = (t5) => {
    const e8 = t5.observeEffects || false, n8 = t5.intrinsics instanceof Function ? t5.intrinsics : () => t5.intrinsics;
    return (i6, r5) => {
      const s6 = i6.updated, a4 = i6.connectedCallback, o7 = i6.disconnectedCallback, l6 = Symbol(`${r5}StyleEffector`), h4 = Symbol(`${r5}StyleEvaluator`), c3 = Symbol(`${r5}UpdateEvaluator`), u3 = Symbol(`${r5}EvaluateAndSync`);
      Object.defineProperties(i6, { [l6]: { value: null, writable: true }, [h4]: { value: null, writable: true }, [c3]: { value: function() {
        const t6 = mu(this[r5]);
        this[h4] = new Uf(t6, n8(this)), this[l6] == null && e8 && (this[l6] = new Qf(() => this[u3]())), this[l6] != null && this[l6].observeEffectsFor(t6);
      } }, [u3]: { value: function() {
        if (this[h4] == null)
          return;
        const e9 = this[h4].evaluate();
        this[t5.updateHandler](e9);
      } }, updated: { value: function(t6) {
        t6.has(r5) && (this[c3](), this[u3]()), s6.call(this, t6);
      } }, connectedCallback: { value: function() {
        a4.call(this), this.requestUpdate(r5, this[r5]);
      } }, disconnectedCallback: { value: function() {
        o7.call(this), this[l6] != null && (this[l6].dispose(), this[l6] = null);
      } } });
    };
  };
  var eg = new g2();
  var ng = new V2();
  var ig = Object.freeze({ minimumRadius: 0, maximumRadius: 1 / 0, minimumPolarAngle: Math.PI / 8, maximumPolarAngle: Math.PI - Math.PI / 8, minimumAzimuthalAngle: -1 / 0, maximumAzimuthalAngle: 1 / 0, minimumFieldOfView: 10, maximumFieldOfView: 45, interactionPolicy: "always-allow", touchAction: "pan-y" });
  var rg = Math.PI / 8;
  var sg = 33;
  var ag = 34;
  var og = 37;
  var lg = 38;
  var hg = 39;
  var cg = 40;
  var ug = "user-interaction";
  var dg = "none";
  var pg = class extends i5 {
    constructor(t5, e8, n8) {
      super(), this.camera = t5, this.element = e8, this.scene = n8, this.sensitivity = 1, this.isUserChange = false, this._interactionEnabled = false, this._disableZoom = false, this.isUserPointing = false, this.enablePan = true, this.panProjection = new v2(), this.panPerPixel = 0, this.spherical = new Ko(), this.goalSpherical = new Ko(), this.thetaDamper = new du(), this.phiDamper = new du(), this.radiusDamper = new du(), this.logFov = Math.log(ig.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new du(), this.touchMode = null, this.pointers = [], this.startTime = 0, this.startPointerPosition = { clientX: 0, clientY: 0 }, this.lastSeparation = 0, this.touchDecided = false, this.onContext = (t6) => {
        if (this.enablePan)
          t6.preventDefault();
        else
          for (const t7 of this.pointers)
            this.onPointerUp(new PointerEvent("pointercancel", Object.assign(Object.assign({}, this.startPointerPosition), { pointerId: t7.id })));
      }, this.touchModeZoom = (t6, e9) => {
        if (!this._disableZoom) {
          const t7 = this.twoTouchDistance(this.pointers[0], this.pointers[1]), e10 = 0.04 * (this.lastSeparation - t7) * 50 / this.scene.height;
          this.lastSeparation = t7, this.userAdjustOrbit(0, 0, e10);
        }
        this.panPerPixel > 0 && this.movePan(t6, e9);
      }, this.disableScroll = (t6) => {
        t6.preventDefault();
      }, this.touchModeRotate = (t6, e9) => {
        const { touchAction: n9 } = this._options;
        if (!this.touchDecided && n9 !== "none") {
          this.touchDecided = true;
          const i6 = Math.abs(t6), r5 = Math.abs(e9);
          if (this.isUserChange && (n9 === "pan-y" && r5 > i6 || n9 === "pan-x" && i6 > r5))
            return void (this.touchMode = null);
          this.element.addEventListener("touchmove", this.disableScroll, { passive: false });
        }
        this.handleSinglePointerMove(t6, e9);
      }, this.onPointerDown = (t6) => {
        if (!this.canInteract || this.pointers.length > 2)
          return;
        const { element: e9 } = this;
        this.pointers.length === 0 && (e9.addEventListener("pointermove", this.onPointerMove), e9.addEventListener("pointerup", this.onPointerUp), this.touchMode = null, this.touchDecided = false, this.startPointerPosition.clientX = t6.clientX, this.startPointerPosition.clientY = t6.clientY, this.startTime = performance.now());
        try {
          e9.setPointerCapture(t6.pointerId);
        } catch (t7) {
        }
        this.pointers.push({ clientX: t6.clientX, clientY: t6.clientY, id: t6.pointerId }), this.isUserPointing = false, t6.pointerType === "touch" ? (this.isUserChange = !t6.altKey, this.onTouchChange(t6)) : (this.isUserChange = true, this.onMouseDown(t6));
      }, this.onPointerMove = (t6) => {
        const e9 = this.pointers.find((e10) => e10.id === t6.pointerId);
        if (e9 == null)
          return;
        const n9 = this.pointers.length, i6 = (t6.clientX - e9.clientX) / n9, r5 = (t6.clientY - e9.clientY) / n9;
        i6 === 0 && r5 === 0 || (e9.clientX = t6.clientX, e9.clientY = t6.clientY, t6.pointerType === "touch" ? (this.isUserChange = !t6.altKey, this.touchMode !== null && this.touchMode(i6, r5)) : (this.isUserChange = true, this.panPerPixel > 0 ? this.movePan(i6, r5) : this.handleSinglePointerMove(i6, r5)));
      }, this.onPointerUp = (t6) => {
        const { element: e9 } = this, n9 = this.pointers.findIndex((e10) => e10.id === t6.pointerId);
        n9 !== -1 && this.pointers.splice(n9, 1), this.panPerPixel > 0 && !t6.altKey && this.resetRadius(), this.pointers.length === 0 ? (e9.removeEventListener("pointermove", this.onPointerMove), e9.removeEventListener("pointerup", this.onPointerUp), e9.removeEventListener("touchmove", this.disableScroll), this.enablePan && this.recenter(t6)) : this.touchMode !== null && this.onTouchChange(t6), this.scene.element[kg].style.opacity = 0, e9.style.cursor = "grab", this.panPerPixel = 0, this.isUserPointing && this.dispatchEvent({ type: "pointer-change-end" });
      }, this.onWheel = (t6) => {
        if (!this.canInteract)
          return;
        this.isUserChange = true;
        const e9 = t6.deltaY * (t6.deltaMode == 1 ? 18 : 1) * 0.04 / 30;
        this.userAdjustOrbit(0, 0, e9), t6.preventDefault();
      }, this.onKeyDown = (t6) => {
        let e9 = true;
        const { isUserChange: n9 } = this;
        switch (this.isUserChange = true, t6.keyCode) {
          case sg:
            this.userAdjustOrbit(0, 0, 0.04);
            break;
          case ag:
            this.userAdjustOrbit(0, 0, -0.04);
            break;
          case lg:
            this.userAdjustOrbit(0, -rg, 0);
            break;
          case cg:
            this.userAdjustOrbit(0, rg, 0);
            break;
          case og:
            this.userAdjustOrbit(-rg, 0, 0);
            break;
          case hg:
            this.userAdjustOrbit(rg, 0, 0);
            break;
          default:
            e9 = false, this.isUserChange = n9;
        }
        e9 && t6.preventDefault();
      }, this._options = Object.assign({}, ig), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal();
    }
    get interactionEnabled() {
      return this._interactionEnabled;
    }
    enableInteraction() {
      if (this._interactionEnabled === false) {
        const { element: t5 } = this;
        t5.addEventListener("pointerdown", this.onPointerDown), t5.addEventListener("pointercancel", this.onPointerUp), this._disableZoom || t5.addEventListener("wheel", this.onWheel), t5.addEventListener("keydown", this.onKeyDown), t5.addEventListener("touchmove", () => {
        }, { passive: false }), t5.addEventListener("contextmenu", this.onContext), this.element.style.cursor = "grab", this._interactionEnabled = true, this.updateTouchActionStyle();
      }
    }
    disableInteraction() {
      if (this._interactionEnabled === true) {
        const { element: t5 } = this;
        t5.removeEventListener("pointerdown", this.onPointerDown), t5.removeEventListener("pointermove", this.onPointerMove), t5.removeEventListener("pointerup", this.onPointerUp), t5.removeEventListener("pointercancel", this.onPointerUp), t5.removeEventListener("wheel", this.onWheel), t5.removeEventListener("keydown", this.onKeyDown), t5.removeEventListener("contextmenu", this.onContext), t5.style.cursor = "", this.touchMode = null, this._interactionEnabled = false, this.updateTouchActionStyle();
      }
    }
    get options() {
      return this._options;
    }
    set disableZoom(t5) {
      this._disableZoom != t5 && (this._disableZoom = t5, t5 === true ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle());
    }
    getCameraSpherical(t5 = new Ko()) {
      return t5.copy(this.spherical);
    }
    getFieldOfView() {
      return this.camera.fov;
    }
    applyOptions(t5) {
      Object.assign(this._options, t5), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
    }
    updateNearFar(t5, e8) {
      this.camera.near = Math.max(t5, e8 / 1e3), this.camera.far = e8, this.camera.updateProjectionMatrix();
    }
    updateAspect(t5) {
      this.camera.aspect = t5, this.camera.updateProjectionMatrix();
    }
    setOrbit(t5 = this.goalSpherical.theta, e8 = this.goalSpherical.phi, n8 = this.goalSpherical.radius) {
      const { minimumAzimuthalAngle: i6, maximumAzimuthalAngle: r5, minimumPolarAngle: s6, maximumPolarAngle: a4, minimumRadius: o7, maximumRadius: l6 } = this._options, { theta: h4, phi: c3, radius: u3 } = this.goalSpherical, d3 = lu(t5, i6, r5);
      isFinite(i6) || isFinite(r5) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d3) + d3);
      const p3 = lu(e8, s6, a4), m3 = lu(n8, o7, l6);
      return (d3 !== h4 || p3 !== c3 || m3 !== u3) && (this.goalSpherical.theta = d3, this.goalSpherical.phi = p3, this.goalSpherical.radius = m3, this.goalSpherical.makeSafe(), true);
    }
    setRadius(t5) {
      this.goalSpherical.radius = t5, this.setOrbit();
    }
    setFieldOfView(t5) {
      const { minimumFieldOfView: e8, maximumFieldOfView: n8 } = this._options;
      t5 = lu(t5, e8, n8), this.goalLogFov = Math.log(t5);
    }
    setDamperDecayTime(t5) {
      this.thetaDamper.setDecayTime(t5), this.phiDamper.setDecayTime(t5), this.radiusDamper.setDecayTime(t5), this.fovDamper.setDecayTime(t5);
    }
    adjustOrbit(t5, e8, n8) {
      const { theta: i6, phi: r5, radius: s6 } = this.goalSpherical, { minimumRadius: a4, maximumRadius: o7, minimumFieldOfView: l6, maximumFieldOfView: h4 } = this._options, c3 = this.spherical.theta - i6, u3 = Math.PI - 1e-3, d3 = i6 - lu(t5, -u3 - c3, u3 - c3), p3 = r5 - e8, m3 = n8 === 0 ? 0 : ((n8 > 0 ? o7 : a4) - s6) / (Math.log(n8 > 0 ? h4 : l6) - this.goalLogFov), f3 = s6 + n8 * (isFinite(m3) ? m3 : 2 * (o7 - a4));
      if (this.setOrbit(d3, p3, f3), n8 !== 0) {
        const t6 = this.goalLogFov + n8;
        this.setFieldOfView(Math.exp(t6));
      }
    }
    jumpToGoal() {
      this.update(0, 1e4);
    }
    update(t5, e8) {
      if (this.isStationary())
        return;
      const { maximumPolarAngle: n8, maximumRadius: i6 } = this._options, r5 = this.spherical.theta - this.goalSpherical.theta;
      Math.abs(r5) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r5) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e8, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e8, n8), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e8, i6), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e8, 1), this.moveCamera();
    }
    updateTouchActionStyle() {
      const { style: t5 } = this.element;
      if (this._interactionEnabled) {
        const { touchAction: e8 } = this._options;
        this._disableZoom && e8 !== "none" ? t5.touchAction = "manipulation" : t5.touchAction = e8;
      } else
        t5.touchAction = "";
    }
    isStationary() {
      return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
    }
    dispatchChange() {
      const t5 = this.isUserChange ? ug : dg;
      this.dispatchEvent({ type: "change", source: t5 });
    }
    moveCamera() {
      this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Ct(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix()), this.dispatchChange();
    }
    get canInteract() {
      if (this._options.interactionPolicy == "allow-when-focused") {
        return this.element.getRootNode().activeElement === this.element;
      }
      return this._options.interactionPolicy === "always-allow";
    }
    userAdjustOrbit(t5, e8, n8) {
      this.adjustOrbit(t5 * this.sensitivity, e8 * this.sensitivity, n8), this.dispatchChange();
    }
    wrapAngle(t5) {
      const e8 = (t5 + Math.PI) / (2 * Math.PI);
      return 2 * (e8 - Math.floor(e8)) * Math.PI - Math.PI;
    }
    pixelLengthToSphericalAngle(t5) {
      return 2 * Math.PI * t5 / this.element.clientHeight;
    }
    twoTouchDistance(t5, e8) {
      const { clientX: n8, clientY: i6 } = t5, { clientX: r5, clientY: s6 } = e8, a4 = r5 - n8, o7 = s6 - i6;
      return Math.sqrt(a4 * a4 + o7 * o7);
    }
    handleSinglePointerMove(t5, e8) {
      const n8 = this.pixelLengthToSphericalAngle(t5), i6 = this.pixelLengthToSphericalAngle(e8);
      this.isUserPointing === false && (this.isUserPointing = true, this.dispatchEvent({ type: "pointer-change-start" })), this.userAdjustOrbit(n8, i6, 0);
    }
    initializePan() {
      const { theta: t5, phi: e8 } = this.spherical, n8 = t5 - this.scene.yaw;
      this.panPerPixel = 0.018 / this.scene.height, this.panProjection.set(-Math.cos(n8), -Math.cos(e8) * Math.sin(n8), 0, 0, Math.sin(e8), 0, Math.sin(n8), -Math.cos(e8) * Math.cos(n8), 0);
    }
    movePan(t5, e8) {
      const { scene: n8 } = this, i6 = ng.set(t5, e8, 0), r5 = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
      i6.multiplyScalar(r5);
      const s6 = n8.getTarget();
      s6.add(i6.applyMatrix3(this.panProjection)), n8.boundingSphere.clampPoint(s6, s6), n8.setTarget(s6.x, s6.y, s6.z), this.dispatchChange();
    }
    recenter(t5) {
      if (performance.now() > this.startTime + 300 || Math.abs(t5.clientX - this.startPointerPosition.clientX) > 2 || Math.abs(t5.clientY - this.startPointerPosition.clientY) > 2)
        return;
      const { scene: e8 } = this, n8 = e8.positionAndNormalFromPoint(e8.getNDC(t5.clientX, t5.clientY));
      if (n8 == null) {
        const { cameraTarget: t6 } = e8.element;
        e8.element.cameraTarget = "", e8.element.cameraTarget = t6, this.userAdjustOrbit(0, 0, 1);
      } else
        e8.target.worldToLocal(n8.position), e8.setTarget(n8.position.x, n8.position.y, n8.position.z);
    }
    resetRadius() {
      const { scene: t5 } = this, e8 = t5.positionAndNormalFromPoint(eg.set(0, 0));
      if (e8 == null)
        return;
      t5.target.worldToLocal(e8.position);
      const n8 = t5.getTarget(), { theta: i6, phi: r5 } = this.spherical, s6 = i6 - t5.yaw, a4 = ng.set(Math.sin(r5) * Math.sin(s6), Math.cos(r5), Math.sin(r5) * Math.cos(s6)), o7 = a4.dot(e8.position.sub(n8));
      n8.add(a4.multiplyScalar(o7)), t5.setTarget(n8.x, n8.y, n8.z), this.setOrbit(void 0, void 0, this.goalSpherical.radius - o7);
    }
    onTouchChange(t5) {
      if (this.pointers.length === 1)
        this.touchMode = this.touchModeRotate;
      else {
        if (this._disableZoom)
          return this.touchMode = null, void this.element.removeEventListener("touchmove", this.disableScroll);
        this.touchMode = this.touchDecided && this.touchMode === null ? null : this.touchModeZoom, this.touchDecided = true, this.element.addEventListener("touchmove", this.disableScroll, { passive: false }), this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]), this.enablePan && this.touchMode != null && (this.initializePan(), t5.altKey || (this.scene.element[kg].style.opacity = 1));
      }
    }
    onMouseDown(t5) {
      this.panPerPixel = 0, this.enablePan && (t5.button === 2 || t5.ctrlKey || t5.metaKey || t5.shiftKey) && (this.initializePan(), this.scene.element[kg].style.opacity = 1), this.element.style.cursor = "grabbing";
    }
  };
  var mg = (t5) => t5 < 0.5 ? 2 * t5 * t5 : (4 - 2 * t5) * t5 - 1;
  var fg = (t5, e8, n8 = mg) => (i6) => t5 + (e8 - t5) * n8(i6);
  var gg = (t5) => {
    const e8 = [], n8 = [];
    let i6 = t5.initialValue;
    for (let r5 = 0; r5 < t5.keyframes.length; ++r5) {
      const s6 = t5.keyframes[r5], { value: a4, frames: o7 } = s6, l6 = s6.ease || mg, h4 = fg(i6, a4, l6);
      e8.push(h4), n8.push(o7), i6 = a4;
    }
    return ((t6, e9) => {
      const n9 = e9.map((i7 = 0, (t7) => i7 += t7));
      var i7;
      return (e10) => {
        e10 = lu(e10, 0, 1), e10 *= n9[n9.length - 1];
        const i8 = n9.findIndex((t7) => t7 >= e10), r5 = i8 < 1 ? 0 : n9[i8 - 1], s6 = n9[i8];
        return t6[i8]((e10 - r5) / (s6 - r5));
      };
    })(e8, n8);
  };
  var vg = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var yg = gg({ initialValue: 0, keyframes: [{ frames: 5, value: -1 }, { frames: 1, value: -1 }, { frames: 8, value: 1 }, { frames: 1, value: 1 }, { frames: 5, value: 0 }, { frames: 18, value: 0 }] });
  var xg = gg({ initialValue: 0, keyframes: [{ frames: 1, value: 1 }, { frames: 5, value: 1 }, { frames: 1, value: 0 }, { frames: 6, value: 0 }] });
  var bg = ["front", "right", "back", "left"];
  var _g = ["upper-", "", "lower-"];
  var wg = "auto";
  var Mg = "when-focused";
  var Sg = "wiggle";
  var Tg = "always-allow";
  var Eg = "pan-y";
  var Ag = (t5) => {
    const e8 = t5.enablePan ? 30 : 45;
    return { basis: [Mu(pu(e8, "deg"))], keywords: { auto: [null] } };
  };
  var Rg = (t5) => {
    const e8 = t5.enablePan ? 12 : 25;
    return { basis: [Mu(pu(e8, "deg"))], keywords: { auto: [null] } };
  };
  var Cg = (() => {
    const t5 = mu("0deg 75deg 105%")[0].terms, e8 = Tu(t5[0]), n8 = Tu(t5[1]);
    return (t6) => {
      const i6 = t6[_p].idealCameraDistance();
      return { basis: [e8, n8, pu(i6, "m")], keywords: { auto: [null, null, pu(105, "%")] } };
    };
  })();
  var Lg = (t5) => {
    const e8 = 1.1 * t5[_p].boundingSphere.radius * (t5.enablePan ? 2 : 1);
    return { basis: [pu(-1 / 0, "rad"), pu(Math.PI / 8, "rad"), pu(e8, "m")], keywords: { auto: [null, null, null] } };
  };
  var Pg = (t5) => {
    const e8 = Cg(t5), n8 = new Uf([], e8).evaluate()[2];
    return { basis: [pu(1 / 0, "rad"), pu(Math.PI - Math.PI / 8, "rad"), pu(n8, "m")], keywords: { auto: [null, null, null] } };
  };
  var Dg = (t5) => {
    const e8 = t5[_p].boundingBox.getCenter(new V2());
    return { basis: [pu(e8.x, "m"), pu(e8.y, "m"), pu(e8.z, "m")], keywords: { auto: [null, null, null] } };
  };
  var Ig = Math.PI / 2;
  var Og = Math.PI / 3;
  var Ng = Ig / 2;
  var Fg = 2 * Math.PI;
  var Ug = Symbol("controls");
  var kg = Symbol("panElement");
  var Bg = Symbol("promptElement");
  var zg = Symbol("promptAnimatedContainer");
  var Hg = Symbol("fingerAnimatedContainers");
  var Vg = Symbol("deferInteractionPrompt");
  var Gg = Symbol("updateAria");
  var Wg = Symbol("updateCameraForRadius");
  var jg = Symbol("onBlur");
  var qg = Symbol("onFocus");
  var Xg = Symbol("onChange");
  var $g = Symbol("onPointerChange");
  var Yg = Symbol("waitingToPromptUser");
  var Jg = Symbol("userHasInteracted");
  var Kg = Symbol("promptElementVisibleTime");
  var Zg = Symbol("lastPromptOffset");
  var Qg = Symbol("focusedTime");
  var tv = Symbol("lastSpherical");
  var ev = Symbol("jumpCamera");
  var nv = Symbol("initialized");
  var iv = Symbol("maintainThetaPhi");
  var rv = Symbol("syncCameraOrbit");
  var sv = Symbol("syncFieldOfView");
  var av = Symbol("syncCameraTarget");
  var ov = Symbol("syncMinCameraOrbit");
  var lv = Symbol("syncMaxCameraOrbit");
  var hv = Symbol("syncMinFieldOfView");
  var cv = Symbol("syncMaxFieldOfView");
  var uv = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var dv2 = "auto";
  var pv = "manual";
  var mv = "auto";
  var fv = "eager";
  var gv = "interaction";
  var vv = Symbol("defaultProgressBarElement");
  var yv = Symbol("defaultProgressMaskElement");
  var xv = Symbol("posterContainerElement");
  var bv = Symbol("defaultPosterElement");
  var _v = Symbol("posterDismissalSource");
  var wv = Symbol("hidePoster");
  var Mv = Symbol("modelIsRevealed");
  var Sv = Symbol("updateProgressBar");
  var Tv = Symbol("lastReportedProgress");
  var Ev = Symbol("transitioned");
  var Av = Symbol("onTransitionEnd");
  var Rv = Symbol("ariaLabelCallToAction");
  var Cv = Symbol("onClick");
  var Lv = Symbol("onKeydown");
  var Pv = Symbol("onProgress");
  var Dv = class {
    constructor() {
      this.pluginCallbacks = [], this.register(function(t5) {
        return new ay(t5);
      }), this.register(function(t5) {
        return new oy(t5);
      }), this.register(function(t5) {
        return new ly(t5);
      }), this.register(function(t5) {
        return new cy(t5);
      }), this.register(function(t5) {
        return new uy(t5);
      }), this.register(function(t5) {
        return new hy(t5);
      });
    }
    register(t5) {
      return this.pluginCallbacks.indexOf(t5) === -1 && this.pluginCallbacks.push(t5), this;
    }
    unregister(t5) {
      return this.pluginCallbacks.indexOf(t5) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t5), 1), this;
    }
    parse(t5, e8, n8, i6) {
      typeof n8 == "object" && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), i6 = n8);
      const r5 = new sy(), s6 = [];
      for (let t6 = 0, e9 = this.pluginCallbacks.length; t6 < e9; t6++)
        s6.push(this.pluginCallbacks[t6](r5));
      r5.setPlugins(s6), r5.write(t5, e8, i6).catch(n8);
    }
    parseAsync(t5, e8) {
      const n8 = this;
      return new Promise(function(i6, r5) {
        n8.parse(t5, i6, r5, e8);
      });
    }
  };
  var Iv = 0;
  var Ov = 1;
  var Nv = 2;
  var Fv = 3;
  var Uv = 4;
  var kv = 5121;
  var Bv = 5123;
  var zv = 5126;
  var Hv = 5125;
  var Vv = 34962;
  var Gv = 34963;
  var Wv = 9728;
  var jv = 9729;
  var qv = 9984;
  var Xv = 9985;
  var $v = 9986;
  var Yv = 9987;
  var Jv = 33071;
  var Kv = 33648;
  var Zv = 10497;
  var Qv = {};
  Qv[1003] = Wv, Qv[1004] = qv, Qv[1005] = $v, Qv[1006] = jv, Qv[1007] = Xv, Qv[1008] = Yv, Qv[1001] = Jv, Qv[1e3] = Zv, Qv[1002] = Kv;
  var ty = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
  function ey(t5, e8) {
    return t5.length === e8.length && t5.every(function(t6, n8) {
      return t6 === e8[n8];
    });
  }
  function ny(t5) {
    return 4 * Math.ceil(t5 / 4);
  }
  function iy(t5, e8 = 0) {
    const n8 = ny(t5.byteLength);
    if (n8 !== t5.byteLength) {
      const i6 = new Uint8Array(n8);
      if (i6.set(new Uint8Array(t5)), e8 !== 0)
        for (let r5 = t5.byteLength; r5 < n8; r5++)
          i6[r5] = e8;
      return i6.buffer;
    }
    return t5;
  }
  var ry = null;
  var sy = class {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
    }
    setPlugins(t5) {
      this.plugins = t5;
    }
    async write(t5, e8, n8) {
      this.options = Object.assign({}, { binary: false, trs: false, onlyVisible: true, truncateDrawRange: true, embedImages: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, n8), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(t5), await Promise.all(this.pending);
      const i6 = this, r5 = i6.buffers, s6 = i6.json;
      n8 = i6.options;
      const a4 = i6.extensionsUsed, o7 = new Blob(r5, { type: "application/octet-stream" }), l6 = Object.keys(a4);
      if (l6.length > 0 && (s6.extensionsUsed = l6), s6.buffers && s6.buffers.length > 0 && (s6.buffers[0].byteLength = o7.size), n8.binary === true) {
        const t6 = new window.FileReader();
        t6.readAsArrayBuffer(o7), t6.onloadend = function() {
          const n9 = iy(t6.result), i7 = new DataView(new ArrayBuffer(8));
          i7.setUint32(0, n9.byteLength, true), i7.setUint32(4, 5130562, true);
          const r6 = iy(function(t7) {
            if (window.TextEncoder !== void 0)
              return new TextEncoder().encode(t7).buffer;
            const e9 = new Uint8Array(new ArrayBuffer(t7.length));
            for (let n10 = 0, i8 = t7.length; n10 < i8; n10++) {
              const i9 = t7.charCodeAt(n10);
              e9[n10] = i9 > 255 ? 32 : i9;
            }
            return e9.buffer;
          }(JSON.stringify(s6)), 32), a5 = new DataView(new ArrayBuffer(8));
          a5.setUint32(0, r6.byteLength, true), a5.setUint32(4, 1313821514, true);
          const o8 = new ArrayBuffer(12), l7 = new DataView(o8);
          l7.setUint32(0, 1179937895, true), l7.setUint32(4, 2, true);
          const h4 = 12 + a5.byteLength + r6.byteLength + i7.byteLength + n9.byteLength;
          l7.setUint32(8, h4, true);
          const c3 = new Blob([o8, a5, r6, i7, n9], { type: "application/octet-stream" }), u3 = new window.FileReader();
          u3.readAsArrayBuffer(c3), u3.onloadend = function() {
            e8(u3.result);
          };
        };
      } else if (s6.buffers && s6.buffers.length > 0) {
        const t6 = new window.FileReader();
        t6.readAsDataURL(o7), t6.onloadend = function() {
          const n9 = t6.result;
          s6.buffers[0].uri = n9, e8(s6);
        };
      } else
        e8(s6);
    }
    serializeUserData(t5, e8) {
      if (Object.keys(t5.userData).length === 0)
        return;
      const n8 = this.options, i6 = this.extensionsUsed;
      try {
        const r5 = JSON.parse(JSON.stringify(t5.userData));
        if (n8.includeCustomExtensions && r5.gltfExtensions) {
          e8.extensions === void 0 && (e8.extensions = {});
          for (const t6 in r5.gltfExtensions)
            e8.extensions[t6] = r5.gltfExtensions[t6], i6[t6] = true;
          delete r5.gltfExtensions;
        }
        Object.keys(r5).length > 0 && (e8.extras = r5);
      } catch (e9) {
        console.warn("THREE.GLTFExporter: userData of '" + t5.name + "' won't be serialized because of JSON.stringify error - " + e9.message);
      }
    }
    getUID(t5) {
      return this.uids.has(t5) || this.uids.set(t5, this.uid++), this.uids.get(t5);
    }
    isNormalizedNormalAttribute(t5) {
      if (this.cache.attributesNormalized.has(t5))
        return false;
      const e8 = new V2();
      for (let n8 = 0, i6 = t5.count; n8 < i6; n8++)
        if (Math.abs(e8.fromBufferAttribute(t5, n8).length() - 1) > 5e-4)
          return false;
      return true;
    }
    createNormalizedNormalAttribute(t5) {
      const e8 = this.cache;
      if (e8.attributesNormalized.has(t5))
        return e8.attributesNormalized.get(t5);
      const n8 = t5.clone(), i6 = new V2();
      for (let t6 = 0, e9 = n8.count; t6 < e9; t6++)
        i6.fromBufferAttribute(n8, t6), i6.x === 0 && i6.y === 0 && i6.z === 0 ? i6.setX(1) : i6.normalize(), n8.setXYZ(t6, i6.x, i6.y, i6.z);
      return e8.attributesNormalized.set(t5, n8), n8;
    }
    applyTextureTransform(t5, e8) {
      let n8 = false;
      const i6 = {};
      e8.offset.x === 0 && e8.offset.y === 0 || (i6.offset = e8.offset.toArray(), n8 = true), e8.rotation !== 0 && (i6.rotation = e8.rotation, n8 = true), e8.repeat.x === 1 && e8.repeat.y === 1 || (i6.scale = e8.repeat.toArray(), n8 = true), n8 && (t5.extensions = t5.extensions || {}, t5.extensions.KHR_texture_transform = i6, this.extensionsUsed.KHR_texture_transform = true);
    }
    buildMetalRoughTexture(t5, e8) {
      if (t5 === e8)
        return t5;
      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
      const n8 = t5 == null ? void 0 : t5.image, i6 = e8 == null ? void 0 : e8.image, r5 = Math.max((n8 == null ? void 0 : n8.width) || 0, (i6 == null ? void 0 : i6.width) || 0), s6 = Math.max((n8 == null ? void 0 : n8.height) || 0, (i6 == null ? void 0 : i6.height) || 0), a4 = document.createElement("canvas");
      a4.width = r5, a4.height = s6;
      const o7 = a4.getContext("2d");
      o7.fillStyle = "#00ffff", o7.fillRect(0, 0, r5, s6);
      const l6 = o7.getImageData(0, 0, r5, s6);
      if (n8) {
        o7.drawImage(n8, 0, 0, r5, s6);
        const t6 = o7.getImageData(0, 0, r5, s6).data;
        for (let e9 = 2; e9 < t6.length; e9 += 4)
          l6.data[e9] = t6[e9];
      }
      if (i6) {
        o7.drawImage(i6, 0, 0, r5, s6);
        const t6 = o7.getImageData(0, 0, r5, s6).data;
        for (let e9 = 1; e9 < t6.length; e9 += 4)
          l6.data[e9] = t6[e9];
      }
      o7.putImageData(l6, 0, 0);
      const h4 = (t5 || e8).clone();
      return h4.source = new I2(a4), h4;
    }
    processBuffer(t5) {
      const e8 = this.json, n8 = this.buffers;
      return e8.buffers || (e8.buffers = [{ byteLength: 0 }]), n8.push(t5), 0;
    }
    processBufferView(t5, e8, n8, i6, r5) {
      const s6 = this.json;
      let a4;
      s6.bufferViews || (s6.bufferViews = []), a4 = e8 === kv ? 1 : e8 === Bv ? 2 : 4;
      const o7 = ny(i6 * t5.itemSize * a4), l6 = new DataView(new ArrayBuffer(o7));
      let h4 = 0;
      for (let r6 = n8; r6 < n8 + i6; r6++)
        for (let n9 = 0; n9 < t5.itemSize; n9++) {
          let i7;
          t5.itemSize > 4 ? i7 = t5.array[r6 * t5.itemSize + n9] : n9 === 0 ? i7 = t5.getX(r6) : n9 === 1 ? i7 = t5.getY(r6) : n9 === 2 ? i7 = t5.getZ(r6) : n9 === 3 && (i7 = t5.getW(r6)), e8 === zv ? l6.setFloat32(h4, i7, true) : e8 === Hv ? l6.setUint32(h4, i7, true) : e8 === Bv ? l6.setUint16(h4, i7, true) : e8 === kv && l6.setUint8(h4, i7), h4 += a4;
        }
      const c3 = { buffer: this.processBuffer(l6.buffer), byteOffset: this.byteOffset, byteLength: o7 };
      r5 !== void 0 && (c3.target = r5), r5 === Vv && (c3.byteStride = t5.itemSize * a4), this.byteOffset += o7, s6.bufferViews.push(c3);
      return { id: s6.bufferViews.length - 1, byteLength: 0 };
    }
    processBufferViewImage(t5) {
      const e8 = this, n8 = e8.json;
      return n8.bufferViews || (n8.bufferViews = []), new Promise(function(i6) {
        const r5 = new window.FileReader();
        r5.readAsArrayBuffer(t5), r5.onloadend = function() {
          const t6 = iy(r5.result), s6 = { buffer: e8.processBuffer(t6), byteOffset: e8.byteOffset, byteLength: t6.byteLength };
          e8.byteOffset += t6.byteLength, i6(n8.bufferViews.push(s6) - 1);
        };
      });
    }
    processAccessor(t5, e8, n8, i6) {
      const r5 = this.options, s6 = this.json;
      let a4;
      if (t5.array.constructor === Float32Array)
        a4 = zv;
      else if (t5.array.constructor === Uint32Array)
        a4 = Hv;
      else if (t5.array.constructor === Uint16Array)
        a4 = Bv;
      else {
        if (t5.array.constructor !== Uint8Array)
          throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        a4 = kv;
      }
      if (n8 === void 0 && (n8 = 0), i6 === void 0 && (i6 = t5.count), r5.truncateDrawRange && e8 !== void 0 && e8.index === null) {
        const r6 = n8 + i6, s7 = e8.drawRange.count === 1 / 0 ? t5.count : e8.drawRange.start + e8.drawRange.count;
        n8 = Math.max(n8, e8.drawRange.start), (i6 = Math.min(r6, s7) - n8) < 0 && (i6 = 0);
      }
      if (i6 === 0)
        return null;
      const o7 = function(t6, e9, n9) {
        const i7 = { min: new Array(t6.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(t6.itemSize).fill(Number.NEGATIVE_INFINITY) };
        for (let r6 = e9; r6 < e9 + n9; r6++)
          for (let e10 = 0; e10 < t6.itemSize; e10++) {
            let n10;
            t6.itemSize > 4 ? n10 = t6.array[r6 * t6.itemSize + e10] : e10 === 0 ? n10 = t6.getX(r6) : e10 === 1 ? n10 = t6.getY(r6) : e10 === 2 ? n10 = t6.getZ(r6) : e10 === 3 && (n10 = t6.getW(r6)), i7.min[e10] = Math.min(i7.min[e10], n10), i7.max[e10] = Math.max(i7.max[e10], n10);
          }
        return i7;
      }(t5, n8, i6);
      let l6;
      e8 !== void 0 && (l6 = t5 === e8.index ? Gv : Vv);
      const h4 = this.processBufferView(t5, a4, n8, i6, l6), c3 = { bufferView: h4.id, byteOffset: h4.byteOffset, componentType: a4, count: i6, max: o7.max, min: o7.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[t5.itemSize] };
      return t5.normalized === true && (c3.normalized = true), s6.accessors || (s6.accessors = []), s6.accessors.push(c3) - 1;
    }
    processImage(t5, e8, n8, i6 = "image/png") {
      const r5 = this, s6 = r5.cache, a4 = r5.json, o7 = r5.options, l6 = r5.pending;
      s6.images.has(t5) || s6.images.set(t5, {});
      const h4 = s6.images.get(t5), c3 = i6 + ":flipY/" + n8.toString();
      if (h4[c3] !== void 0)
        return h4[c3];
      a4.images || (a4.images = []);
      const u3 = { mimeType: i6 };
      if (o7.embedImages) {
        const s7 = ry = ry || document.createElement("canvas");
        s7.width = Math.min(t5.width, o7.maxTextureSize), s7.height = Math.min(t5.height, o7.maxTextureSize);
        const a5 = s7.getContext("2d");
        if (n8 === true && (a5.translate(0, s7.height), a5.scale(1, -1)), typeof HTMLImageElement != "undefined" && t5 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t5 instanceof HTMLCanvasElement || typeof OffscreenCanvas != "undefined" && t5 instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && t5 instanceof ImageBitmap)
          a5.drawImage(t5, 0, 0, s7.width, s7.height);
        else {
          e8 !== 1023 && console.error("GLTFExporter: Only RGBAFormat is supported."), (t5.width > o7.maxTextureSize || t5.height > o7.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t5);
          const n9 = new Uint8ClampedArray(t5.height * t5.width * 4);
          for (let e9 = 0; e9 < n9.length; e9 += 4)
            n9[e9 + 0] = t5.data[e9 + 0], n9[e9 + 1] = t5.data[e9 + 1], n9[e9 + 2] = t5.data[e9 + 2], n9[e9 + 3] = t5.data[e9 + 3];
          a5.putImageData(new ImageData(n9, t5.width, t5.height), 0, 0);
        }
        o7.binary === true ? l6.push(new Promise(function(t6) {
          s7.toBlob(function(e9) {
            r5.processBufferViewImage(e9).then(function(e10) {
              u3.bufferView = e10, t6();
            });
          }, i6);
        })) : u3.uri = s7.toDataURL(i6);
      } else
        u3.uri = t5.src;
      const d3 = a4.images.push(u3) - 1;
      return h4[c3] = d3, d3;
    }
    processSampler(t5) {
      const e8 = this.json;
      e8.samplers || (e8.samplers = []);
      const n8 = { magFilter: Qv[t5.magFilter], minFilter: Qv[t5.minFilter], wrapS: Qv[t5.wrapS], wrapT: Qv[t5.wrapT] };
      return e8.samplers.push(n8) - 1;
    }
    processTexture(t5) {
      const e8 = this.cache, n8 = this.json;
      if (e8.textures.has(t5))
        return e8.textures.get(t5);
      n8.textures || (n8.textures = []);
      let i6 = t5.userData.mimeType;
      i6 === "image/webp" && (i6 = "image/png");
      const r5 = { sampler: this.processSampler(t5), source: this.processImage(t5.image, t5.format, t5.flipY, i6) };
      t5.name && (r5.name = t5.name), this._invokeAll(function(e9) {
        e9.writeTexture && e9.writeTexture(t5, r5);
      });
      const s6 = n8.textures.push(r5) - 1;
      return e8.textures.set(t5, s6), s6;
    }
    processMaterial(t5) {
      const e8 = this.cache, n8 = this.json;
      if (e8.materials.has(t5))
        return e8.materials.get(t5);
      if (t5.isShaderMaterial)
        return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      n8.materials || (n8.materials = []);
      const i6 = { pbrMetallicRoughness: {} };
      t5.isMeshStandardMaterial !== true && t5.isMeshBasicMaterial !== true && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const r5 = t5.color.toArray().concat([t5.opacity]);
      if (ey(r5, [1, 1, 1, 1]) || (i6.pbrMetallicRoughness.baseColorFactor = r5), t5.isMeshStandardMaterial ? (i6.pbrMetallicRoughness.metallicFactor = t5.metalness, i6.pbrMetallicRoughness.roughnessFactor = t5.roughness) : (i6.pbrMetallicRoughness.metallicFactor = 0.5, i6.pbrMetallicRoughness.roughnessFactor = 0.5), t5.metalnessMap || t5.roughnessMap) {
        const e9 = this.buildMetalRoughTexture(t5.metalnessMap, t5.roughnessMap), n9 = { index: this.processTexture(e9) };
        this.applyTextureTransform(n9, e9), i6.pbrMetallicRoughness.metallicRoughnessTexture = n9;
      }
      if (t5.map) {
        const e9 = { index: this.processTexture(t5.map) };
        this.applyTextureTransform(e9, t5.map), i6.pbrMetallicRoughness.baseColorTexture = e9;
      }
      if (t5.emissive) {
        const e9 = t5.emissive.clone().multiplyScalar(t5.emissiveIntensity), n9 = Math.max(e9.r, e9.g, e9.b);
        if (n9 > 1 && (e9.multiplyScalar(1 / n9), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n9 > 0 && (i6.emissiveFactor = e9.toArray()), t5.emissiveMap) {
          const e10 = { index: this.processTexture(t5.emissiveMap) };
          this.applyTextureTransform(e10, t5.emissiveMap), i6.emissiveTexture = e10;
        }
      }
      if (t5.normalMap) {
        const e9 = { index: this.processTexture(t5.normalMap) };
        t5.normalScale && t5.normalScale.x !== 1 && (e9.scale = t5.normalScale.x), this.applyTextureTransform(e9, t5.normalMap), i6.normalTexture = e9;
      }
      if (t5.aoMap) {
        const e9 = { index: this.processTexture(t5.aoMap), texCoord: 1 };
        t5.aoMapIntensity !== 1 && (e9.strength = t5.aoMapIntensity), this.applyTextureTransform(e9, t5.aoMap), i6.occlusionTexture = e9;
      }
      t5.transparent ? i6.alphaMode = "BLEND" : t5.alphaTest > 0 && (i6.alphaMode = "MASK", i6.alphaCutoff = t5.alphaTest), t5.side === 2 && (i6.doubleSided = true), t5.name !== "" && (i6.name = t5.name), this.serializeUserData(t5, i6), this._invokeAll(function(e9) {
        e9.writeMaterial && e9.writeMaterial(t5, i6);
      });
      const s6 = n8.materials.push(i6) - 1;
      return e8.materials.set(t5, s6), s6;
    }
    processMesh(t5) {
      const e8 = this.cache, n8 = this.json, i6 = [t5.geometry.uuid];
      if (Array.isArray(t5.material))
        for (let e9 = 0, n9 = t5.material.length; e9 < n9; e9++)
          i6.push(t5.material[e9].uuid);
      else
        i6.push(t5.material.uuid);
      const r5 = i6.join(":");
      if (e8.meshes.has(r5))
        return e8.meshes.get(r5);
      const s6 = t5.geometry;
      let a4;
      if (a4 = t5.isLineSegments ? Ov : t5.isLineLoop ? Nv : t5.isLine ? Fv : t5.isPoints ? Iv : t5.material.wireframe ? Ov : Uv, s6.isBufferGeometry !== true)
        throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
      const o7 = {}, l6 = {}, h4 = [], c3 = [], u3 = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, d3 = s6.getAttribute("normal");
      d3 === void 0 || this.isNormalizedNormalAttribute(d3) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), s6.setAttribute("normal", this.createNormalizedNormalAttribute(d3)));
      let p3 = null;
      for (let t6 in s6.attributes) {
        if (t6.slice(0, 5) === "morph")
          continue;
        const n9 = s6.attributes[t6];
        t6 = u3[t6] || t6.toUpperCase();
        if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t6) || (t6 = "_" + t6), e8.attributes.has(this.getUID(n9))) {
          l6[t6] = e8.attributes.get(this.getUID(n9));
          continue;
        }
        p3 = null;
        const i7 = n9.array;
        t6 !== "JOINTS_0" || i7 instanceof Uint16Array || i7 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p3 = new oe(new Uint16Array(i7), n9.itemSize, n9.normalized));
        const r6 = this.processAccessor(p3 || n9, s6);
        r6 !== null && (l6[t6] = r6, e8.attributes.set(this.getUID(n9), r6));
      }
      if (d3 !== void 0 && s6.setAttribute("normal", d3), Object.keys(l6).length === 0)
        return null;
      if (t5.morphTargetInfluences !== void 0 && t5.morphTargetInfluences.length > 0) {
        const n9 = [], i7 = [], r6 = {};
        if (t5.morphTargetDictionary !== void 0)
          for (const e9 in t5.morphTargetDictionary)
            r6[t5.morphTargetDictionary[e9]] = e9;
        for (let a5 = 0; a5 < t5.morphTargetInfluences.length; ++a5) {
          const o8 = {};
          let l7 = false;
          for (const t6 in s6.morphAttributes) {
            if (t6 !== "position" && t6 !== "normal") {
              l7 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l7 = true);
              continue;
            }
            const n10 = s6.morphAttributes[t6][a5], i8 = t6.toUpperCase(), r7 = s6.attributes[t6];
            if (e8.attributes.has(this.getUID(n10))) {
              o8[i8] = e8.attributes.get(this.getUID(n10));
              continue;
            }
            const h5 = n10.clone();
            if (!s6.morphTargetsRelative)
              for (let t7 = 0, e9 = n10.count; t7 < e9; t7++)
                h5.setXYZ(t7, n10.getX(t7) - r7.getX(t7), n10.getY(t7) - r7.getY(t7), n10.getZ(t7) - r7.getZ(t7));
            o8[i8] = this.processAccessor(h5, s6), e8.attributes.set(this.getUID(r7), o8[i8]);
          }
          c3.push(o8), n9.push(t5.morphTargetInfluences[a5]), t5.morphTargetDictionary !== void 0 && i7.push(r6[a5]);
        }
        o7.weights = n9, i7.length > 0 && (o7.extras = {}, o7.extras.targetNames = i7);
      }
      const m3 = Array.isArray(t5.material);
      if (m3 && s6.groups.length === 0)
        return null;
      const f3 = m3 ? t5.material : [t5.material], g3 = m3 ? s6.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
      for (let t6 = 0, n9 = g3.length; t6 < n9; t6++) {
        const n10 = { mode: a4, attributes: l6 };
        if (this.serializeUserData(s6, n10), c3.length > 0 && (n10.targets = c3), s6.index !== null) {
          let i8 = this.getUID(s6.index);
          g3[t6].start === void 0 && g3[t6].count === void 0 || (i8 += ":" + g3[t6].start + ":" + g3[t6].count), e8.attributes.has(i8) ? n10.indices = e8.attributes.get(i8) : (n10.indices = this.processAccessor(s6.index, s6, g3[t6].start, g3[t6].count), e8.attributes.set(i8, n10.indices)), n10.indices === null && delete n10.indices;
        }
        const i7 = this.processMaterial(f3[g3[t6].materialIndex]);
        i7 !== null && (n10.material = i7), h4.push(n10);
      }
      o7.primitives = h4, n8.meshes || (n8.meshes = []), this._invokeAll(function(e9) {
        e9.writeMesh && e9.writeMesh(t5, o7);
      });
      const v3 = n8.meshes.push(o7) - 1;
      return e8.meshes.set(r5, v3), v3;
    }
    processCamera(t5) {
      const e8 = this.json;
      e8.cameras || (e8.cameras = []);
      const n8 = t5.isOrthographicCamera, i6 = { type: n8 ? "orthographic" : "perspective" };
      return n8 ? i6.orthographic = { xmag: 2 * t5.right, ymag: 2 * t5.top, zfar: t5.far <= 0 ? 1e-3 : t5.far, znear: t5.near < 0 ? 0 : t5.near } : i6.perspective = { aspectRatio: t5.aspect, yfov: f2.degToRad(t5.fov), zfar: t5.far <= 0 ? 1e-3 : t5.far, znear: t5.near < 0 ? 0 : t5.near }, t5.name !== "" && (i6.name = t5.type), e8.cameras.push(i6) - 1;
    }
    processAnimation(t5, e8) {
      const n8 = this.json, i6 = this.nodeMap;
      n8.animations || (n8.animations = []);
      const r5 = (t5 = Dv.Utils.mergeMorphTargetTracks(t5.clone(), e8)).tracks, s6 = [], a4 = [];
      for (let t6 = 0; t6 < r5.length; ++t6) {
        const n9 = r5[t6], o7 = qo.parseTrackName(n9.name);
        let l6 = qo.findNode(e8, o7.nodeName);
        const h4 = ty[o7.propertyName];
        if (o7.objectName === "bones" && (l6 = l6.isSkinnedMesh === true ? l6.skeleton.getBoneByName(o7.objectIndex) : void 0), !l6 || !h4)
          return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n9.name), null;
        const c3 = 1;
        let u3, d3 = n9.values.length / n9.times.length;
        h4 === ty.morphTargetInfluences && (d3 /= l6.morphTargetInfluences.length), n9.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ? (u3 = "CUBICSPLINE", d3 /= 3) : u3 = n9.getInterpolation() === 2300 ? "STEP" : "LINEAR", a4.push({ input: this.processAccessor(new oe(n9.times, c3)), output: this.processAccessor(new oe(n9.values, d3)), interpolation: u3 }), s6.push({ sampler: a4.length - 1, target: { node: i6.get(l6), path: h4 } });
      }
      return n8.animations.push({ name: t5.name || "clip_" + n8.animations.length, samplers: a4, channels: s6 }), n8.animations.length - 1;
    }
    processSkin(t5) {
      const e8 = this.json, n8 = this.nodeMap, i6 = e8.nodes[n8.get(t5)], r5 = t5.skeleton;
      if (r5 === void 0)
        return null;
      const s6 = t5.skeleton.bones[0];
      if (s6 === void 0)
        return null;
      const a4 = [], o7 = new Float32Array(16 * r5.bones.length), l6 = new xt();
      for (let e9 = 0; e9 < r5.bones.length; ++e9)
        a4.push(n8.get(r5.bones[e9])), l6.copy(r5.boneInverses[e9]), l6.multiply(t5.bindMatrix).toArray(o7, 16 * e9);
      e8.skins === void 0 && (e8.skins = []), e8.skins.push({ inverseBindMatrices: this.processAccessor(new oe(o7, 16)), joints: a4, skeleton: n8.get(s6) });
      return i6.skin = e8.skins.length - 1;
    }
    processNode(t5) {
      const e8 = this.json, n8 = this.options, i6 = this.nodeMap;
      e8.nodes || (e8.nodes = []);
      const r5 = {};
      if (n8.trs) {
        const e9 = t5.quaternion.toArray(), n9 = t5.position.toArray(), i7 = t5.scale.toArray();
        ey(e9, [0, 0, 0, 1]) || (r5.rotation = e9), ey(n9, [0, 0, 0]) || (r5.translation = n9), ey(i7, [1, 1, 1]) || (r5.scale = i7);
      } else
        t5.matrixAutoUpdate && t5.updateMatrix(), ey(t5.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) === false && (r5.matrix = t5.matrix.elements);
      if (t5.name !== "" && (r5.name = String(t5.name)), this.serializeUserData(t5, r5), t5.isMesh || t5.isLine || t5.isPoints) {
        const e9 = this.processMesh(t5);
        e9 !== null && (r5.mesh = e9);
      } else
        t5.isCamera && (r5.camera = this.processCamera(t5));
      if (t5.isSkinnedMesh && this.skins.push(t5), t5.children.length > 0) {
        const e9 = [];
        for (let i7 = 0, r6 = t5.children.length; i7 < r6; i7++) {
          const r7 = t5.children[i7];
          if (r7.visible || n8.onlyVisible === false) {
            const t6 = this.processNode(r7);
            t6 !== null && e9.push(t6);
          }
        }
        e9.length > 0 && (r5.children = e9);
      }
      this._invokeAll(function(e9) {
        e9.writeNode && e9.writeNode(t5, r5);
      });
      const s6 = e8.nodes.push(r5) - 1;
      return i6.set(t5, s6), s6;
    }
    processScene(t5) {
      const e8 = this.json, n8 = this.options;
      e8.scenes || (e8.scenes = [], e8.scene = 0);
      const i6 = {};
      t5.name !== "" && (i6.name = t5.name), e8.scenes.push(i6);
      const r5 = [];
      for (let e9 = 0, i7 = t5.children.length; e9 < i7; e9++) {
        const i8 = t5.children[e9];
        if (i8.visible || n8.onlyVisible === false) {
          const t6 = this.processNode(i8);
          t6 !== null && r5.push(t6);
        }
      }
      r5.length > 0 && (i6.nodes = r5), this.serializeUserData(t5, i6);
    }
    processObjects(t5) {
      const e8 = new Nr();
      e8.name = "AuxScene";
      for (let n8 = 0; n8 < t5.length; n8++)
        e8.children.push(t5[n8]);
      this.processScene(e8);
    }
    processInput(t5) {
      const e8 = this.options;
      t5 = t5 instanceof Array ? t5 : [t5], this._invokeAll(function(e9) {
        e9.beforeParse && e9.beforeParse(t5);
      });
      const n8 = [];
      for (let e9 = 0; e9 < t5.length; e9++)
        t5[e9] instanceof Nr ? this.processScene(t5[e9]) : n8.push(t5[e9]);
      n8.length > 0 && this.processObjects(n8);
      for (let t6 = 0; t6 < this.skins.length; ++t6)
        this.processSkin(this.skins[t6]);
      for (let n9 = 0; n9 < e8.animations.length; ++n9)
        this.processAnimation(e8.animations[n9], t5[0]);
      this._invokeAll(function(e9) {
        e9.afterParse && e9.afterParse(t5);
      });
    }
    _invokeAll(t5) {
      for (let e8 = 0, n8 = this.plugins.length; e8 < n8; e8++)
        t5(this.plugins[e8]);
    }
  };
  var ay = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_lights_punctual";
    }
    writeNode(t5, e8) {
      if (!t5.isLight)
        return;
      if (!t5.isDirectionalLight && !t5.isPointLight && !t5.isSpotLight)
        return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t5);
      const n8 = this.writer, i6 = n8.json, r5 = n8.extensionsUsed, s6 = {};
      t5.name && (s6.name = t5.name), s6.color = t5.color.toArray(), s6.intensity = t5.intensity, t5.isDirectionalLight ? s6.type = "directional" : t5.isPointLight ? (s6.type = "point", t5.distance > 0 && (s6.range = t5.distance)) : t5.isSpotLight && (s6.type = "spot", t5.distance > 0 && (s6.range = t5.distance), s6.spot = {}, s6.spot.innerConeAngle = (t5.penumbra - 1) * t5.angle * -1, s6.spot.outerConeAngle = t5.angle), t5.decay !== void 0 && t5.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !t5.target || t5.target.parent === t5 && t5.target.position.x === 0 && t5.target.position.y === 0 && t5.target.position.z === -1 || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), r5[this.name] || (i6.extensions = i6.extensions || {}, i6.extensions[this.name] = { lights: [] }, r5[this.name] = true);
      const a4 = i6.extensions[this.name].lights;
      a4.push(s6), e8.extensions = e8.extensions || {}, e8.extensions[this.name] = { light: a4.length - 1 };
    }
  };
  var oy = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_unlit";
    }
    writeMaterial(t5, e8) {
      if (!t5.isMeshBasicMaterial)
        return;
      const n8 = this.writer.extensionsUsed;
      e8.extensions = e8.extensions || {}, e8.extensions[this.name] = {}, n8[this.name] = true, e8.pbrMetallicRoughness.metallicFactor = 0, e8.pbrMetallicRoughness.roughnessFactor = 0.9;
    }
  };
  var ly = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_pbrSpecularGlossiness";
    }
    writeMaterial(t5, e8) {
      if (!t5.isGLTFSpecularGlossinessMaterial)
        return;
      const n8 = this.writer, i6 = n8.extensionsUsed, r5 = {};
      e8.pbrMetallicRoughness.baseColorFactor && (r5.diffuseFactor = e8.pbrMetallicRoughness.baseColorFactor);
      const s6 = [1, 1, 1];
      if (t5.specular.toArray(s6, 0), r5.specularFactor = s6, r5.glossinessFactor = t5.glossiness, e8.pbrMetallicRoughness.baseColorTexture && (r5.diffuseTexture = e8.pbrMetallicRoughness.baseColorTexture), t5.specularMap) {
        const e9 = { index: n8.processTexture(t5.specularMap) };
        n8.applyTextureTransform(e9, t5.specularMap), r5.specularGlossinessTexture = e9;
      }
      e8.extensions = e8.extensions || {}, e8.extensions[this.name] = r5, i6[this.name] = true;
    }
  };
  var hy = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(t5, e8) {
      if (!t5.isMeshPhysicalMaterial)
        return;
      const n8 = this.writer, i6 = n8.extensionsUsed, r5 = {};
      if (r5.clearcoatFactor = t5.clearcoat, t5.clearcoatMap) {
        const e9 = { index: n8.processTexture(t5.clearcoatMap) };
        n8.applyTextureTransform(e9, t5.clearcoatMap), r5.clearcoatTexture = e9;
      }
      if (r5.clearcoatRoughnessFactor = t5.clearcoatRoughness, t5.clearcoatRoughnessMap) {
        const e9 = { index: n8.processTexture(t5.clearcoatRoughnessMap) };
        n8.applyTextureTransform(e9, t5.clearcoatRoughnessMap), r5.clearcoatRoughnessTexture = e9;
      }
      if (t5.clearcoatNormalMap) {
        const e9 = { index: n8.processTexture(t5.clearcoatNormalMap) };
        n8.applyTextureTransform(e9, t5.clearcoatNormalMap), r5.clearcoatNormalTexture = e9;
      }
      e8.extensions = e8.extensions || {}, e8.extensions[this.name] = r5, i6[this.name] = true;
    }
  };
  var cy = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_transmission";
    }
    writeMaterial(t5, e8) {
      if (!t5.isMeshPhysicalMaterial || t5.transmission === 0)
        return;
      const n8 = this.writer, i6 = n8.extensionsUsed, r5 = {};
      if (r5.transmissionFactor = t5.transmission, t5.transmissionMap) {
        const e9 = { index: n8.processTexture(t5.transmissionMap) };
        n8.applyTextureTransform(e9, t5.transmissionMap), r5.transmissionTexture = e9;
      }
      e8.extensions = e8.extensions || {}, e8.extensions[this.name] = r5, i6[this.name] = true;
    }
  };
  var uy = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_volume";
    }
    writeMaterial(t5, e8) {
      if (!t5.isMeshPhysicalMaterial || t5.transmission === 0)
        return;
      const n8 = this.writer, i6 = n8.extensionsUsed, r5 = {};
      if (r5.thicknessFactor = t5.thickness, t5.thicknessMap) {
        const e9 = { index: n8.processTexture(t5.thicknessMap) };
        n8.applyTextureTransform(e9, t5.thicknessMap), r5.thicknessTexture = e9;
      }
      r5.attenuationDistance = t5.attenuationDistance, r5.attenuationColor = t5.attenuationColor.toArray(), e8.extensions = e8.extensions || {}, e8.extensions[this.name] = r5, i6[this.name] = true;
    }
  };
  Dv.Utils = { insertKeyframe: function(t5, e8) {
    const n8 = 1e-3, i6 = t5.getValueSize(), r5 = new t5.TimeBufferType(t5.times.length + 1), s6 = new t5.ValueBufferType(t5.values.length + i6), a4 = t5.createInterpolant(new t5.ValueBufferType(i6));
    let o7;
    if (t5.times.length === 0) {
      r5[0] = e8;
      for (let t6 = 0; t6 < i6; t6++)
        s6[t6] = 0;
      o7 = 0;
    } else if (e8 < t5.times[0]) {
      if (Math.abs(t5.times[0] - e8) < n8)
        return 0;
      r5[0] = e8, r5.set(t5.times, 1), s6.set(a4.evaluate(e8), 0), s6.set(t5.values, i6), o7 = 0;
    } else if (e8 > t5.times[t5.times.length - 1]) {
      if (Math.abs(t5.times[t5.times.length - 1] - e8) < n8)
        return t5.times.length - 1;
      r5[r5.length - 1] = e8, r5.set(t5.times, 0), s6.set(t5.values, 0), s6.set(a4.evaluate(e8), t5.values.length), o7 = r5.length - 1;
    } else
      for (let l6 = 0; l6 < t5.times.length; l6++) {
        if (Math.abs(t5.times[l6] - e8) < n8)
          return l6;
        if (t5.times[l6] < e8 && t5.times[l6 + 1] > e8) {
          r5.set(t5.times.slice(0, l6 + 1), 0), r5[l6 + 1] = e8, r5.set(t5.times.slice(l6 + 1), l6 + 2), s6.set(t5.values.slice(0, (l6 + 1) * i6), 0), s6.set(a4.evaluate(e8), (l6 + 1) * i6), s6.set(t5.values.slice((l6 + 1) * i6), (l6 + 2) * i6), o7 = l6 + 1;
          break;
        }
      }
    return t5.times = r5, t5.values = s6, o7;
  }, mergeMorphTargetTracks: function(t5, e8) {
    const n8 = [], i6 = {}, r5 = t5.tracks;
    for (let t6 = 0; t6 < r5.length; ++t6) {
      let s6 = r5[t6];
      const a4 = qo.parseTrackName(s6.name), o7 = qo.findNode(e8, a4.nodeName);
      if (a4.propertyName !== "morphTargetInfluences" || a4.propertyIndex === void 0) {
        n8.push(s6);
        continue;
      }
      if (s6.createInterpolant !== s6.InterpolantFactoryMethodDiscrete && s6.createInterpolant !== s6.InterpolantFactoryMethodLinear) {
        if (s6.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), s6 = s6.clone(), s6.setInterpolation(2301);
      }
      const l6 = o7.morphTargetInfluences.length, h4 = o7.morphTargetDictionary[a4.propertyIndex];
      if (h4 === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a4.propertyIndex);
      let c3;
      if (i6[o7.uuid] === void 0) {
        c3 = s6.clone();
        const t7 = new c3.ValueBufferType(l6 * c3.times.length);
        for (let e9 = 0; e9 < c3.times.length; e9++)
          t7[e9 * l6 + h4] = c3.values[e9];
        c3.name = (a4.nodeName || "") + ".morphTargetInfluences", c3.values = t7, i6[o7.uuid] = c3, n8.push(c3);
        continue;
      }
      const u3 = s6.createInterpolant(new s6.ValueBufferType(1));
      c3 = i6[o7.uuid];
      for (let t7 = 0; t7 < c3.times.length; t7++)
        c3.values[t7 * l6 + h4] = u3.evaluate(c3.times[t7]);
      for (let t7 = 0; t7 < s6.times.length; t7++) {
        const e9 = this.insertKeyframe(c3, s6.times[t7]);
        c3.values[e9 * l6 + h4] = s6.values[t7];
      }
    }
    return t5.tracks = n8, t5;
  } };
  var dy = (t5) => t5.material !== void 0 && t5.userData && t5.userData.variantMaterials && !!Array.from(t5.userData.variantMaterials.values()).filter((t6) => py(t6.material));
  var py = (t5) => t5 && t5.isMaterial && !Array.isArray(t5);
  var my = class {
    constructor(t5) {
      this.writer = t5, this.name = "KHR_materials_variants", this.variantNames = [];
    }
    beforeParse(t5) {
      const e8 = /* @__PURE__ */ new Set();
      for (const n8 of t5)
        n8.traverse((t6) => {
          if (!dy(t6))
            return;
          const n9 = t6.userData.variantMaterials, i6 = t6.userData.variantData;
          for (const [t7, r5] of i6) {
            const i7 = n9.get(r5.index);
            py(i7.material) && e8.add(t7);
          }
        });
      e8.forEach((t6) => this.variantNames.push(t6));
    }
    writeMesh(t5, e8) {
      if (!dy(t5))
        return;
      const n8 = t5.userData, i6 = n8.variantMaterials, r5 = n8.variantData, s6 = /* @__PURE__ */ new Map(), a4 = /* @__PURE__ */ new Map(), o7 = Array.from(r5.values()).sort((t6, e9) => t6.index - e9.index);
      for (const [t6, e9] of o7.entries())
        a4.set(e9.index, t6);
      for (const t6 of r5.values()) {
        const e9 = i6.get(t6.index).material;
        if (!py(e9))
          continue;
        const n9 = this.writer.processMaterial(e9);
        s6.has(n9) || s6.set(n9, { material: n9, variants: [] }), s6.get(n9).variants.push(a4.get(t6.index));
      }
      const l6 = Array.from(s6.values()).map((t6) => t6.variants.sort((t7, e9) => t7 - e9) && t6).sort((t6, e9) => t6.material - e9.material);
      if (l6.length === 0)
        return;
      const h4 = py(n8.originalMaterial) ? this.writer.processMaterial(n8.originalMaterial) : -1;
      for (const t6 of e8.primitives)
        h4 >= 0 && (t6.material = h4), t6.extensions = t6.extensions || {}, t6.extensions[this.name] = { mappings: l6 };
    }
    afterParse() {
      if (this.variantNames.length === 0)
        return;
      const t5 = this.writer.json;
      t5.extensions = t5.extensions || {};
      const e8 = this.variantNames.map((t6) => ({ name: t6 }));
      t5.extensions[this.name] = { variants: e8 }, this.writer.extensionsUsed[this.name] = true;
    }
  };
  var fy = Symbol("correlatedObjects");
  var gy = Symbol("sourceObject");
  var vy = Symbol("onUpdate");
  var yy = class {
    constructor(t5, e8, n8 = null) {
      this[vy] = t5, this[gy] = e8, this[fy] = n8;
    }
  };
  var xy = new uo();
  var by = new re();
  var _y = new rn(2, 2);
  var wy = 0;
  var My = Symbol("threeTexture");
  var Sy = class extends yy {
    get [My]() {
      var t5;
      return console.assert(this[fy] != null && this[fy].size > 0, "Image correlated object is undefined"), (t5 = this[fy]) === null || t5 === void 0 ? void 0 : t5.values().next().value;
    }
    constructor(t5, e8, n8) {
      super(t5, n8 = n8 != null ? n8 : { name: e8 && e8.image && e8.image.src ? e8.image.src.split("/").pop() : "adhoc_image", uri: e8 && e8.image && e8.image.src ? e8.image.src : "adhoc_image" + wy++ }, new Set(e8 ? [e8] : []));
    }
    get name() {
      return this[gy].name || "";
    }
    get uri() {
      return this[gy].uri;
    }
    get bufferView() {
      return this[gy].bufferView;
    }
    get type() {
      return this.uri != null ? "external" : "embedded";
    }
    set name(t5) {
      this[gy].name = t5;
    }
    async setURI(t5) {
      this[gy].uri = t5, this[gy].name = t5.split("/").pop();
      const e8 = await new Promise((e9, n9) => {
        xy.load(t5, e9, void 0, n9);
      }), n8 = this[My];
      n8.image = e8, n8.needsUpdate = true, this[vy]();
    }
    async createThumbnail(t5, e8) {
      const n8 = new Nr();
      by.map = this[My];
      const i6 = new Fe(_y, by);
      n8.add(i6);
      const r5 = new mn(-1, 1, 1, -1, 0, 1), { threeRenderer: s6 } = Fd.singleton, a4 = new k2(t5, e8);
      s6.setRenderTarget(a4), s6.render(n8, r5), s6.setRenderTarget(null);
      const o7 = new Uint8Array(t5 * e8 * 4);
      s6.readRenderTargetPixels(a4, 0, 0, t5, e8, o7), Kd.width = t5, Kd.height = e8;
      const l6 = Kd.getContext("2d"), h4 = l6.createImageData(t5, e8);
      return h4.data.set(o7), l6.putImageData(h4, 0, 0), new Promise(async (t6, e9) => {
        Kd.toBlob((n9) => {
          if (!n9)
            return e9("Failed to capture thumbnail.");
          t6(URL.createObjectURL(n9));
        }, "image/png");
      });
    }
  };
  var Ty;
  var Ey;
  !function(t5) {
    t5[t5.Nearest = 9728] = "Nearest", t5[t5.Linear = 9729] = "Linear", t5[t5.NearestMipmapNearest = 9984] = "NearestMipmapNearest", t5[t5.LinearMipmapNearest = 9985] = "LinearMipmapNearest", t5[t5.NearestMipmapLinear = 9986] = "NearestMipmapLinear", t5[t5.LinearMipmapLinear = 9987] = "LinearMipmapLinear";
  }(Ty || (Ty = {})), function(t5) {
    t5[t5.ClampToEdge = 33071] = "ClampToEdge", t5[t5.MirroredRepeat = 33648] = "MirroredRepeat", t5[t5.Repeat = 10497] = "Repeat";
  }(Ey || (Ey = {}));
  var Ay = (() => {
    const t5 = [Ty.Nearest, Ty.Linear, Ty.NearestMipmapNearest, Ty.LinearMipmapLinear, Ty.NearestMipmapLinear, Ty.LinearMipmapLinear];
    return (e8) => t5.indexOf(e8) > -1;
  })();
  var Ry = (() => {
    const t5 = [Ty.Nearest, Ty.Linear];
    return (e8) => t5.indexOf(e8) > -1;
  })();
  var Cy = (() => {
    const t5 = [Ey.ClampToEdge, Ey.MirroredRepeat, Ey.Repeat];
    return (e8) => t5.indexOf(e8) > -1;
  })();
  var Ly = Symbol("threeTextures");
  var Py = Symbol("setProperty");
  var Dy = Symbol("sourceSampler");
  var Iy = class extends yy {
    get [Ly]() {
      return console.assert(this[fy] != null && this[fy].size > 0, "Sampler correlated object is undefined"), this[fy];
    }
    get [Dy]() {
      return console.assert(this[gy] != null, "Sampler source is undefined"), this[gy];
    }
    constructor(t5, e8, n8) {
      (n8 = n8 != null ? n8 : {}).minFilter == null && (n8.minFilter = e8 ? e8.minFilter : Ty.LinearMipmapLinear), n8.magFilter == null && (n8.magFilter = e8 ? e8.magFilter : Ty.Linear), n8.wrapS == null && (n8.wrapS = e8 ? e8.wrapS : Ey.Repeat), n8.wrapT == null && (n8.wrapT = e8 ? e8.wrapT : Ey.Repeat), super(t5, n8, new Set(e8 ? [e8] : []));
    }
    get name() {
      return this[gy].name || "";
    }
    get minFilter() {
      return this[Dy].minFilter;
    }
    get magFilter() {
      return this[Dy].magFilter;
    }
    get wrapS() {
      return this[Dy].wrapS;
    }
    get wrapT() {
      return this[Dy].wrapT;
    }
    setMinFilter(t5) {
      this[Py]("minFilter", t5);
    }
    setMagFilter(t5) {
      this[Py]("magFilter", t5);
    }
    setWrapS(t5) {
      this[Py]("wrapS", t5);
    }
    setWrapT(t5) {
      this[Py]("wrapT", t5);
    }
    [Py](t5, e8) {
      const n8 = this[Dy];
      if (n8 != null) {
        if (((t6, e9) => {
          switch (t6) {
            case "minFilter":
              return Ay(e9);
            case "magFilter":
              return Ry(e9);
            case "wrapS":
            case "wrapT":
              return Cy(e9);
            default:
              throw new Error(`Cannot configure property "${t6}" on Sampler`);
          }
        })(t5, e8)) {
          n8[t5] = e8;
          for (const n9 of this[Ly])
            n9[t5] = e8, n9.needsUpdate = true;
        }
        this[vy]();
      }
    }
  };
  var Oy = Symbol("image");
  var Ny = Symbol("sampler");
  var Fy = class extends yy {
    constructor(t5, e8, n8 = null, i6 = null, r5 = null) {
      super(t5, n8 || {}, new Set(e8 ? [e8] : [])), this[Ny] = new Iy(t5, e8, i6), this[Oy] = new Sy(t5, e8, r5);
    }
    get name() {
      return this[gy].name || "";
    }
    set name(t5) {
      this[gy].name = t5;
    }
    get sampler() {
      return this[Ny];
    }
    get source() {
      return this[Oy];
    }
  };
  var Uy;
  var ky;
  var By = Symbol("texture");
  var zy = Symbol("transform");
  var Hy = Symbol("materials");
  var Vy = Symbol("usage");
  var Gy;
  !function(t5) {
    t5[t5.Base = 0] = "Base", t5[t5.MetallicRoughness = 1] = "MetallicRoughness", t5[t5.Normal = 2] = "Normal", t5[t5.Occlusion = 3] = "Occlusion", t5[t5.Emissive = 4] = "Emissive";
  }(Gy || (Gy = {}));
  var Wy = class {
    constructor(t5, e8, n8, i6, r5, s6) {
      if (this[Uy] = null, this[ky] = { rotation: 0, scale: new g2(1, 1), offset: new g2(0, 0) }, s6 && n8) {
        const e9 = r5.textures ? r5.textures[s6.index] : null, i7 = e9 && r5.samplers ? r5.samplers[e9.sampler] : null, a4 = e9 && r5.images ? r5.images[e9.source] : null;
        this[zy].rotation = n8.rotation, this[zy].scale.copy(n8.repeat), this[zy].offset.copy(n8.offset), this[By] = new Fy(t5, n8, e9, i7, a4);
      }
      this.onUpdate = t5, this[Hy] = i6, this[Vy] = e8;
    }
    get texture() {
      return this[By];
    }
    setTexture(t5) {
      const e8 = t5 != null ? t5.source[My] : null;
      let n8 = 3001;
      if (this[By] = t5, this[Hy])
        for (const t6 of this[Hy]) {
          switch (this[Vy]) {
            case Gy.Base:
              t6.map = e8;
              break;
            case Gy.MetallicRoughness:
              n8 = 3e3, t6.metalnessMap = e8, t6.roughnessMap = e8;
              break;
            case Gy.Normal:
              n8 = 3e3, t6.normalMap = e8;
              break;
            case Gy.Occlusion:
              n8 = 3e3, t6.aoMap = e8;
              break;
            case Gy.Emissive:
              t6.emissiveMap = e8;
          }
          t6.needsUpdate = true;
        }
      e8 && (e8.encoding = n8, e8.rotation = this[zy].rotation, e8.repeat = this[zy].scale, e8.offset = this[zy].offset), this.onUpdate();
    }
  };
  Uy = By, ky = zy;
  var jy = Symbol("threeMaterials");
  var qy = Symbol("baseColorTexture");
  var Xy = Symbol("metallicRoughnessTexture");
  var $y = class extends yy {
    constructor(t5, e8, n8, i6) {
      super(t5, n8, i6), n8.baseColorFactor == null && (n8.baseColorFactor = [1, 1, 1, 1]), n8.roughnessFactor == null && (n8.roughnessFactor = 1), n8.metallicFactor == null && (n8.metallicFactor = 1);
      const { baseColorTexture: r5, metallicRoughnessTexture: s6 } = n8, { map: a4, metalnessMap: o7 } = i6.values().next().value;
      this[qy] = new Wy(t5, Gy.Base, a4, i6, e8, r5 || null), this[Xy] = new Wy(t5, Gy.MetallicRoughness, o7, i6, e8, s6 || null);
    }
    get [jy]() {
      return this[fy];
    }
    get baseColorFactor() {
      return this[gy].baseColorFactor;
    }
    get metallicFactor() {
      return this[gy].metallicFactor;
    }
    get roughnessFactor() {
      return this[gy].roughnessFactor;
    }
    get baseColorTexture() {
      return this[qy];
    }
    get metallicRoughnessTexture() {
      return this[Xy];
    }
    setBaseColorFactor(t5) {
      for (const e8 of this[jy])
        e8.color.fromArray(t5), e8.opacity = t5[3];
      this[gy].baseColorFactor = t5, this[vy]();
    }
    setMetallicFactor(t5) {
      for (const e8 of this[jy])
        e8.metalness = t5;
      this[gy].metallicFactor = t5, this[vy]();
    }
    setRoughnessFactor(t5) {
      for (const e8 of this[jy])
        e8.roughness = t5;
      this[gy].roughnessFactor = t5, this[vy]();
    }
  };
  var Yy;
  var Jy = Symbol("pbrMetallicRoughness");
  var Ky = Symbol("normalTexture");
  var Zy = Symbol("occlusionTexture");
  var Qy = Symbol("emissiveTexture");
  var tx = Symbol("backingThreeMaterial");
  var ex = Symbol("applyAlphaCutoff");
  var nx = Symbol("lazyLoadGLTFInfo");
  var ix = Symbol("initialize");
  var rx = Symbol("getLoadedMaterial");
  var sx = Symbol("ensureMaterialIsLoaded");
  var ax = Symbol("gltfIndex");
  var ox = Symbol("setActive");
  var lx = Symbol("variantIndices");
  var hx = Symbol("isActive");
  var cx = Symbol("variantSet");
  var ux = Symbol("modelVariants");
  var dx = class extends yy {
    constructor(t5, e8, n8, i6, r5, s6, a4, o7) {
      super(t5, n8, a4), this[Yy] = /* @__PURE__ */ new Set(), this[ax] = i6, this[hx] = r5, this[ux] = s6, o7 == null ? this[ix](e8) : this[nx] = o7;
    }
    get [(Yy = cx, tx)]() {
      return this[fy].values().next().value;
    }
    [ix](t5) {
      const e8 = this[vy], n8 = this[gy], i6 = this[fy];
      n8.extensions && n8.extensions.KHR_materials_pbrSpecularGlossiness && console.warn(`Material ${n8.name} uses a deprecated extension
          "KHR_materials_pbrSpecularGlossiness", please use
          "pbrMetallicRoughness" instead. Specular Glossiness materials are
          currently supported for rendering, but not for our scene-graph API,
          nor for auto-generation of USDZ for Quick Look.`), n8.pbrMetallicRoughness == null && (n8.pbrMetallicRoughness = {}), this[Jy] = new $y(e8, t5, n8.pbrMetallicRoughness, i6), n8.emissiveFactor == null && (n8.emissiveFactor = [0, 0, 0]), n8.doubleSided == null && (n8.doubleSided = false), n8.alphaMode == null && (n8.alphaMode = "OPAQUE"), n8.alphaCutoff == null && (n8.alphaCutoff = 0.5);
      const { normalTexture: r5, occlusionTexture: s6, emissiveTexture: a4 } = n8, { normalMap: o7, aoMap: l6, emissiveMap: h4 } = i6.values().next().value;
      this[Ky] = new Wy(e8, Gy.Normal, o7, i6, t5, r5 || null), this[Zy] = new Wy(e8, Gy.Occlusion, l6, i6, t5, s6 || null), this[Qy] = new Wy(e8, Gy.Emissive, h4, i6, t5, a4 || null);
    }
    async [rx]() {
      if (this[nx] != null) {
        const { set: t5, material: e8 } = await this[nx].doLazyLoad();
        return this[fy] = t5, this[ix](this[nx].gltf), this[nx] = void 0, this.ensureLoaded = async () => {
        }, e8;
      }
      return this[fy].values().next().value;
    }
    [sx]() {
      if (this[nx] != null)
        throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`);
    }
    async ensureLoaded() {
      await this[rx]();
    }
    get isLoaded() {
      return this[nx] == null;
    }
    get isActive() {
      return this[hx];
    }
    [ox](t5) {
      this[hx] = t5;
    }
    get name() {
      return this[gy].name;
    }
    set name(t5) {
      const e8 = this[gy];
      if (e8 != null && (e8.name = t5), this[fy] != null)
        for (const e9 of this[fy])
          e9.name = t5;
    }
    get pbrMetallicRoughness() {
      return this[sx](), this[Jy];
    }
    get normalTexture() {
      return this[sx](), this[Ky];
    }
    get occlusionTexture() {
      return this[sx](), this[Zy];
    }
    get emissiveTexture() {
      return this[sx](), this[Qy];
    }
    get emissiveFactor() {
      return this[sx](), this[gy].emissiveFactor;
    }
    get index() {
      return this[ax];
    }
    [lx]() {
      return this[cx];
    }
    hasVariant(t5) {
      const e8 = this[ux].get(t5);
      return e8 != null && this[cx].has(e8.index);
    }
    setEmissiveFactor(t5) {
      this[sx]();
      for (const e8 of this[fy])
        e8.emissive.fromArray(t5);
      this[gy].emissiveFactor = t5, this[vy]();
    }
    [ex]() {
      this[sx]();
      const t5 = this[gy];
      for (const e8 of this[fy])
        this[gy].alphaMode === "MASK" ? e8.alphaTest = t5.alphaCutoff : e8.alphaTest = void 0, e8.needsUpdate = true;
    }
    setAlphaCutoff(t5) {
      this[sx](), this[gy].alphaCutoff = t5, this[ex](), this[vy]();
    }
    getAlphaCutoff() {
      return this[sx](), this[gy].alphaCutoff;
    }
    setDoubleSided(t5) {
      this[sx]();
      for (const e8 of this[fy])
        e8.side = t5 ? 2 : 0, e8.needsUpdate = true;
      this[gy].doubleSided = t5, this[vy]();
    }
    getDoubleSided() {
      return this[sx](), this[gy].doubleSided;
    }
    setAlphaMode(t5) {
      this[sx]();
      const e8 = (t6, e9) => {
        t6.transparent = e9, t6.depthWrite = !e9;
      };
      this[gy].alphaMode = t5;
      for (const n8 of this[fy])
        e8(n8, t5 === "BLEND"), this[ex](), n8.needsUpdate = true;
      this[vy]();
    }
    getAlphaMode() {
      return this[sx](), this[gy].alphaMode;
    }
  };
  var px;
  var mx;
  var fx;
  var gx = Symbol("materials");
  var vx = Symbol("variantToMaterialMap");
  var yx = Symbol("modelVariants");
  var xx = Symbol("mesh");
  var bx = Symbol("children");
  var _x = Symbol("initialMaterialIdx");
  var wx = Symbol("activeMaterialIdx");
  var Mx = class {
    constructor(t5) {
      this.name = "", this[px] = new Array(), this.name = t5;
    }
  };
  px = bx;
  var Sx = class extends Mx {
    constructor(t5, e8, n8, i6) {
      super(t5.name), this[mx] = /* @__PURE__ */ new Map(), this[fx] = /* @__PURE__ */ new Map(), this[xx] = t5;
      const { gltf: r5, threeGLTF: s6, threeObjectMap: a4 } = i6;
      this[yx] = n8, this.mesh.userData.variantData = n8;
      const o7 = a4.get(t5.material);
      o7.materials != null ? this[_x] = this[wx] = o7.materials : console.error(`Primitive (${t5.name}) missing initial material reference.`);
      const l6 = t5.userData.associations || {};
      if (l6.meshes == null)
        return void console.error("Mesh is missing primitive index association");
      const h4 = ((r5.meshes || [])[l6.meshes].primitives || [])[l6.primitives];
      if (h4 != null) {
        if (h4.material != null)
          this[gx].set(h4.material, e8[h4.material]);
        else {
          const t6 = e8.findIndex((t7) => t7.name === "Default");
          t6 >= 0 ? this[gx].set(t6, e8[t6]) : console.warn("gltfPrimitive has no material!");
        }
        if (h4.extensions && h4.extensions.KHR_materials_variants) {
          const t6 = h4.extensions.KHR_materials_variants, i7 = s6.parser.json.extensions.KHR_materials_variants.variants;
          for (const r6 of t6.mappings) {
            const t7 = e8[r6.material];
            this[gx].set(r6.material, t7);
            for (const e9 of r6.variants) {
              const { name: r7 } = i7[e9];
              this[vx].set(e9, t7), t7[lx]().add(e9), n8.has(r7) || n8.set(r7, { name: r7, index: e9 });
            }
          }
        }
      } else
        console.error("Mesh primitive definition is missing.");
    }
    get mesh() {
      return this[xx];
    }
    async setActiveMaterial(t5) {
      const e8 = this[gx].get(t5);
      return e8 != null && (this.mesh.material = await e8[rx](), this[wx] = t5), this.mesh.material;
    }
    getActiveMaterial() {
      return this[gx].get(this[wx]);
    }
    getMaterial(t5) {
      return this[gx].get(t5);
    }
    async enableVariant(t5) {
      if (t5 == null)
        return this.setActiveMaterial(this[_x]);
      if (this[vx] != null && this[yx].has(t5)) {
        const e8 = this[yx].get(t5);
        return this.enableVariantHelper(e8.index);
      }
      return null;
    }
    async enableVariantHelper(t5) {
      if (this[vx] != null && t5 != null) {
        const e8 = this[vx].get(t5);
        if (e8 != null)
          return this.setActiveMaterial(e8.index);
      }
      return null;
    }
    async instantiateVariants() {
      if (this[vx] != null)
        for (const t5 of this[vx].keys()) {
          if (this.mesh.userData.variantMaterials.get(t5).material != null)
            continue;
          const e8 = await this.enableVariantHelper(t5);
          e8 != null && (this.mesh.userData.variantMaterials.get(t5).material = e8);
        }
    }
    get variantInfo() {
      return this[vx];
    }
    addVariant(t5, e8) {
      if (!this.ensureVariantIsUnused(e8))
        return false;
      this[yx].has(e8) || this[yx].set(e8, { name: e8, index: this[yx].size });
      const n8 = this[yx].get(e8).index;
      return t5[lx]().add(n8), this[vx].set(n8, t5), this[gx].set(t5.index, t5), this.updateVariantUserData(n8, t5), true;
    }
    deleteVariant(t5) {
      if (this.variantInfo.has(t5)) {
        this.variantInfo.delete(t5);
        const e8 = this.mesh.userData.variantMaterials;
        e8 != null && e8.delete(t5);
      }
    }
    updateVariantUserData(t5, e8) {
      e8[lx]().add(t5), this.mesh.userData.variantData = this[yx], this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || /* @__PURE__ */ new Map();
      this.mesh.userData.variantMaterials.set(t5, { material: e8[fy].values().next().value, gltfMaterialIndex: e8.index });
    }
    ensureVariantIsUnused(t5) {
      const e8 = this[yx].get(t5);
      return e8 == null || !this.variantInfo.has(e8.index) || (console.warn(`Primitive cannot add variant '${t5}' for this material, it already exists.`), false);
    }
  };
  var Tx;
  var Ex;
  var Ax;
  var Rx;
  var Cx;
  var Lx;
  mx = gx, fx = vx;
  var Px = Symbol("materials");
  var Dx = Symbol("hierarchy");
  var Ix = Symbol("roots");
  var Ox = Symbol("primitives");
  var Nx = Symbol("correlatedSceneGraph");
  var Fx = Symbol("prepareVariantsForExport");
  var Ux = Symbol("switchVariant");
  var kx = Symbol("threeScene");
  var Bx = Symbol("materialsFromPoint");
  var zx = Symbol("materialFromPoint");
  var Hx = Symbol("variantData");
  var Vx = Symbol("availableVariants");
  var Gx = Symbol("modelOnUpdate");
  var Wx = Symbol("cloneMaterial");
  var jx = class {
    constructor(t5, e8, n8, i6) {
      this.gltf = t5, this.gltfElementMap = e8, this.mapKey = n8, this.doLazyLoad = i6;
    }
  };
  var qx = class {
    constructor(t5, e8 = () => {
    }) {
      this[Tx] = new Array(), this[Ex] = new Array(), this[Ax] = new Array(), this[Rx] = new Array(), this[Cx] = () => {
      }, this[Lx] = /* @__PURE__ */ new Map(), this[Gx] = e8, this[Nx] = t5;
      const { gltf: n8, threeGLTF: i6, gltfElementMap: r5 } = t5;
      this[kx] = i6.scene;
      for (const [t6, s7] of n8.materials.entries()) {
        const a5 = r5.get(s7);
        if (a5 != null)
          this[Px].push(new dx(e8, n8, s7, t6, true, this[Hx], a5));
        else {
          const s8 = (n8.materials || [])[t6], o7 = t6, l6 = async () => {
            const t7 = await i6.parser.getDependency("material", o7), e9 = /* @__PURE__ */ new Set();
            return r5.set(s8, e9), e9.add(t7), { set: e9, material: t7 };
          };
          this[Px].push(new dx(e8, n8, s8, t6, false, this[Hx], a5, new jx(n8, r5, s8, l6)));
        }
      }
      const s6 = /* @__PURE__ */ new Map(), a4 = new Array();
      for (const t6 of i6.scene.children)
        a4.push(t6);
      for (; a4.length > 0; ) {
        const e9 = a4.pop();
        let n9 = null;
        e9 instanceof Fe ? (n9 = new Sx(e9, this.materials, this[Hx], t5), this[Ox].push(n9)) : n9 = new Mx(e9.name);
        const i7 = s6.get(e9);
        i7 != null ? i7[bx].push(n9) : this[Ix].push(n9), this[Dx].push(n9);
        for (const t6 of e9.children)
          a4.push(t6), s6.set(e9, n9);
      }
    }
    get materials() {
      return this[Px];
    }
    [(Tx = Px, Ex = Dx, Ax = Ix, Rx = Ox, Cx = Gx, Lx = Hx, Vx)]() {
      const t5 = Array.from(this[Hx].values());
      return t5.sort((t6, e8) => t6.index - e8.index), t5.map((t6) => t6.name);
    }
    getMaterialByName(t5) {
      const e8 = this[Px].filter((e9) => e9.name === t5);
      return e8.length > 0 ? e8[0] : null;
    }
    [Bx](t5) {
      return t5.intersectObject(this[kx], true).map((t6) => {
        const e8 = this[Dx].find((e9) => {
          if (e9 instanceof Sx) {
            if (e9.mesh === t6.object)
              return true;
          }
          return false;
        });
        return e8 != null ? e8.getActiveMaterial() : null;
      });
    }
    [zx](t5) {
      const e8 = this[Bx](t5);
      return e8.length > 0 ? e8[0] : null;
    }
    async [Ux](t5) {
      for (const e8 of this[Ox])
        await e8.enableVariant(t5);
      for (const t6 of this.materials)
        t6[ox](false);
      for (const t6 of this[Ox])
        this.materials[t6.getActiveMaterial().index][ox](true);
    }
    async [Fx]() {
      const t5 = new Array();
      for (const e8 of this[Ox])
        t5.push(e8.instantiateVariants());
      await Promise.all(t5);
    }
    [Wx](t5, e8) {
      const n8 = this.materials[t5];
      n8.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
      const i6 = n8[fy], r5 = JSON.parse(JSON.stringify(n8[gy]));
      r5.name = e8;
      this[Nx].gltf.materials.push(r5);
      const s6 = /* @__PURE__ */ new Set();
      for (const [t6, n9] of i6.entries()) {
        const r6 = n9.clone();
        r6.name = e8 + (i6.size > 1 ? "_inst" + t6 : ""), s6.add(r6);
      }
      const a4 = new dx(this[Gx], this[Nx].gltf, r5, this[Px].length, false, this[Hx], s6);
      return this[Px].push(a4), a4;
    }
    createMaterialInstanceForVariant(t5, e8, n8, i6 = true) {
      let r5 = null;
      for (const i7 of this[Ox]) {
        const s6 = this[Hx].get(n8);
        s6 != null && i7.variantInfo.has(s6.index) || i7.getMaterial(t5) != null && (this.hasVariant(n8) || this.createVariant(n8), r5 == null && (r5 = this[Wx](t5, e8)), i7.addVariant(r5, n8));
      }
      if (i6 && r5 != null) {
        r5[ox](true), this.materials[t5][ox](false);
        for (const t6 of this[Ox])
          t6.enableVariant(n8);
      }
      return r5;
    }
    createVariant(t5) {
      this[Hx].has(t5) ? console.warn(`Variant '${t5}'' already exists`) : this[Hx].set(t5, { name: t5, index: this[Hx].size });
    }
    hasVariant(t5) {
      return this[Hx].has(t5);
    }
    setMaterialToVariant(t5, e8) {
      if (this[Vx]().find((t6) => t6 === e8) != null)
        if (t5 < 0 || t5 >= this.materials.length)
          console.error("setMaterialToVariant(): materialIndex is out of bounds.");
        else
          for (const n8 of this[Ox]) {
            const i6 = n8.getMaterial(t5);
            i6 != null && n8.addVariant(i6, e8);
          }
      else
        console.warn(`Can't add material to '${e8}', the variant does not exist.'`);
    }
    updateVariantName(t5, e8) {
      const n8 = this[Hx].get(t5);
      n8 != null && (n8.name = e8, this[Hx].set(e8, n8), this[Hx].delete(t5));
    }
    deleteVariant(t5) {
      const e8 = this[Hx].get(t5);
      if (e8 != null) {
        for (const n8 of this.materials)
          n8.hasVariant(t5) && n8[cx].delete(e8.index);
        for (const t6 of this[Ox])
          t6.deleteVariant(e8.index);
        this[Hx].delete(t5);
      }
    }
  };
  var Xx = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var $x = Symbol("currentGLTF");
  var Yx = Symbol("model");
  var Jx = Symbol("getOnUpdateMethod");
  var Kx = Symbol("textureLoader");
  var Zx = Symbol("originalGltfJson");
  var Qx = function(t5, e8, n8, i6) {
    for (var r5, s6 = arguments.length, a4 = s6 < 3 ? e8 : i6 === null ? i6 = Object.getOwnPropertyDescriptor(e8, n8) : i6, o7 = t5.length - 1; o7 >= 0; o7--)
      (r5 = t5[o7]) && (a4 = (s6 < 3 ? r5(a4) : s6 > 3 ? r5(e8, n8, a4) : r5(e8, n8)) || a4);
    return s6 > 3 && a4 && Object.defineProperty(e8, n8, a4), a4;
  };
  var tb = Math.PI / 32;
  var eb = { basis: [Mu(pu(tb, "rad"))], keywords: { auto: [null] } };
  var nb = Symbol("autoRotateStartTime");
  var ib = Symbol("radiansPerSecond");
  var rb = Symbol("syncRotationRate");
  var sb = Symbol("onCameraChange");
  var ab = ((t5) => {
    var e8, n8, i6;
    class r5 extends t5 {
      constructor() {
        super(...arguments), this[e8] = /* @__PURE__ */ new Map(), this[n8] = (t6) => {
          t6.forEach((t7) => {
            t7 instanceof MutationRecord && t7.type !== "childList" || (t7.addedNodes.forEach((t8) => {
              this[Gp](t8);
            }), t7.removedNodes.forEach((t8) => {
              this[Wp](t8);
            }), this[wp]());
          });
        }, this[i6] = new MutationObserver(this[Hp]);
      }
      connectedCallback() {
        super.connectedCallback();
        for (let t7 = 0; t7 < this.children.length; ++t7)
          this[Gp](this.children[t7]);
        const { ShadyDOM: t6 } = self;
        t6 == null ? this[Vp].observe(this, { childList: true }) : this[Vp] = t6.observeChildren(this, this[Hp]);
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        const { ShadyDOM: t6 } = self;
        t6 == null ? this[Vp].disconnect() : t6.unobserveChildren(this[Vp]);
      }
      [(e8 = zp, n8 = Hp, i6 = Vp, Mp)](t6, e9) {
        super[Mp](t6, e9);
        const n9 = this[_p], { annotationRenderer: i7 } = n9, r6 = n9.getCamera();
        n9.shouldRender() && (n9.updateHotspots(r6.position), i7.domElement.style.display = "", i7.render(n9, r6));
      }
      updateHotspot(t6) {
        const e9 = this[zp].get(t6.name);
        e9 != null && (e9.updatePosition(t6.position), e9.updateNormal(t6.normal), this[wp]());
      }
      positionAndNormalFromPoint(t6, e9) {
        const n9 = this[_p], i7 = n9.getNDC(t6, e9), r6 = n9.positionAndNormalFromPoint(i7);
        if (r6 == null)
          return null;
        jp.copy(n9.target.matrixWorld).invert();
        const s6 = Ip(r6.position.applyMatrix4(jp));
        qp.getNormalMatrix(jp);
        const a4 = Ip(r6.normal.applyNormalMatrix(qp));
        let o7 = null;
        return r6.uv != null && (o7 = Op(r6.uv)), { position: s6, normal: a4, uv: o7 };
      }
      [Gp](t6) {
        if (!(t6 instanceof HTMLElement && t6.slot.indexOf("hotspot") === 0))
          return;
        let e9 = this[zp].get(t6.slot);
        e9 != null ? e9.increment() : (e9 = new Eu({ name: t6.slot, position: t6.dataset.position, normal: t6.dataset.normal }), this[zp].set(t6.slot, e9), this[_p].addHotspot(e9)), this[_p].queueRender();
      }
      [Wp](t6) {
        if (!(t6 instanceof HTMLElement))
          return;
        const e9 = this[zp].get(t6.slot);
        e9 && (e9.decrement() && (this[_p].removeHotspot(e9), this[zp].delete(t6.slot)), this[_p].queueRender());
      }
    }
    return r5;
  })(((t5) => {
    var n8, i6, r5, s6;
    class a4 extends t5 {
      constructor() {
        super(...arguments), this[n8] = void 0, this[i6] = null, this[r5] = new fo(), this[s6] = null, this.variantName = null, this.orientation = "0 0 0", this.scale = "1 1 1";
      }
      get model() {
        return this[Yx];
      }
      get availableVariants() {
        return this.model ? this.model[Vx]() : [];
      }
      get originalGltfJson() {
        return this[Zx];
      }
      [(n8 = Yx, i6 = $x, r5 = Kx, s6 = Zx, Jx)]() {
        return () => {
          this[wp]();
        };
      }
      async createTexture(t6, e8 = "image/png") {
        const n9 = this[$x], i7 = await new Promise((e9) => this[Kx].load(t6, e9));
        return n9 && i7 ? (i7.encoding = 3001, i7.wrapS = 1e3, i7.wrapT = 1e3, i7.flipY = false, i7.userData.mimeType = e8, new Fy(this[Jx](), i7)) : null;
      }
      async updated(t6) {
        if (super.updated(t6), t6.has("variantName")) {
          const t7 = this[$x], { variantName: e8 } = this;
          t7 != null && (await this[Yx][Ux](e8), this[wp](), this.dispatchEvent(new CustomEvent("variant-applied")));
        }
        if (t6.has("orientation") || t6.has("scale")) {
          const { modelContainer: t7 } = this[_p], e8 = mu(this.orientation)[0].terms, n9 = Tu(e8[0]).number, i7 = Tu(e8[1]).number, r6 = Tu(e8[2]).number;
          t7.quaternion.setFromEuler(new Ct(i7, r6, n9, "YXZ"));
          const s7 = mu(this.scale)[0].terms;
          t7.scale.set(s7[0].number, s7[1].number, s7[2].number), this[_p].updateBoundingBox(), this[_p].updateShadow(), this[Ep].arRenderer.onUpdateScene(), this[wp]();
        }
      }
      [Sp]() {
        super[Sp]();
        const { currentGLTF: t6 } = this[_p];
        if (t6 != null) {
          const { correlatedSceneGraph: e8 } = t6;
          e8 != null && t6 !== this[$x] && (this[Yx] = new qx(e8, this[Jx]()), this[Zx] = JSON.parse(JSON.stringify(e8.gltf))), "variants" in t6.userData && this.requestUpdate("variantName");
        }
        this[$x] = t6, this.dispatchEvent(new CustomEvent("scene-graph-ready"));
      }
      async exportScene(t6) {
        const e8 = this[_p];
        return new Promise(async (n9) => {
          const i7 = { binary: true, onlyVisible: true, maxTextureSize: 1 / 0, forcePowerOfTwoTextures: false, includeCustomExtensions: false, embedImages: true };
          Object.assign(i7, t6), i7.animations = e8.animations, i7.truncateDrawRange = true;
          const r6 = e8.shadow;
          let s7 = false;
          r6 != null && (s7 = r6.visible, r6.visible = false), await this[Yx][Fx]();
          new Dv().register((t7) => new my(t7)).parse(e8.modelContainer.children[0], (t7) => n9(new Blob([i7.binary ? t7 : JSON.stringify(t7)], { type: i7.binary ? "application/octet-stream" : "application/json" })), i7), r6 != null && (r6.visible = s7);
        });
      }
      materialFromPoint(t6, e8) {
        const n9 = this[_p], i7 = n9.getNDC(t6, e8);
        return n9.raycaster.setFromCamera(i7, n9.getCamera()), this[Yx][zx](n9.raycaster);
      }
    }
    return Xx([e7({ type: String, attribute: "variant-name" })], a4.prototype, "variantName", void 0), Xx([e7({ type: String, attribute: "orientation" })], a4.prototype, "orientation", void 0), Xx([e7({ type: String, attribute: "scale" })], a4.prototype, "scale", void 0), a4;
  })(((t5) => {
    var n8, i6, r5;
    class s6 extends t5 {
      constructor() {
        super(...arguments), this.autoRotate = false, this.autoRotateDelay = 3e3, this.rotationPerSecond = "auto", this[n8] = performance.now(), this[i6] = 0, this[r5] = (t6) => {
          this.autoRotate && t6.detail.source === "user-interaction" && (this[nb] = performance.now());
        };
      }
      connectedCallback() {
        super.connectedCallback(), this.addEventListener("camera-change", this[sb]), this[nb] = performance.now();
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this.removeEventListener("camera-change", this[sb]), this[nb] = performance.now();
      }
      updated(t6) {
        super.updated(t6), t6.has("autoRotate") && (this[nb] = performance.now());
      }
      [(n8 = nb, i6 = ib, rb)](t6) {
        this[ib] = t6[0];
      }
      [Mp](t6, e8) {
        if (super[Mp](t6, e8), !this.autoRotate || !this[Dp]() || this[Ep].isPresenting)
          return;
        const n9 = Math.min(e8, t6 - this[nb] - this.autoRotateDelay);
        n9 > 0 && (this[_p].yaw = this.turntableRotation + this[ib] * n9 * 1e-3);
      }
      get turntableRotation() {
        return this[_p].yaw;
      }
      resetTurntableRotation(t6 = 0) {
        this[_p].yaw = t6;
      }
    }
    return r5 = sb, Qx([e7({ type: Boolean, attribute: "auto-rotate" })], s6.prototype, "autoRotate", void 0), Qx([e7({ type: Number, attribute: "auto-rotate-delay" })], s6.prototype, "autoRotateDelay", void 0), Qx([tg({ intrinsics: eb, updateHandler: rb }), e7({ type: String, attribute: "rotation-per-second" })], s6.prototype, "rotationPerSecond", void 0), s6;
  })(((t5) => {
    var n8, i6, r5;
    class s6 extends t5 {
      constructor() {
        super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this[n8] = null, this[i6] = null, this[r5] = (t6) => {
          t6.element === this && this[Gu]();
        };
      }
      connectedCallback() {
        super.connectedCallback(), this[Ep].loader.addEventListener("preload", this[ju]);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this[Ep].loader.removeEventListener("preload", this[ju]);
      }
      updated(t6) {
        super.updated(t6), t6.has("shadowIntensity") && (this[_p].setShadowIntensity(0.5 * this.shadowIntensity), this[wp]()), t6.has("shadowSoftness") && (this[_p].setShadowSoftness(this.shadowSoftness), this[wp]()), t6.has("exposure") && (this[_p].exposure = this.exposure, this[wp]()), (t6.has("environmentImage") || t6.has("skyboxImage")) && this[Lp]() && this[Gu]();
      }
      hasBakedShadow() {
        return this[_p].bakedShadows.size > 0;
      }
      [(n8 = Hu, i6 = Wu, r5 = ju, Sp)]() {
        super[Sp](), this[Hu] != null && this[Vu](this[Hu]);
      }
      async [Gu]() {
        const { skyboxImage: t6, environmentImage: e8 } = this;
        this[Wu] != null && (this[Wu](), this[Wu] = null);
        const { textureUtils: n9 } = this[Ep];
        if (n9 != null)
          try {
            const { environmentMap: i7, skybox: r6 } = await new Promise(async (i8, r7) => {
              const s7 = n9.generateEnvironmentMapAndSkybox(ru(t6), e8, { progressTracker: this[Ap] });
              this[Wu] = () => r7(s7), i8(await s7);
            });
            this[_p].background = r6 != null ? r6.name === i7.name ? i7 : r6 : null, this[Vu](i7), this[_p].dispatchEvent({ type: "envmap-update" });
          } catch (t7) {
            if (t7 instanceof Error)
              throw this[Vu](null), t7;
          }
      }
      [Vu](t6) {
        this[_p].environment !== t6 && (this[Hu] = t6, this[_p].environment = this[Hu], this.dispatchEvent(new CustomEvent("environment-change")), this[wp]());
      }
    }
    return zu([e7({ type: String, attribute: "environment-image" })], s6.prototype, "environmentImage", void 0), zu([e7({ type: String, attribute: "skybox-image" })], s6.prototype, "skyboxImage", void 0), zu([e7({ type: Number, attribute: "shadow-intensity" })], s6.prototype, "shadowIntensity", void 0), zu([e7({ type: Number, attribute: "shadow-softness" })], s6.prototype, "shadowSoftness", void 0), zu([e7({ type: Number })], s6.prototype, "exposure", void 0), s6;
  })(((t5) => {
    var n8, i6, r5, s6, a4, o7, l6, h4, c3, u3, d3, p3, m3, f3, g3, v3, y3, x3;
    class b3 extends t5 {
      constructor() {
        super(...arguments), this.cameraControls = false, this.cameraOrbit = "0deg 75deg 105%", this.cameraTarget = "auto auto auto", this.fieldOfView = "auto", this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = 3e3, this.interactionPromptStyle = Sg, this.interactionPrompt = wg, this.interactionPolicy = Tg, this.orbitSensitivity = 1, this.touchAction = Eg, this.disableZoom = false, this.enablePan = false, this.interpolationDecay = 50, this.bounds = "legacy", this[n8] = this.shadowRoot.querySelector(".interaction-prompt"), this[i6] = this.shadowRoot.querySelector("#prompt"), this[r5] = [this.shadowRoot.querySelector("#finger0"), this.shadowRoot.querySelector("#finger1")], this[s6] = this.shadowRoot.querySelector(".pan-target"), this[a4] = 1 / 0, this[o7] = 0, this[l6] = 1 / 0, this[h4] = false, this[c3] = false, this[u3] = new pg(this[_p].camera, this[xp], this[_p]), this[d3] = new Ko(), this[p3] = false, this[m3] = false, this[f3] = false, this[g3] = () => {
          isFinite(this[Qg]) || (this[Qg] = performance.now()), this.interactionPrompt !== Mg || this[Jg] || (this[Yg] = true);
        }, this[v3] = () => {
          this.interactionPrompt === Mg && (this[Yg] = false, this[Bg].classList.remove("visible"), this[Kg] = 1 / 0, this[Qg] = 1 / 0);
        }, this[y3] = ({ source: t6 }) => {
          this[Gg](), this[wp](), t6 === ug && (this[Jg] = true, this[Vg]()), this.dispatchEvent(new CustomEvent("camera-change", { detail: { source: t6 } }));
        }, this[x3] = (t6) => {
          t6.type === "pointer-change-start" ? this[yp].classList.add("pointer-tumbling") : this[yp].classList.remove("pointer-tumbling");
        };
      }
      getCameraOrbit() {
        const { theta: t6, phi: e8, radius: n9 } = this[tv];
        return { theta: t6, phi: e8, radius: n9, toString() {
          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
        } };
      }
      getCameraTarget() {
        return Ip(this[Ep].isPresenting ? this[Ep].arRenderer.target : this[_p].getTarget());
      }
      getFieldOfView() {
        return this[Ug].getFieldOfView();
      }
      getMinimumFieldOfView() {
        return this[Ug].options.minimumFieldOfView;
      }
      getMaximumFieldOfView() {
        return this[Ug].options.maximumFieldOfView;
      }
      getIdealAspect() {
        return this[_p].idealAspect;
      }
      jumpCameraToGoal() {
        this[ev] = true, this.requestUpdate(ev, false);
      }
      resetInteractionPrompt() {
        this[Zg] = 0, this[Kg] = 1 / 0, this[Jg] = false, this[Yg] = this.interactionPrompt === wg && this.cameraControls;
      }
      zoom(t6) {
        const e8 = new WheelEvent("wheel", { deltaY: -30 * t6 });
        this[xp].dispatchEvent(e8);
      }
      connectedCallback() {
        super.connectedCallback(), this[Ug].addEventListener("change", this[Xg]), this[Ug].addEventListener("pointer-change-start", this[$g]), this[Ug].addEventListener("pointer-change-end", this[$g]);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this[Ug].removeEventListener("change", this[Xg]), this[Ug].removeEventListener("pointer-change-start", this[$g]), this[Ug].removeEventListener("pointer-change-end", this[$g]);
      }
      updated(t6) {
        super.updated(t6);
        const e8 = this[Ug], n9 = this[_p], i7 = this[xp];
        if (t6.has("cameraControls") && (this.cameraControls ? (e8.enableInteraction(), this.interactionPrompt === wg && (this[Yg] = true), i7.addEventListener("focus", this[qg]), i7.addEventListener("blur", this[jg])) : (i7.removeEventListener("focus", this[qg]), i7.removeEventListener("blur", this[jg]), e8.disableInteraction(), this[Vg]()), this[xp].setAttribute("aria-label", this[up])), t6.has("disableZoom") && (e8.disableZoom = this.disableZoom), t6.has("enablePan") && (e8.enablePan = this.enablePan), t6.has("bounds") && (n9.tightBounds = this.bounds === "tight"), (t6.has("interactionPrompt") || t6.has("cameraControls") || t6.has("src")) && (this.interactionPrompt === wg && this.cameraControls && !this[Jg] ? this[Yg] = true : this[Vg]()), t6.has("interactionPolicy")) {
          const t7 = this.interactionPolicy;
          e8.applyOptions({ interactionPolicy: t7 });
        }
        if (t6.has("touchAction")) {
          const t7 = this.touchAction;
          e8.applyOptions({ touchAction: t7 }), e8.updateTouchActionStyle();
        }
        t6.has("orbitSensitivity") && (e8.sensitivity = this.orbitSensitivity), t6.has("interpolationDecay") && (e8.setDamperDecayTime(this.interpolationDecay), n9.setTargetDamperDecayTime(this.interpolationDecay)), this[ev] === true && Promise.resolve().then(() => {
          e8.jumpToGoal(), n9.jumpToGoal(), this[ev] = false;
        });
      }
      async updateFraming() {
        const t6 = this[_p], e8 = t6.adjustedFoV(t6.framedFoVDeg);
        await t6.updateFraming();
        const n9 = t6.adjustedFoV(t6.framedFoVDeg), i7 = this[Ug].getFieldOfView() / e8;
        this[Ug].setFieldOfView(n9 * i7), this[iv] = true, this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), this.requestUpdate("cameraOrbit"), await this.updateComplete;
      }
      interact(t6, e8, n9) {
        const i7 = this[xp], r6 = this[Hg];
        if (r6[0].style.opacity === "1")
          return void console.warn("interact() failed because an existing interaction is running.");
        const s7 = new Array();
        s7.push({ x: gg(e8.x), y: gg(e8.y) });
        const a5 = [{ x: s7[0].x(0), y: s7[0].y(0) }];
        n9 != null && (s7.push({ x: gg(n9.x), y: gg(n9.y) }), a5.push({ x: s7[1].x(0), y: s7[1].y(0) }));
        let o8 = performance.now();
        const { width: l7, height: h5 } = this[_p], c4 = (t7) => {
          for (const [e9, n10] of a5.entries()) {
            const { style: s8 } = r6[e9];
            s8.transform = `translateX(${l7 * n10.x}px) translateY(${h5 * n10.y}px)`, t7 === "pointerdown" ? s8.opacity = "1" : t7 === "pointerup" && (s8.opacity = "0");
            const a6 = { pointerId: e9 - 5678, pointerType: "touch", target: i7, clientX: l7 * n10.x, clientY: h5 * n10.y, altKey: true };
            i7.dispatchEvent(new PointerEvent(t7, a6));
          }
        }, u4 = () => {
          if (this[Ug].isUserChange) {
            for (const t7 of this[Hg])
              t7.style.opacity = "0";
            return void c4("pointercancel");
          }
          const e9 = Math.min(1, (performance.now() - o8) / t6);
          for (const [t7, n10] of a5.entries())
            n10.x = s7[t7].x(e9), n10.y = s7[t7].y(e9);
          c4("pointermove"), e9 < 1 ? requestAnimationFrame(u4) : (c4("pointerup"), document.removeEventListener("visibilitychange", d4));
        }, d4 = () => {
          let t7 = 0;
          document.visibilityState === "hidden" ? t7 = performance.now() - o8 : o8 = performance.now() - t7;
        };
        document.addEventListener("visibilitychange", d4), c4("pointerdown"), requestAnimationFrame(u4);
      }
      [(n8 = Bg, i6 = zg, r5 = Hg, s6 = kg, a4 = Qg, o7 = Zg, l6 = Kg, h4 = Jg, c3 = Yg, u3 = Ug, d3 = tv, p3 = ev, m3 = nv, f3 = iv, sv)](t6) {
        const e8 = this[_p];
        e8.framedFoVDeg = 180 * t6[0] / Math.PI, this[Ug].setFieldOfView(e8.adjustedFoV(e8.framedFoVDeg));
      }
      [rv](t6) {
        const e8 = this[Ug];
        if (this[iv]) {
          const { theta: e9, phi: n9 } = this.getCameraOrbit();
          t6[0] = e9, t6[1] = n9, this[iv] = false;
        }
        e8.isUserChange = false, e8.setOrbit(t6[0], t6[1], t6[2]);
      }
      [ov](t6) {
        this[Ug].applyOptions({ minimumAzimuthalAngle: t6[0], minimumPolarAngle: t6[1], minimumRadius: t6[2] }), this.jumpCameraToGoal();
      }
      [lv](t6) {
        this[Ug].applyOptions({ maximumAzimuthalAngle: t6[0], maximumPolarAngle: t6[1], maximumRadius: t6[2] }), this[Wg](t6[2]), this.jumpCameraToGoal();
      }
      [hv](t6) {
        this[Ug].applyOptions({ minimumFieldOfView: 180 * t6[0] / Math.PI }), this.jumpCameraToGoal();
      }
      [cv](t6) {
        const e8 = this[_p].adjustedFoV(180 * t6[0] / Math.PI);
        this[Ug].applyOptions({ maximumFieldOfView: e8 }), this.jumpCameraToGoal();
      }
      [av](t6) {
        const [e8, n9, i7] = t6;
        this[Ep].arRenderer.isPresenting || this[_p].setTarget(e8, n9, i7), this[Ug].isUserChange = false, this[Ep].arRenderer.updateTarget();
      }
      [Mp](t6, e8) {
        if (super[Mp](t6, e8), this[Ep].isPresenting || !this[Dp]())
          return;
        const n9 = this[Ug], i7 = this[_p], r6 = performance.now();
        if (this[Yg]) {
          const t7 = this.interactionPrompt === wg ? this[fp] : this[Qg];
          this.loaded && r6 > t7 + this.interactionPromptThreshold && (this[Yg] = false, this[Kg] = r6, this[Bg].classList.add("visible"));
        }
        if (isFinite(this[Kg]) && this.interactionPromptStyle === Sg) {
          const t7 = (r6 - this[Kg]) / 5e3 % 1, e9 = yg(t7), s7 = xg(t7);
          if (this[zg].style.opacity = `${s7}`, e9 !== this[Zg]) {
            const t8 = e9 * i7.width * 0.05, r7 = (e9 - this[Zg]) * Math.PI / 16;
            this[zg].style.transform = `translateX(${t8}px)`, n9.isUserChange = false, n9.adjustOrbit(r7, 0, 0), this[Zg] = e9;
          }
        }
        if (n9.update(t6, e8), i7.updateTarget(e8)) {
          const t7 = n9.isUserChange ? ug : dg;
          this[Xg]({ type: "change", source: t7 });
        }
      }
      [Vg]() {
        this[Yg] = false, this[Bg].classList.remove("visible"), this[Kg] = 1 / 0;
      }
      [Wg](t6) {
        const e8 = 2 * Math.max(this[_p].boundingSphere.radius, t6);
        this[Ug].updateNearFar(0, e8);
      }
      [Gg]() {
        const { theta: t6, phi: e8 } = this[Ug].getCameraSpherical(this[tv]), n9 = (4 + Math.floor((t6 % Fg + Ng) / Ig)) % 4, i7 = Math.floor(e8 / Og), r6 = bg[n9], s7 = _g[i7];
        this[mp](`View from stage ${s7}${r6}`);
      }
      get [up]() {
        return super[up] + (this.cameraControls ? ". Use mouse, touch or arrow keys to move." : "");
      }
      async [Tp](t6) {
        const e8 = this[Ug], n9 = this[_p], i7 = n9.adjustedFoV(n9.framedFoVDeg);
        super[Tp](t6);
        const r6 = n9.adjustedFoV(n9.framedFoVDeg) / i7, s7 = e8.getFieldOfView() * (isFinite(r6) ? r6 : 1);
        e8.updateAspect(this[_p].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), await this.updateComplete, this[Ug].setFieldOfView(s7), this.jumpCameraToGoal();
      }
      [Sp]() {
        super[Sp](), this[nv] ? this[iv] = true : this[nv] = true, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
      }
    }
    return g3 = qg, v3 = jg, y3 = Xg, x3 = $g, vg([e7({ type: Boolean, attribute: "camera-controls" })], b3.prototype, "cameraControls", void 0), vg([tg({ intrinsics: Cg, observeEffects: true, updateHandler: rv }), e7({ type: String, attribute: "camera-orbit", hasChanged: () => true })], b3.prototype, "cameraOrbit", void 0), vg([tg({ intrinsics: Dg, observeEffects: true, updateHandler: av }), e7({ type: String, attribute: "camera-target", hasChanged: () => true })], b3.prototype, "cameraTarget", void 0), vg([tg({ intrinsics: Ag, observeEffects: true, updateHandler: sv }), e7({ type: String, attribute: "field-of-view", hasChanged: () => true })], b3.prototype, "fieldOfView", void 0), vg([tg({ intrinsics: Lg, updateHandler: ov }), e7({ type: String, attribute: "min-camera-orbit", hasChanged: () => true })], b3.prototype, "minCameraOrbit", void 0), vg([tg({ intrinsics: Pg, updateHandler: lv }), e7({ type: String, attribute: "max-camera-orbit", hasChanged: () => true })], b3.prototype, "maxCameraOrbit", void 0), vg([tg({ intrinsics: Rg, updateHandler: hv }), e7({ type: String, attribute: "min-field-of-view", hasChanged: () => true })], b3.prototype, "minFieldOfView", void 0), vg([tg({ intrinsics: Ag, updateHandler: cv }), e7({ type: String, attribute: "max-field-of-view", hasChanged: () => true })], b3.prototype, "maxFieldOfView", void 0), vg([e7({ type: Number, attribute: "interaction-prompt-threshold" })], b3.prototype, "interactionPromptThreshold", void 0), vg([e7({ type: String, attribute: "interaction-prompt-style" })], b3.prototype, "interactionPromptStyle", void 0), vg([e7({ type: String, attribute: "interaction-prompt" })], b3.prototype, "interactionPrompt", void 0), vg([e7({ type: String, attribute: "interaction-policy" })], b3.prototype, "interactionPolicy", void 0), vg([e7({ type: Number, attribute: "orbit-sensitivity" })], b3.prototype, "orbitSensitivity", void 0), vg([e7({ type: String, attribute: "touch-action" })], b3.prototype, "touchAction", void 0), vg([e7({ type: Boolean, attribute: "disable-zoom" })], b3.prototype, "disableZoom", void 0), vg([e7({ type: Boolean, attribute: "enable-pan" })], b3.prototype, "enablePan", void 0), vg([e7({ type: Number, attribute: "interpolation-decay" })], b3.prototype, "interpolationDecay", void 0), vg([e7({ type: String, attribute: "bounds" })], b3.prototype, "bounds", void 0), b3;
  })(((t5) => {
    var n8, i6, r5, s6, a4, o7, l6, h4, c3, u3;
    class d3 extends t5 {
      constructor() {
        super(...arguments), this.ar = false, this.arScale = "auto", this.arPlacement = "floor", this.arModes = "webxr scene-viewer", this.iosSrc = null, this.xrEnvironment = false, this[n8] = false, this[i6] = this.shadowRoot.querySelector(".ar-button"), this[r5] = document.createElement("a"), this[s6] = /* @__PURE__ */ new Set(), this[a4] = tf, this[o7] = false, this[l6] = (t6) => {
          t6.preventDefault(), this.activateAR();
        }, this[h4] = ({ status: t6 }) => {
          t6 !== Zu && this[Ep].arRenderer.presentedScene !== this[_p] || (this.setAttribute("ar-status", t6), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t6 } })), t6 === Zu ? this.removeAttribute("ar-tracking") : t6 === Qu && this.setAttribute("ar-tracking", nd));
        }, this[c3] = ({ status: t6 }) => {
          this.setAttribute("ar-tracking", t6), this.dispatchEvent(new CustomEvent("ar-tracking", { detail: { status: t6 } }));
        }, this[u3] = (t6) => {
          t6.data == "_apple_ar_quicklook_button_tapped" && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
        };
      }
      get canActivateAR() {
        return this[of] !== tf;
      }
      connectedCallback() {
        super.connectedCallback(), this[Ep].arRenderer.addEventListener("status", this[df]), this.setAttribute("ar-status", Zu), this[Ep].arRenderer.addEventListener("tracking", this[pf]), this[hf].addEventListener("message", this[mf]);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this[Ep].arRenderer.removeEventListener("status", this[df]), this[Ep].arRenderer.removeEventListener("tracking", this[pf]), this[hf].removeEventListener("message", this[mf]);
      }
      async update(t6) {
        super.update(t6), t6.has("arScale") && (this[_p].canScale = this.arScale !== "fixed"), t6.has("arPlacement") && (this[_p].updateShadow(), this[wp]()), (t6.has("ar") || t6.has("arModes") || t6.has("src") || t6.has("iosSrc")) && (t6.has("arModes") && (this[lf] = Ym(this.arModes)), this[ff]());
      }
      async activateAR() {
        switch (this[of]) {
          case Km:
            this[sf]();
            break;
          case Qm:
            await this[nf]();
            break;
          case Zm:
            this[rf]();
            break;
          default:
            console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");
        }
      }
      async [(n8 = af, i6 = ef, r5 = hf, s6 = lf, a4 = of, o7 = cf, l6 = uf, h4 = df, c3 = pf, u3 = mf, ff)]() {
        if (this[of] = tf, this.ar) {
          if (this.src != null)
            for (const t6 of this[lf]) {
              if (t6 === "webxr" && ph && !Xm && await this[Ep].arRenderer.supportsPresentation()) {
                this[of] = Qm;
                break;
              }
              if (t6 === "scene-viewer" && xh && !$m) {
                this[of] = Zm;
                break;
              }
              if (t6 === "quick-look" && gh) {
                this[of] = Km;
                break;
              }
            }
          !this.canActivateAR && this.iosSrc != null && gh && (this[of] = Km);
        }
        if (this.canActivateAR)
          this[ef].classList.add("enabled"), this[ef].addEventListener("click", this[uf]);
        else if (this[ef].classList.contains("enabled")) {
          this[ef].removeEventListener("click", this[uf]), this[ef].classList.remove("enabled");
          const t6 = ed;
          this.setAttribute("ar-status", t6), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t6 } }));
        }
      }
      async [nf]() {
        console.log("Attempting to present in AR with WebXR..."), await this[gf]();
        try {
          this[ef].removeEventListener("click", this[uf]);
          const { arRenderer: t6 } = this[Ep];
          t6.placeOnWall = this.arPlacement === "wall", await t6.present(this[_p], this.xrEnvironment);
        } catch (t6) {
          console.warn("Error while trying to present in AR with WebXR"), console.error(t6), await this[Ep].arRenderer.stopPresenting(), Xm = true, console.warn("Falling back to next ar-mode"), await this[ff](), this.activateAR();
        } finally {
          this[ff]();
        }
      }
      async [gf]() {
        this.loaded || (this[cf] = true, this[gp](), await ((t6, e8, n9 = null) => new Promise((i7) => {
          t6.addEventListener(e8, function r6(s7) {
            n9 && !n9(s7) || (i7(s7), t6.removeEventListener(e8, r6));
          });
        }))(this, "load"), this[cf] = false);
      }
      [Lp]() {
        return super[Lp]() || this[cf];
      }
      [rf]() {
        const t6 = self.location.toString(), e8 = new URL(t6), n9 = new URL(this.src, t6), i7 = new URLSearchParams(n9.search);
        if (e8.hash = "#model-viewer-no-ar-fallback", i7.set("mode", "ar_preferred"), i7.has("disable_occlusion") || i7.set("disable_occlusion", "true"), this.arScale === "fixed" && i7.set("resizable", "false"), this.arPlacement === "wall" && i7.set("enable_vertical_placement", "true"), i7.has("sound")) {
          const e9 = new URL(i7.get("sound"), t6);
          i7.set("sound", e9.toString());
        }
        if (i7.has("link")) {
          const e9 = new URL(i7.get("link"), t6);
          i7.set("link", e9.toString());
        }
        const r6 = `intent://arvr.google.com/scene-viewer/1.0?${i7.toString() + "&file=" + encodeURIComponent(n9.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e8.toString())};end;`;
        self.addEventListener("hashchange", () => {
          self.location.hash === "#model-viewer-no-ar-fallback" && ($m = true, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), this[ff]());
        }, { once: true }), this[hf].setAttribute("href", r6), console.log("Attempting to present in AR with Scene Viewer..."), this[hf].click();
      }
      async [sf]() {
        const t6 = !this.iosSrc;
        this[ef].classList.remove("enabled");
        const e8 = t6 ? await this.prepareUSDZ() : this.iosSrc, n9 = new URL(e8, self.location.toString());
        this.arScale === "fixed" && (n9.hash && (n9.hash += "&"), n9.hash += "allowsContentScaling=0");
        const i7 = this[hf];
        i7.setAttribute("rel", "ar");
        const r6 = document.createElement("img");
        i7.appendChild(r6), i7.setAttribute("href", n9.toString()), t6 && i7.setAttribute("download", "model.usdz"), console.log("Attempting to present in AR with Quick Look..."), i7.click(), i7.removeChild(r6), t6 && URL.revokeObjectURL(e8), this[ef].classList.add("enabled");
      }
      async prepareUSDZ() {
        const t6 = this[Ap].beginActivity();
        await this[gf]();
        const e8 = this[_p], n9 = e8.shadow;
        let i7 = false;
        n9 != null && (i7 = n9.visible, n9.visible = false), t6(0.2);
        const r6 = new km(), s7 = await r6.parse(e8.modelContainer), a5 = new Blob([s7], { type: "model/vnd.usdz+zip" }), o8 = URL.createObjectURL(a5);
        return t6(1), n9 != null && (n9.visible = i7), o8;
      }
    }
    return qm([e7({ type: Boolean, attribute: "ar" })], d3.prototype, "ar", void 0), qm([e7({ type: String, attribute: "ar-scale" })], d3.prototype, "arScale", void 0), qm([e7({ type: String, attribute: "ar-placement" })], d3.prototype, "arPlacement", void 0), qm([e7({ type: String, attribute: "ar-modes" })], d3.prototype, "arModes", void 0), qm([e7({ type: String, attribute: "ios-src" })], d3.prototype, "iosSrc", void 0), qm([e7({ type: Boolean, attribute: "xr-environment" })], d3.prototype, "xrEnvironment", void 0), d3;
  })(((t5) => {
    var n8, i6, r5, s6, a4, o7, l6, h4, c3, u3, d3, p3, m3, f3;
    class g3 extends t5 {
      constructor(...t6) {
        super(...t6), this.poster = null, this.reveal = dv2, this.loading = mv, this.generateSchema = false, this.seamlessPoster = false, this[n8] = false, this[i6] = false, this[r5] = 0, this[s6] = null, this[a4] = this.shadowRoot.querySelector(".slot.poster"), this[o7] = this.shadowRoot.querySelector("#default-poster"), this[l6] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[h4] = this.shadowRoot.querySelector("#default-progress-bar > .mask"), this[c3] = this[bv].getAttribute("aria-label"), this[u3] = ((t7, e9) => {
          let n9 = null;
          const i7 = (...i8) => {
            n9 == null && (t7(...i8), n9 = self.setTimeout(() => n9 = null, e9));
          };
          return i7.flush = () => {
            n9 != null && (self.clearTimeout(n9), n9 = null);
          }, i7;
        })((t7) => {
          const e9 = this[vv].parentNode;
          requestAnimationFrame(() => {
            this[yv].style.opacity = "" + 0.2 * (1 - t7), this[vv].style.transform = `scaleX(${t7})`, t7 === 0 && (e9.removeChild(this[vv]), e9.appendChild(this[vv])), t7 === 1 ? this[vv].classList.add("hide") : this[vv].classList.remove("hide");
          });
        }, 100), this[d3] = () => {
          this.reveal !== pv && this.reveal !== dv2 && this.dismissPoster();
        }, this[p3] = (t7) => {
          if (this.reveal !== pv)
            switch (t7.keyCode) {
              case 32:
              case 13:
                this.dismissPoster();
            }
        }, this[m3] = (t7) => {
          const e9 = t7.detail.totalProgress;
          this[Tv] = Math.max(e9, this[Tv]), e9 === 1 && (this[Sv].flush(), !this[Pp]() || this[_v] == null && this.reveal !== dv2 || this[wv]()), this[Sv](e9), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: e9 } }));
        }, this[f3] = () => {
          this[Ev] = true;
          const t7 = this.getRootNode();
          t7 && t7.activeElement === this && this[xp].focus();
          const e9 = this[bv];
          e9.setAttribute("aria-hidden", "true"), e9.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"));
        };
        const e8 = self.ModelViewerElement || {}, g4 = e8.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.4.1/";
        Jc.setDRACODecoderLocation(g4);
        const v3 = e8.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
        Jc.setKTX2TranscoderLocation(v3), e8.meshoptDecoderLocation && Jc.setMeshoptDecoderLocation(e8.meshoptDecoderLocation);
      }
      static set dracoDecoderLocation(t6) {
        Jc.setDRACODecoderLocation(t6);
      }
      static get dracoDecoderLocation() {
        return Jc.getDRACODecoderLocation();
      }
      static set ktx2TranscoderLocation(t6) {
        Jc.setKTX2TranscoderLocation(t6);
      }
      static get ktx2TranscoderLocation() {
        return Jc.getKTX2TranscoderLocation();
      }
      static set meshoptDecoderLocation(t6) {
        Jc.setMeshoptDecoderLocation(t6);
      }
      static get meshoptDecoderLocation() {
        return Jc.getMeshoptDecoderLocation();
      }
      static mapURLs(t6) {
        Fd.singleton.loader[Xc].manager.setURLModifier(t6);
      }
      dismissPoster() {
        this[Pp]() ? this[wv]() : (this[_v] = gv, this[gp]());
      }
      showPoster() {
        const t6 = this[xv], e8 = this[bv];
        e8.removeAttribute("tabindex"), e8.removeAttribute("aria-hidden"), t6.classList.add("show");
        const n9 = this.modelIsVisible;
        this[Mv] = false, this[cp](n9), this[Ev] = false;
      }
      getDimensions() {
        return Ip(this[_p].size);
      }
      connectedCallback() {
        super.connectedCallback(), this[xv].addEventListener("click", this[Cv]), this[xv].addEventListener("keydown", this[Lv]), this[Ap].addEventListener("progress", this[Pv]);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this[xv].removeEventListener("click", this[Cv]), this[xv].removeEventListener("keydown", this[Lv]), this[Ap].removeEventListener("progress", this[Pv]);
      }
      async updated(t6) {
        super.updated(t6), t6.has("poster") && this.poster != null && (this[bv].style.backgroundImage = `url(${this.poster})`), t6.has("alt") && this[bv].setAttribute("aria-label", this[dp]), (t6.has("reveal") || t6.has("loading")) && this[gp](), t6.has("generateSchema") && (this.generateSchema === true ? this[_p].updateSchema(this.src) : this[_p].updateSchema(null)), t6.has("seamlessPoster") && (this.seamlessPoster === true ? this[xv].classList.add("quick") : this[xv].classList.remove("quick"));
      }
      [(n8 = Mv, i6 = Ev, r5 = Tv, s6 = _v, a4 = xv, o7 = bv, l6 = vv, h4 = yv, c3 = Rv, u3 = Sv, d3 = Cv, p3 = Lv, m3 = Pv, Lp)]() {
        return !!this.src && (this[_v] != null || this.loading === fv || this.reveal === dv2 && this[hp]);
      }
      [Pp]() {
        const { src: t6 } = this;
        return !!t6 && super[Pp]() && this[Tv] === 1;
      }
      [(f3 = Av, wv)]() {
        this[_v] = null;
        const t6 = this[xv];
        if (t6.classList.contains("show")) {
          const e8 = this.modelIsVisible;
          this[Mv] = true, this[cp](e8), requestAnimationFrame(() => {
            t6.classList.remove("show"), this.seamlessPoster === true ? this[Av]() : t6.addEventListener("transitionend", this[Av], { once: true });
          });
        } else
          this[Ev] = true;
      }
      [Cp]() {
        return super[Cp]() && this[Mv];
      }
      [Dp]() {
        return super[Dp]() && this[Ev];
      }
      async [gp]() {
        this[Tv] = 0, this.generateSchema === true && this[_p].updateSchema(this.src), this[_p].currentGLTF != null && this.src != null && this[Lp]() || this.showPoster(), this[mp]("Loading"), await super[gp]();
      }
    }
    return uv([e7({ type: String })], g3.prototype, "poster", void 0), uv([e7({ type: String })], g3.prototype, "reveal", void 0), uv([e7({ type: String })], g3.prototype, "loading", void 0), uv([e7({ type: Boolean, attribute: "generate-schema" })], g3.prototype, "generateSchema", void 0), uv([e7({ type: Boolean, attribute: "seamless-poster" })], g3.prototype, "seamlessPoster", void 0), g3;
  })(((t5) => {
    var n8;
    class i6 extends t5 {
      constructor(...t6) {
        super(t6), this.autoplay = false, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[n8] = true, this[_p].subscribeMixerEvent("loop", (t7) => {
          const e8 = t7.action._loopCount;
          this.dispatchEvent(new CustomEvent("loop", { detail: { count: e8 } }));
        }), this[_p].subscribeMixerEvent("finished", () => {
          this[kp] = true, this.dispatchEvent(new CustomEvent("finished"));
        });
      }
      get availableAnimations() {
        return this.loaded ? this[_p].animationNames : [];
      }
      get duration() {
        return this[_p].duration;
      }
      get paused() {
        return this[kp];
      }
      get currentTime() {
        return this[_p].animationTime;
      }
      set currentTime(t6) {
        this[_p].animationTime = t6, this[wp]();
      }
      get timeScale() {
        return this[_p].animationTimeScale;
      }
      set timeScale(t6) {
        this[_p].animationTimeScale = t6;
      }
      pause() {
        this[kp] || (this[kp] = true, this.dispatchEvent(new CustomEvent("pause")));
      }
      play(t6) {
        this.availableAnimations.length > 0 && (this[kp] = false, this[Up](t6), this.dispatchEvent(new CustomEvent("play")));
      }
      [(n8 = kp, Sp)]() {
        super[Sp](), this[kp] = true, this.autoplay && this.play();
      }
      [Mp](t6, e8) {
        super[Mp](t6, e8), this[kp] || !this[Dp]() && !this[Ep].isPresenting || (this[_p].updateAnimation(e8 / 1e3), this[wp]());
      }
      updated(t6) {
        super.updated(t6), t6.has("autoplay") && this.autoplay && this.play(), t6.has("animationName") && this[Up]();
      }
      async [gp]() {
        return this[_p].stopAnimation(), super[gp]();
      }
      [Up](t6 = Bp) {
        var e8;
        const n9 = (e8 = t6.repetitions) !== null && e8 !== void 0 ? e8 : 1 / 0, i7 = t6.pingpong ? 2202 : n9 === 1 ? 2200 : 2201;
        this[_p].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, i7, n9), this[kp] && (this[_p].updateAnimation(0), this[wp]());
      }
    }
    return Fp([e7({ type: Boolean })], i6.prototype, "autoplay", void 0), Fp([e7({ type: String, attribute: "animation-name" })], i6.prototype, "animationName", void 0), Fp([e7({ type: Number, attribute: "animation-crossfade-duration" })], i6.prototype, "animationCrossfadeDuration", void 0), i6;
  })(((t5) => {
    var e8;
    const n8 = Symbol("endPolyfillCoordination");
    return e8 = n8, class extends t5 {
      constructor() {
        super(...arguments), this[e8] = null;
      }
      connectedCallback() {
        super.connectedCallback && super.connectedCallback(), this[n8] == null && (this[n8] = ((t6) => {
          if (t6.shadowRoot == null || t6.hasAttribute("data-js-focus-visible"))
            return () => {
            };
          if (!self.applyFocusVisiblePolyfill) {
            const e9 = () => {
              self.applyFocusVisiblePolyfill(t6.shadowRoot);
            };
            return self.addEventListener("focus-visible-polyfill-ready", e9, { once: true }), () => {
              self.removeEventListener("focus-visible-polyfill-ready", e9);
            };
          }
          return self.applyFocusVisiblePolyfill(t6.shadowRoot), () => {
          };
        })(this));
      }
      disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback(), this[n8] != null && (this[n8](), this[n8] = null);
      }
    };
  })(Np)))))))));
  customElements.define("model-viewer", ab);

  // src/uni-media.ts
  var UniMedia = class extends s4 {
    constructor() {
      super(...arguments);
      this._mediaType = null;
      this._error = null;
      this._src = null;
    }
    async handleSrcChanged() {
      if (this.src) {
        try {
          let result;
          if (this.mediaType) {
            this._mediaType = this.mediaType;
            result = { mediaType: this.mediaType, mimeType: null, src: this.src };
          } else if (this.mimetype) {
            this._mediaType = mimeTypeToMediaType(this.mimetype);
            result = {
              mediaType: this._mediaType,
              mimeType: this.mimetype,
              src: this.src
            };
          } else {
            result = await getMediaType(this.src, {
              ipfsGateway: this.ipfsGateway
            });
            this._mediaType = result.mediaType;
          }
          this._src = result.src;
          this.dispatchEvent(new CustomEvent("filetype", {
            detail: {
              mediaType: result.mediaType,
              mimeType: result.mimeType,
              src: this.src
            },
            bubbles: true,
            composed: true
          }));
        } catch (e8) {
          console.error(e8);
          e8.detail = {
            mediaType: void 0,
            mimeType: void 0,
            src: this.src
          };
          this._error = e8;
          this.dispatchEvent(new ErrorEvent("filetype-error", {
            error: e8,
            bubbles: true,
            composed: true
          }));
        }
      } else {
        const e8 = new Error("src is required");
        this._error = e8;
        this.dispatchEvent(new ErrorEvent("filetype-error", {
          error: e8,
          bubbles: true,
          composed: true
        }));
      }
    }
    requestUpdate(name, oldValue, options) {
      super.requestUpdate(name, oldValue, options);
      if (name === "src") {
        this.handleSrcChanged();
      }
    }
    render() {
      var _a2;
      if (!this.src || this._error) {
        return $`<slot name="error"
        >Some error occurs! ${(_a2 = this._error) == null ? void 0 : _a2.message}</slot
      >`;
      }
      if (!this._mediaType) {
        return $`<slot name="loading">Loading</slot>`;
      }
      if (!this._src) {
        return $`<slot name="error">Some error occurs! Can't find src</slot>`;
      }
      if (this._mediaType === "image") {
        return $`<img src="${this._src}" ${spreadProps()} />`;
      }
      if (this._mediaType === "video") {
        return $`<video src="${this._src}" controls ${spreadProps()}>
        <slot></slot>
      </video>`;
      }
      if (this._mediaType === "audio") {
        return $`<audio src="${this._src}" controls ${spreadProps()}>
        <slot></slot>
      </audio>`;
      }
      if (this._mediaType === "model") {
        return $`<model-viewer src="${this._src}" ${spreadProps()}>
        <slot></slot>
      </model-viewer>`;
      }
      if (this._mediaType === "pdf") {
        return $`<iframe src="${this._src}" ${spreadProps()} />`;
      }
      if (this._mediaType === "html") {
        return $`<iframe src="${this._src}" ${spreadProps()} />`;
      }
      return $`<slot name="unsupported"></slot>`;
    }
  };
  __decorateClass([
    e4({ type: String })
  ], UniMedia.prototype, "src", 2);
  __decorateClass([
    e4({ type: String, attribute: "mimetype" })
  ], UniMedia.prototype, "mimetype", 2);
  __decorateClass([
    e4({ type: String, attribute: "media-type" })
  ], UniMedia.prototype, "mediaType", 2);
  __decorateClass([
    e4({ type: String, attribute: "ipfs-gateway" })
  ], UniMedia.prototype, "ipfsGateway", 2);
  __decorateClass([
    t3()
  ], UniMedia.prototype, "_mediaType", 2);
  __decorateClass([
    t3()
  ], UniMedia.prototype, "_error", 2);
  __decorateClass([
    t3()
  ], UniMedia.prototype, "_src", 2);
  UniMedia = __decorateClass([
    n5("uni-media")
  ], UniMedia);
})();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
